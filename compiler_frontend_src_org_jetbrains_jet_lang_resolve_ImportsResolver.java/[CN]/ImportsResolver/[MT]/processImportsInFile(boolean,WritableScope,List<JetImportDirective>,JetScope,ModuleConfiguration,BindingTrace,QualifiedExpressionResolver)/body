{
  Importer.DelayedImporter delayedImporter=new Importer.DelayedImporter(namespaceScope);
  if (!onlyClasses) {
    namespaceScope.clearImports();
  }
  Map<JetImportDirective,DeclarationDescriptor> resolvedDirectives=Maps.newHashMap();
  Collection<JetImportDirective> defaultImportDirectives=Lists.newArrayList();
  configuration.addDefaultImports(defaultImportDirectives);
  for (  JetImportDirective defaultImportDirective : defaultImportDirectives) {
    TemporaryBindingTrace temporaryTrace=TemporaryBindingTrace.create(trace);
    qualifiedExpressionResolver.processImportReference(defaultImportDirective,rootScope,namespaceScope,delayedImporter,temporaryTrace,onlyClasses);
  }
  for (  JetImportDirective importDirective : importDirectives) {
    Collection<? extends DeclarationDescriptor> descriptors=qualifiedExpressionResolver.processImportReference(importDirective,rootScope,namespaceScope,delayedImporter,trace,onlyClasses);
    if (descriptors.size() == 1) {
      resolvedDirectives.put(importDirective,descriptors.iterator().next());
    }
    for (    DeclarationDescriptor descriptor : descriptors) {
      if (descriptor instanceof ClassDescriptor && !onlyClasses) {
        FqNameUnsafe fqName=DescriptorUtils.getFQName(descriptor);
        Collection<ClassDescriptor> kotlinAnalogs=configuration.getKotlinAnalogs(fqName);
        JetExpression importedReference=importDirective.getImportedReference();
        if (importedReference != null && !kotlinAnalogs.isEmpty()) {
          trace.report(CLASS_HAS_KOTLIN_ANALOG.on(importedReference,kotlinAnalogs));
        }
      }
    }
  }
  delayedImporter.processImports();
  if (!onlyClasses) {
    for (    JetImportDirective importDirective : importDirectives) {
      reportUselessImport(importDirective,namespaceScope,resolvedDirectives,trace);
    }
  }
}
