{
  checkForBuiltIns(fqName,files);
  LightClassConstructionContext context=LightClassGenerationSupport.getInstance(project).analyzeRelevantCode(files);
  Throwable error=context.getError();
  if (error != null) {
    throw new IllegalStateException("failed to analyze: " + error,error);
  }
  PsiJavaFileStubImpl javaFileStub=new PsiJavaFileStubImpl(fqName.parent().getFqName(),true);
  try {
    Stack<StubElement> stubStack=new Stack<StubElement>();
    ClassBuilderFactory builderFactory=new KotlinLightClassBuilderFactory(stubStack);
    GenerationState state=new GenerationState(project,builderFactory,Progress.DEAF,context.getBindingContext(),Lists.newArrayList(files),BuiltinToJavaTypesMapping.ENABLED,false,false,stubGenerationStrategy.generateDeclaredClasses());
    GenerationStrategy strategy=new LightClassGenerationStrategy(new LightVirtualFile(),stubStack,javaFileStub);
    stubGenerationStrategy.generate(state,strategy);
  }
 catch (  ProcessCanceledException e) {
    throw e;
  }
catch (  RuntimeException e) {
    logErrorWithOSInfo(e,fqName,null);
    throw e;
  }
  PsiClass psiClass=findClass(fqName,javaFileStub);
  if (psiClass == null) {
    throw new IllegalStateException("Class was not found " + fqName + " for files "+ files);
  }
  List<Object> dependencies=Lists.<Object>newArrayList(files);
  dependencies.add(PsiModificationTracker.OUT_OF_CODE_BLOCK_MODIFICATION_COUNT);
  return Result.create(psiClass,files);
}
