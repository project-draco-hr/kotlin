{
  final JetScope scopeForConstructor=primaryConstructor == null ? null : FunctionDescriptorUtil.getFunctionInnerScope(scopeForSupertypeResolution,primaryConstructor,trace);
  final ExpressionTypingServices typeInferrer=expressionTypingServices;
  final Map<JetTypeReference,JetType> supertypes=Maps.newLinkedHashMap();
  final ResolvedCall<?>[] primaryConstructorDelegationCall=new ResolvedCall[1];
  JetVisitorVoid visitor=new JetVisitorVoid(){
    private void recordSupertype(    JetTypeReference typeReference,    JetType supertype){
      if (supertype == null)       return;
      supertypes.put(typeReference,supertype);
    }
    @Override public void visitDelegationByExpressionSpecifier(    @NotNull JetDelegatorByExpressionSpecifier specifier){
      if (descriptor.getKind() == ClassKind.INTERFACE) {
        trace.report(DELEGATION_IN_TRAIT.on(specifier));
      }
      JetType supertype=trace.getBindingContext().get(BindingContext.TYPE,specifier.getTypeReference());
      recordSupertype(specifier.getTypeReference(),supertype);
      if (supertype != null) {
        DeclarationDescriptor declarationDescriptor=supertype.getConstructor().getDeclarationDescriptor();
        if (declarationDescriptor instanceof ClassDescriptor) {
          ClassDescriptor classDescriptor=(ClassDescriptor)declarationDescriptor;
          if (classDescriptor.getKind() != ClassKind.INTERFACE) {
            trace.report(DELEGATION_NOT_TO_TRAIT.on(specifier.getTypeReference()));
          }
        }
      }
      JetExpression delegateExpression=specifier.getDelegateExpression();
      if (delegateExpression != null) {
        JetScope scope=scopeForConstructor == null ? scopeForMemberResolution : scopeForConstructor;
        JetType expectedType=supertype != null ? supertype : NO_EXPECTED_TYPE;
        typeInferrer.getType(scope,delegateExpression,expectedType,c.getOuterDataFlowInfo(),trace);
      }
      if (primaryConstructor == null) {
        trace.report(UNSUPPORTED.on(specifier,"Delegation without primary constructor is not supported"));
      }
    }
    @Override public void visitDelegationToSuperCallSpecifier(    @NotNull JetDelegatorToSuperCall call){
      JetValueArgumentList valueArgumentList=call.getValueArgumentList();
      PsiElement elementToMark=valueArgumentList == null ? call : valueArgumentList;
      if (descriptor.getKind() == ClassKind.INTERFACE) {
        trace.report(SUPERTYPE_INITIALIZED_IN_TRAIT.on(elementToMark));
      }
      JetTypeReference typeReference=call.getTypeReference();
      if (typeReference == null)       return;
      if (primaryConstructor == null) {
        if (descriptor.getKind() != ClassKind.INTERFACE) {
          trace.report(SUPERTYPE_INITIALIZED_WITHOUT_PRIMARY_CONSTRUCTOR.on(call));
        }
        recordSupertype(typeReference,trace.getBindingContext().get(BindingContext.TYPE,typeReference));
        return;
      }
      OverloadResolutionResults<FunctionDescriptor> results=callResolver.resolveFunctionCall(trace,scopeForConstructor,CallMaker.makeCall(ReceiverValue.NO_RECEIVER,null,call),NO_EXPECTED_TYPE,c.getOuterDataFlowInfo(),false);
      if (results.isSuccess()) {
        JetType supertype=results.getResultingDescriptor().getReturnType();
        recordSupertype(typeReference,supertype);
        ClassDescriptor classDescriptor=TypeUtils.getClassDescriptor(supertype);
        if (classDescriptor != null) {
          if (primaryConstructorDelegationCall[0] == null) {
            primaryConstructorDelegationCall[0]=results.getResultingCall();
          }
 else {
            primaryConstructorDelegationCall[0]=null;
          }
        }
        trace.record(PROCESSED,call.getCalleeExpression(),true);
        trace.record(EXPRESSION_TYPE_INFO,call.getCalleeExpression(),TypeInfoFactoryPackage.noTypeInfo(results.getResultingCall().getDataFlowInfoForArguments().getResultInfo()));
      }
 else {
        recordSupertype(typeReference,trace.getBindingContext().get(BindingContext.TYPE,typeReference));
      }
    }
    @Override public void visitDelegationToSuperClassSpecifier(    @NotNull JetDelegatorToSuperClass specifier){
      JetTypeReference typeReference=specifier.getTypeReference();
      JetType supertype=trace.getBindingContext().get(BindingContext.TYPE,typeReference);
      recordSupertype(typeReference,supertype);
      if (supertype == null)       return;
      ClassDescriptor superClass=TypeUtils.getClassDescriptor(supertype);
      if (superClass == null)       return;
      if (superClass.getKind().isSingleton()) {
        return;
      }
      if (descriptor.getKind() != ClassKind.INTERFACE && descriptor.getUnsubstitutedPrimaryConstructor() != null && !superClass.getConstructors().isEmpty() && !ErrorUtils.isError(superClass)) {
        trace.report(SUPERTYPE_NOT_INITIALIZED.on(specifier));
      }
    }
    @Override public void visitJetElement(    @NotNull JetElement element){
      throw new UnsupportedOperationException(element.getText() + " : " + element);
    }
  }
;
  for (  JetDelegationSpecifier delegationSpecifier : jetClass.getDelegationSpecifiers()) {
    delegationSpecifier.accept(visitor);
  }
  if (DescriptorUtils.isAnnotationClass(descriptor) && jetClass.getDelegationSpecifierList() != null) {
    trace.report(SUPERTYPES_FOR_ANNOTATION_CLASS.on(jetClass.getDelegationSpecifierList()));
  }
  Set<TypeConstructor> parentEnum=jetClass instanceof JetEnumEntry ? Collections.singleton(((ClassDescriptor)descriptor.getContainingDeclaration()).getTypeConstructor()) : Collections.<TypeConstructor>emptySet();
  if (primaryConstructorDelegationCall[0] != null && primaryConstructor != null) {
    recordConstructorDelegationCall(trace,primaryConstructor,primaryConstructorDelegationCall[0]);
  }
  checkSupertypeList(descriptor,supertypes,parentEnum);
}
