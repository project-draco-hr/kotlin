{
  Set<TypeConstructor> typeConstructors=Sets.newHashSet();
  boolean classAppeared=false;
  for (  Map.Entry<JetTypeReference,JetType> entry : supertypes.entrySet()) {
    JetTypeReference typeReference=entry.getKey();
    JetType supertype=entry.getValue();
    ClassDescriptor classDescriptor=TypeUtils.getClassDescriptor(supertype);
    if (classDescriptor != null) {
      if (classDescriptor.getKind() != ClassKind.TRAIT) {
        if (supertypeOwner.getKind() == ClassKind.ENUM_CLASS) {
          trace.report(CLASS_IN_SUPERTYPE_FOR_ENUM.on(typeReference));
        }
 else         if (supertypeOwner.getKind() == ClassKind.TRAIT && !classAppeared && !TypesPackage.isDynamic(supertype)) {
          trace.report(TRAIT_WITH_SUPERCLASS.on(typeReference));
        }
        if (classAppeared) {
          trace.report(MANY_CLASSES_IN_SUPERTYPE_LIST.on(typeReference));
        }
 else {
          classAppeared=true;
        }
      }
    }
 else {
      trace.report(SUPERTYPE_NOT_A_CLASS_OR_TRAIT.on(typeReference));
    }
    TypeConstructor constructor=supertype.getConstructor();
    if (!typeConstructors.add(constructor)) {
      trace.report(SUPERTYPE_APPEARS_TWICE.on(typeReference));
    }
    if (DescriptorUtils.isSingleton(classDescriptor)) {
      trace.report(SINGLETON_IN_SUPERTYPE.on(typeReference));
    }
 else     if (constructor.isFinal() && !allowedFinalSupertypes.contains(constructor)) {
      trace.report(FINAL_SUPERTYPE.on(typeReference));
    }
  }
}
