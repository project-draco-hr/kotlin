{
  Set<TypeConstructor> parentEnumOrSealed=Collections.emptySet();
  if (ktClassOrObject instanceof KtEnumEntry) {
    parentEnumOrSealed=Collections.singleton(((ClassDescriptor)descriptor.getContainingDeclaration()).getTypeConstructor());
  }
 else   if (languageVersionSettings.supportsFeature(TopLevelSealedInheritance) && DescriptorUtils.isTopLevelDeclaration(descriptor)) {
    for (    KotlinType supertype : supertypes.values()) {
      ClassifierDescriptor classifierDescriptor=supertype.getConstructor().getDeclarationDescriptor();
      if (DescriptorUtils.isSealedClass(classifierDescriptor) && DescriptorUtils.isTopLevelDeclaration(classifierDescriptor)) {
        parentEnumOrSealed=Collections.singleton(classifierDescriptor.getTypeConstructor());
      }
    }
  }
 else {
    ClassDescriptor currentDescriptor=descriptor;
    while (currentDescriptor.getContainingDeclaration() instanceof ClassDescriptor) {
      currentDescriptor=(ClassDescriptor)currentDescriptor.getContainingDeclaration();
      if (DescriptorUtils.isSealedClass(currentDescriptor)) {
        if (parentEnumOrSealed.isEmpty()) {
          parentEnumOrSealed=new HashSet<TypeConstructor>();
        }
        parentEnumOrSealed.add(currentDescriptor.getTypeConstructor());
      }
    }
  }
  return parentEnumOrSealed;
}
