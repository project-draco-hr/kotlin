{
  TypeInferenceContext context=contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE);
  JetSimpleNameExpression operationSign=expression.getOperationReference();
  JetExpression left=expression.getLeft();
  JetExpression right=expression.getRight();
  JetType result=null;
  IElementType operationType=operationSign.getReferencedNameElementType();
  if (operationType == JetTokens.IDENTIFIER) {
    String referencedName=operationSign.getReferencedName();
    if (referencedName != null) {
      result=getTypeForBinaryCall(context.scope,referencedName,context,expression);
    }
  }
 else   if (binaryOperationNames.containsKey(operationType)) {
    result=getTypeForBinaryCall(context.scope,binaryOperationNames.get(operationType),context,expression);
  }
 else   if (operationType == JetTokens.EQ) {
    result=visitAssignment(expression,context);
  }
 else   if (assignmentOperationNames.containsKey(operationType)) {
    result=visitAssignmentOperation(expression,context);
  }
 else   if (comparisonOperations.contains(operationType)) {
    JetType compareToReturnType=getTypeForBinaryCall(context.scope,"compareTo",context,expression);
    if (compareToReturnType != null) {
      TypeConstructor constructor=compareToReturnType.getConstructor();
      JetStandardLibrary standardLibrary=semanticServices.getStandardLibrary();
      TypeConstructor intTypeConstructor=standardLibrary.getInt().getTypeConstructor();
      if (constructor.equals(intTypeConstructor)) {
        result=standardLibrary.getBooleanType();
      }
 else {
        context.trace.report(COMPARE_TO_TYPE_MISMATCH.on(operationSign,compareToReturnType));
      }
    }
  }
 else   if (equalsOperations.contains(operationType)) {
    String name="equals";
    if (right != null) {
      ExpressionReceiver receiver=safeGetExpressionReceiver(left,context.replaceScope(context.scope));
      OverloadResolutionResults<FunctionDescriptor> resolutionResults=context.resolveExactSignature(receiver,"equals",Collections.singletonList(JetStandardClasses.getNullableAnyType()));
      if (resolutionResults.isSuccess()) {
        FunctionDescriptor equals=resolutionResults.getResult().getResultingDescriptor();
        context.trace.record(REFERENCE_TARGET,operationSign,equals);
        if (ensureBooleanResult(operationSign,name,equals.getReturnType(),context)) {
          ensureNonemptyIntersectionOfOperandTypes(expression,context);
        }
      }
 else {
        if (resolutionResults.isAmbiguity()) {
          context.trace.report(OVERLOAD_RESOLUTION_AMBIGUITY.on(operationSign,resolutionResults.getResults()));
        }
 else {
          context.trace.report(EQUALS_MISSING.on(operationSign));
        }
      }
    }
    result=semanticServices.getStandardLibrary().getBooleanType();
  }
 else   if (operationType == JetTokens.EQEQEQ || operationType == JetTokens.EXCLEQEQEQ) {
    ensureNonemptyIntersectionOfOperandTypes(expression,context);
    result=semanticServices.getStandardLibrary().getBooleanType();
  }
 else   if (inOperations.contains(operationType)) {
    if (right == null) {
      result=ErrorUtils.createErrorType("No right argument");
      return null;
    }
    checkInExpression(operationSign,left,right,context);
    result=semanticServices.getStandardLibrary().getBooleanType();
  }
 else   if (operationType == JetTokens.ANDAND || operationType == JetTokens.OROR) {
    JetType leftType=getType(left,context.replaceScope(context.scope));
    WritableScopeImpl leftScope=newWritableScopeImpl(context.scope,context.trace).setDebugName("Left scope of && or ||");
    DataFlowInfo flowInfoLeft=extractDataFlowInfoFromCondition(left,operationType == JetTokens.ANDAND,leftScope,context);
    WritableScopeImpl rightScope=operationType == JetTokens.ANDAND ? leftScope : newWritableScopeImpl(context.scope,context.trace).setDebugName("Right scope of && or ||");
    JetType rightType=right == null ? null : getType(right,context.replaceDataFlowInfo(flowInfoLeft).replaceScope(rightScope));
    if (leftType != null && !isBoolean(leftType)) {
      context.trace.report(TYPE_MISMATCH.on(left,semanticServices.getStandardLibrary().getBooleanType(),leftType));
    }
    if (rightType != null && !isBoolean(rightType)) {
      context.trace.report(TYPE_MISMATCH.on(right,semanticServices.getStandardLibrary().getBooleanType(),rightType));
    }
    result=semanticServices.getStandardLibrary().getBooleanType();
  }
 else   if (operationType == JetTokens.ELVIS) {
    JetType leftType=getType(left,context.replaceScope(context.scope));
    JetType rightType=right == null ? null : getType(right,contextWithExpectedType.replaceScope(context.scope));
    if (leftType != null) {
      if (!leftType.isNullable()) {
        context.trace.report(USELESS_ELVIS.on(expression,left,leftType));
      }
      if (rightType != null) {
        context.services.checkType(TypeUtils.makeNullableAsSpecified(leftType,rightType.isNullable()),left,contextWithExpectedType);
        return TypeUtils.makeNullableAsSpecified(semanticServices.getTypeChecker().commonSupertype(leftType,rightType),rightType.isNullable());
      }
    }
  }
 else {
    context.trace.report(UNSUPPORTED.on(operationSign,"Unknown operation"));
  }
  return context.services.checkType(result,expression,contextWithExpectedType);
}
