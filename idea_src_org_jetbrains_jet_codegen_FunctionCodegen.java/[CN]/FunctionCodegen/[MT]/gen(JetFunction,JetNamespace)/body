{
  final List<JetParameter> parameters=f.getValueParameters();
  Type[] parameterTypes=new Type[parameters.size()];
  for (int i=0; i < parameters.size(); i++) {
    parameterTypes[i]=mapTypeReference(parameters.get(i).getTypeReference());
  }
  final JetTypeReference returnTypeRef=f.getReturnTypeRef();
  Type returnType;
  if (returnTypeRef == null) {
    final FunctionDescriptor functionDescriptor=bindingContext.getFunctionDescriptor(f);
    final org.jetbrains.jet.lang.types.Type type=functionDescriptor.getUnsubstitutedReturnType();
    if (type.equals(JetStandardClasses.getUnitType())) {
      returnType=Type.VOID_TYPE;
    }
 else     if (type.equals(standardLibrary.getIntType())) {
      returnType=Type.getType(Integer.class);
    }
 else {
      throw new UnsupportedOperationException("don't know how to map type " + type);
    }
  }
 else {
    returnType=mapTypeReference(returnTypeRef);
  }
  Method method=new Method(f.getName(),returnType,parameterTypes);
  final MethodVisitor mv=v.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,method.getName(),method.getDescriptor(),null,null);
  mv.visitCode();
  final JetExpression bodyExpression=f.getBodyExpression();
  FrameMap frameMap=new FrameMap();
  List<ValueParameterDescriptor> parameDescrs=bindingContext.getFunctionDescriptor(f).getUnsubstitutedValueParameters();
  for (  ValueParameterDescriptor parameter : parameDescrs) {
    frameMap.enter(parameter);
  }
  bodyExpression.accept(new ExpressionCodegen(mv,bindingContext,frameMap));
  generateReturn(mv,bodyExpression);
  mv.visitMaxs(0,0);
  mv.visitEnd();
}
