{
  int flags=Opcodes.ACC_PUBLIC;
  boolean isStatic=kind == OwnerKind.NAMESPACE;
  if (isStatic)   flags|=Opcodes.ACC_STATIC;
  final JetExpression bodyExpression=f.getBodyExpression();
  boolean isAbstract=kind == OwnerKind.INTERFACE || bodyExpression == null;
  if (isAbstract)   flags|=Opcodes.ACC_ABSTRACT;
  DeclarationDescriptor contextDescriptor=owner instanceof JetClass ? bindingContext.getClassDescriptor((JetClass)owner) : bindingContext.getNamespaceDescriptor((JetNamespace)owner);
  final MethodVisitor mv=v.visitMethod(flags,jvmSignature.getName(),jvmSignature.getDescriptor(),null,null);
  if (kind != OwnerKind.INTERFACE) {
    mv.visitCode();
    FrameMap frameMap=new FrameMap();
    if (kind != OwnerKind.NAMESPACE) {
      frameMap.enterTemp();
    }
    Type[] argTypes=jvmSignature.getArgumentTypes();
    for (int i=0; i < paramDescrs.size(); i++) {
      ValueParameterDescriptor parameter=paramDescrs.get(i);
      frameMap.enter(parameter,argTypes[i].getSize());
    }
    ExpressionCodegen codegen=new ExpressionCodegen(mv,bindingContext,frameMap,typeMapper,jvmSignature.getReturnType(),contextDescriptor,kind);
    if (kind instanceof OwnerKind.DelegateKind) {
      OwnerKind.DelegateKind dk=(OwnerKind.DelegateKind)kind;
      InstructionAdapter iv=new InstructionAdapter(mv);
      iv.load(0,JetTypeMapper.TYPE_OBJECT);
      dk.getDelegate().put(JetTypeMapper.TYPE_OBJECT,iv);
      for (int i=0; i < argTypes.length; i++) {
        Type argType=argTypes[i];
        iv.load(i + 1,argType);
      }
      iv.invokeinterface(dk.getOwnerClass(),jvmSignature.getName(),jvmSignature.getDescriptor());
      iv.areturn(jvmSignature.getReturnType());
    }
 else {
      bodyExpression.accept(codegen);
      generateReturn(mv,bodyExpression,codegen);
    }
    mv.visitMaxs(0,0);
    mv.visitEnd();
  }
}
