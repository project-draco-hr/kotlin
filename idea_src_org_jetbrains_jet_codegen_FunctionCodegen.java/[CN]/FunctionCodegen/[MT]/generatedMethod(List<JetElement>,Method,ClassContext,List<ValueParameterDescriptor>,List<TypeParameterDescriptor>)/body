{
  int flags=Opcodes.ACC_PUBLIC;
  OwnerKind kind=context.getContextKind();
  boolean isStatic=kind == OwnerKind.NAMESPACE;
  if (isStatic)   flags|=Opcodes.ACC_STATIC;
  boolean isAbstract=kind == OwnerKind.INTERFACE || bodyExpressions == null;
  if (isAbstract)   flags|=Opcodes.ACC_ABSTRACT;
  if (isAbstract && (kind == OwnerKind.IMPLEMENTATION || kind == OwnerKind.DELEGATING_IMPLEMENTATION)) {
    return;
  }
  final MethodVisitor mv=v.visitMethod(flags,jvmSignature.getName(),jvmSignature.getDescriptor(),null,null);
  if (kind != OwnerKind.INTERFACE) {
    mv.visitCode();
    FrameMap frameMap=context.prepareFrame();
    ExpressionCodegen codegen=new ExpressionCodegen(mv,frameMap,jvmSignature.getReturnType(),context,state);
    Type[] argTypes=jvmSignature.getArgumentTypes();
    for (int i=0; i < paramDescrs.size(); i++) {
      ValueParameterDescriptor parameter=paramDescrs.get(i);
      frameMap.enter(parameter,argTypes[i].getSize());
    }
    for (    final TypeParameterDescriptor typeParameterDescriptor : typeParameters) {
      int slot=frameMap.enterTemp();
      codegen.addTypeParameter(typeParameterDescriptor,StackValue.local(slot,JetTypeMapper.TYPE_TYPEINFO));
    }
    if (kind instanceof OwnerKind.DelegateKind) {
      OwnerKind.DelegateKind dk=(OwnerKind.DelegateKind)kind;
      InstructionAdapter iv=new InstructionAdapter(mv);
      iv.load(0,JetTypeMapper.TYPE_OBJECT);
      dk.getDelegate().put(JetTypeMapper.TYPE_OBJECT,iv);
      for (int i=0; i < argTypes.length; i++) {
        Type argType=argTypes[i];
        iv.load(i + 1,argType);
      }
      iv.invokeinterface(dk.getOwnerClass(),jvmSignature.getName(),jvmSignature.getDescriptor());
      iv.areturn(jvmSignature.getReturnType());
    }
 else     if (!isAbstract) {
      JetElement last=null;
      for (      JetElement expression : bodyExpressions) {
        expression.accept(codegen);
        last=expression;
      }
      generateReturn(mv,last,codegen,jvmSignature);
    }
    mv.visitMaxs(0,0);
    mv.visitEnd();
  }
}
