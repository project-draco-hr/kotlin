{
  CompilerConfiguration configuration=new CompilerConfiguration();
  File runtimePath=paths.getRuntimePath();
  if (runtimePath.exists()) {
    addJvmClasspathRoot(configuration,runtimePath);
  }
  addJvmClasspathRoots(configuration,PathUtil.getJdkClassesRoots());
  File jdkAnnotationsPath=paths.getJdkAnnotationsPath();
  if (jdkAnnotationsPath.exists()) {
    configuration.add(JVMConfigurationKeys.ANNOTATIONS_PATH_KEY,jdkAnnotationsPath);
  }
  addKotlinSourceRoot(configuration,moduleScriptFile);
  configuration.put(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY,messageCollector);
  List<Module> modules;
  Disposable disposable=Disposer.newDisposable();
  try {
    KotlinCoreEnvironment scriptEnvironment=KotlinCoreEnvironment.createForProduction(disposable,configuration,EnvironmentConfigFiles.JVM_CONFIG_FILES);
    GenerationState generationState=KotlinToJVMBytecodeCompiler.analyzeAndGenerate(scriptEnvironment);
    if (generationState == null) {
      throw new CompileEnvironmentException("Module script " + moduleScriptFile + " analyze failed:\n"+ loadModuleScriptText(moduleScriptFile));
    }
    modules=runDefineModules(paths,generationState.getFactory());
  }
  finally {
    Disposer.dispose(disposable);
  }
  if (modules == null) {
    throw new CompileEnvironmentException("Module script " + moduleScriptFile + " compilation failed");
  }
  if (modules.isEmpty()) {
    throw new CompileEnvironmentException("No modules where defined by " + moduleScriptFile);
  }
  return new ModuleScriptData(modules);
}
