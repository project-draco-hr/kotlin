{
  final KotlinMethodFindUsagesOptions kotlinOptions=(KotlinMethodFindUsagesOptions)options;
  SearchScope searchScope=kotlinOptions.searchScope;
  JetElement blockForLocalDeclaration=JetPsiUtil.getEnclosingBlockForLocalDeclaration((JetNamedFunction)element);
  if (blockForLocalDeclaration != null && kotlinOptions.isUsages) {
    BindingContext bindingContext=AnalyzerFacadeWithCache.analyzeFileWithCache((JetFile)element.getContainingFile()).getBindingContext();
    final List<PsiReference> result=new ArrayList<PsiReference>();
    CalleeReferenceVisitorBase visitor=new CalleeReferenceVisitorBase(bindingContext,true){
      private boolean isAcceptable(      PsiElement declaration){
        if (kotlinOptions.isIncludeOverloadUsages) {
          return declaration instanceof JetNamedFunction && ((JetNamedFunction)element).getName().equals(((JetNamedFunction)declaration).getName());
        }
        return declaration.equals(element);
      }
      @Override protected void processDeclaration(      JetReferenceExpression reference,      PsiElement declaration){
        if (isAcceptable(declaration)) {
          result.add(reference.getReference());
        }
      }
    }
;
    blockForLocalDeclaration.accept(visitor);
    for (    PsiReference ref : result) {
      if (!processUsage(processor,ref,kotlinOptions))       return false;
    }
    return true;
  }
  final PsiMethod lightMethod=ApplicationManager.getApplication().runReadAction(new Computable<PsiMethod>(){
    @Override public PsiMethod compute(){
      return LightClassUtil.getLightClassMethod(getElement());
    }
  }
);
  if (lightMethod == null)   return true;
  if (kotlinOptions.isUsages) {
    boolean strictSignatureSearch=!kotlinOptions.isIncludeOverloadUsages;
    if (!MethodReferencesSearch.search(new MethodReferencesSearch.SearchParameters(lightMethod,searchScope,strictSignatureSearch,kotlinOptions.fastTrack)).forEach(new ReadActionProcessor<PsiReference>(){
      @Override public boolean processInReadAction(      PsiReference ref){
        return processUsage(processor,ref,kotlinOptions);
      }
    }
)) {
      return false;
    }
  }
  boolean isAbstract=ApplicationManager.getApplication().runReadAction(new Computable<Boolean>(){
    @Override public Boolean compute(){
      return lightMethod.hasModifierProperty(PsiModifier.ABSTRACT);
    }
  }
);
  if (isAbstract && kotlinOptions.isImplementingMethods || kotlinOptions.isOverridingMethods) {
    OverridingMethodsSearch.search(lightMethod,options.searchScope,kotlinOptions.isCheckDeepInheritance).forEach(new PsiElementProcessorAdapter<PsiMethod>(new PsiElementProcessor<PsiMethod>(){
      @Override public boolean execute(      @NotNull PsiMethod element){
        return processUsage(processor,element.getNavigationElement(),kotlinOptions);
      }
    }
));
  }
  if (kotlinOptions.isIncludeOverloadUsages) {
    String name=((PsiNamedElement)element).getName();
    if (name == null)     return true;
    for (    PsiReference ref : KotlinExtensionSearch.search(lightMethod,searchScope).findAll()) {
      processUsage(processor,ref,kotlinOptions);
    }
  }
  return true;
}
