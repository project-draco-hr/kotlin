{
  namedMethods.put(KOTLIN_JAVA_CLASS_FUNCTION,new JavaClassFunction());
  namedMethods.put(KOTLIN_JAVA_CLASS_PROPERTY,new JavaClassProperty());
  namedMethods.put(KOTLIN_ARRAYS_ARRAY,new JavaClassArray());
  namedMethods.put(KOTLIN_COPY_TO_ARRAY,new CopyToArray());
  namedMethods.put(KOTLIN_HASH_CODE,HASH_CODE);
  namedMethods.put(KOTLIN_TO_STRING,TO_STRING);
  ImmutableList<Name> primitiveCastMethods=OperatorConventions.NUMBER_CONVERSIONS.asList();
  for (  Name method : primitiveCastMethods) {
    declareIntrinsicFunction(Name.identifier("Number"),method,0,NUMBER_CAST);
    for (    PrimitiveType type : PrimitiveType.NUMBER_TYPES) {
      declareIntrinsicFunction(type.getTypeName(),method,0,NUMBER_CAST);
    }
  }
  for (  PrimitiveType type : PrimitiveType.NUMBER_TYPES) {
    Name typeName=type.getTypeName();
    declareIntrinsicFunction(typeName,Name.identifier("plus"),0,UNARY_PLUS);
    declareIntrinsicFunction(typeName,Name.identifier("minus"),0,UNARY_MINUS);
    declareIntrinsicFunction(typeName,Name.identifier("inv"),0,INV);
    declareIntrinsicFunction(typeName,Name.identifier("rangeTo"),1,RANGE_TO);
    declareIntrinsicFunction(typeName,Name.identifier("inc"),0,INC);
    declareIntrinsicFunction(typeName,Name.identifier("dec"),0,DEC);
    declareIntrinsicFunction(typeName,Name.identifier("hashCode"),0,HASH_CODE);
    declareIntrinsicFunction(typeName,Name.identifier("equals"),1,EQUALS);
  }
  declareBinaryOp(Name.identifier("plus"),IADD);
  declareBinaryOp(Name.identifier("minus"),ISUB);
  declareBinaryOp(Name.identifier("times"),IMUL);
  declareBinaryOp(Name.identifier("div"),IDIV);
  declareBinaryOp(Name.identifier("mod"),IREM);
  declareBinaryOp(Name.identifier("shl"),ISHL);
  declareBinaryOp(Name.identifier("shr"),ISHR);
  declareBinaryOp(Name.identifier("ushr"),IUSHR);
  declareBinaryOp(Name.identifier("and"),IAND);
  declareBinaryOp(Name.identifier("or"),IOR);
  declareBinaryOp(Name.identifier("xor"),IXOR);
  declareIntrinsicFunction(Name.identifier("Boolean"),Name.identifier("not"),0,new Not());
  declareIntrinsicFunction(Name.identifier("String"),Name.identifier("plus"),1,new Concat());
  declareIntrinsicFunction(Name.identifier("CharSequence"),Name.identifier("get"),1,new StringGetChar());
  declareIntrinsicFunction(Name.identifier("String"),Name.identifier("get"),1,new StringGetChar());
  FqName builtInsPackageFqName=KotlinBuiltIns.getInstance().getBuiltInsPackageFqName();
  intrinsicsMap.registerIntrinsic(builtInsPackageFqName,Name.identifier("name"),0,new EnumName());
  intrinsicsMap.registerIntrinsic(builtInsPackageFqName,Name.identifier("ordinal"),0,new EnumOrdinal());
  intrinsicsMap.registerIntrinsic(builtInsPackageFqName,Name.identifier("toString"),0,TO_STRING);
  intrinsicsMap.registerIntrinsic(builtInsPackageFqName,Name.identifier("equals"),1,EQUALS);
  intrinsicsMap.registerIntrinsic(builtInsPackageFqName,Name.identifier("identityEquals"),1,IDENTITY_EQUALS);
  intrinsicsMap.registerIntrinsic(builtInsPackageFqName,Name.identifier("plus"),1,STRING_PLUS);
  intrinsicsMap.registerIntrinsic(builtInsPackageFqName,Name.identifier("arrayOfNulls"),1,new NewArray());
  intrinsicsMap.registerIntrinsic(builtInsPackageFqName,Name.identifier("synchronized"),2,new StupidSync());
  intrinsicsMap.registerIntrinsic(builtInsPackageFqName,Name.identifier("iterator"),0,new IteratorIterator());
  declareIntrinsicFunction(Name.identifier("ByteIterator"),Name.identifier("next"),0,ITERATOR_NEXT);
  declareIntrinsicFunction(Name.identifier("ShortIterator"),Name.identifier("next"),0,ITERATOR_NEXT);
  declareIntrinsicFunction(Name.identifier("IntIterator"),Name.identifier("next"),0,ITERATOR_NEXT);
  declareIntrinsicFunction(Name.identifier("LongIterator"),Name.identifier("next"),0,ITERATOR_NEXT);
  declareIntrinsicFunction(Name.identifier("CharIterator"),Name.identifier("next"),0,ITERATOR_NEXT);
  declareIntrinsicFunction(Name.identifier("BooleanIterator"),Name.identifier("next"),0,ITERATOR_NEXT);
  declareIntrinsicFunction(Name.identifier("FloatIterator"),Name.identifier("next"),0,ITERATOR_NEXT);
  declareIntrinsicFunction(Name.identifier("DoubleIterator"),Name.identifier("next"),0,ITERATOR_NEXT);
  for (  PrimitiveType type : PrimitiveType.values()) {
    declareIntrinsicFunction(type.getTypeName(),Name.identifier("compareTo"),1,new CompareTo());
  }
  declareIntrinsicProperty(Name.identifier("CharSequence"),Name.identifier("length"),new StringLength());
  declareIntrinsicProperty(Name.identifier("String"),Name.identifier("length"),new StringLength());
  registerStaticField(getFQName(KotlinBuiltIns.getInstance().getUnit()).toSafe(),Name.identifier("VALUE"));
  for (  PrimitiveType type : PrimitiveType.NUMBER_TYPES) {
    registerStaticField(type.getRangeClassName(),Name.identifier("EMPTY"));
  }
  for (  PrimitiveType type : PrimitiveType.NUMBER_TYPES) {
    registerRangeOrProgressionProperty(type.getRangeClassName(),Name.identifier("start"));
    registerRangeOrProgressionProperty(type.getRangeClassName(),Name.identifier("end"));
    registerRangeOrProgressionProperty(type.getProgressionClassName(),Name.identifier("start"));
    registerRangeOrProgressionProperty(type.getProgressionClassName(),Name.identifier("end"));
    registerRangeOrProgressionProperty(type.getProgressionClassName(),Name.identifier("increment"));
  }
  declareArrayMethods();
}
