{
  myProject=project;
  myStdLib=stdlib;
  namedMethods.put("\"std.javaClass.function\"",new JavaClassFunction());
  List<String> primitiveCastMethods=OperatorConventions.NUMBER_CONVERSIONS.asList();
  for (  String method : primitiveCastMethods) {
    declareIntrinsicFunction("Number",method,0,NUMBER_CAST,true);
    for (    String type : PRIMITIVE_NUMBER_TYPES) {
      declareIntrinsicFunction(type,method,0,NUMBER_CAST,true);
    }
  }
  for (  String type : PRIMITIVE_NUMBER_TYPES) {
    declareIntrinsicFunction(type,"plus",0,UNARY_PLUS,false);
    declareIntrinsicFunction(type,"minus",0,UNARY_MINUS,false);
    declareIntrinsicFunction(type,"inv",0,INV,false);
    declareIntrinsicFunction(type,"rangeTo",1,UP_TO,false);
    declareIntrinsicFunction(type,"upto",1,UP_TO,false);
    declareIntrinsicFunction(type,"downto",1,DOWN_TO,false);
    declareIntrinsicFunction(type,"inc",0,INC,false);
    declareIntrinsicFunction(type,"dec",0,DEC,false);
  }
  final Set<FunctionDescriptor> typeInfoFunctionGroup=stdlib.getTypeInfoFunctions();
  declareBinaryOp("plus",Opcodes.IADD);
  declareBinaryOp("minus",Opcodes.ISUB);
  declareBinaryOp("times",Opcodes.IMUL);
  declareBinaryOp("div",Opcodes.IDIV);
  declareBinaryOp("mod",Opcodes.IREM);
  declareBinaryOp("shl",Opcodes.ISHL);
  declareBinaryOp("shr",Opcodes.ISHR);
  declareBinaryOp("ushr",Opcodes.IUSHR);
  declareBinaryOp("and",Opcodes.IAND);
  declareBinaryOp("or",Opcodes.IOR);
  declareBinaryOp("xor",Opcodes.IXOR);
  declareIntrinsicFunction("Boolean","not",0,new Not(),true);
  declareIntrinsicFunction("String","plus",1,new Concat(),true);
  declareIntrinsicFunction("CharSequence","get",1,new StringGetChar(),true);
  declareIntrinsicFunction("String","get",1,new StringGetChar(),true);
  declareOverload(myStdLib.getLibraryScope().getFunctions("toString"),0,new ToString());
  declareOverload(myStdLib.getLibraryScope().getFunctions("equals"),1,EQUALS);
  declareOverload(myStdLib.getLibraryScope().getFunctions("identityEquals"),1,EQUALS);
  declareOverload(myStdLib.getLibraryScope().getFunctions("plus"),1,STRING_PLUS);
  declareOverload(myStdLib.getLibraryScope().getFunctions("Array"),1,new NewArray());
  declareOverload(myStdLib.getLibraryScope().getFunctions("sure"),0,new Sure());
  declareOverload(myStdLib.getLibraryScope().getFunctions("synchronized"),2,new StupidSync());
  declareOverload(myStdLib.getLibraryScope().getFunctions("iterator"),0,new IteratorIterator());
  declareIntrinsicFunction("ByteIterator","next",0,ITERATOR_NEXT,false);
  declareIntrinsicFunction("ShortIterator","next",0,ITERATOR_NEXT,false);
  declareIntrinsicFunction("IntIterator","next",0,ITERATOR_NEXT,false);
  declareIntrinsicFunction("LongIterator","next",0,ITERATOR_NEXT,false);
  declareIntrinsicFunction("CharIterator","next",0,ITERATOR_NEXT,false);
  declareIntrinsicFunction("BooleanIterator","next",0,ITERATOR_NEXT,false);
  declareIntrinsicFunction("FloatIterator","next",0,ITERATOR_NEXT,false);
  declareIntrinsicFunction("DoubleIterator","next",0,ITERATOR_NEXT,false);
  for (  String type : PRIMITIVE_TYPES) {
    declareIntrinsicFunction(type,"compareTo",1,new CompareTo(),false);
  }
  declareIntrinsicStringMethods();
  declareIntrinsicProperty("CharSequence","length",new StringLength());
  declareIntrinsicProperty("String","length",new StringLength());
  declareArrayMethods();
}
