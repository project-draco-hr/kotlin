{
  if (types.isEmpty()) {
    return KotlinBuiltIns.getInstance().getNullableAnyType();
  }
  if (types.size() == 1) {
    return types.iterator().next();
  }
  boolean allNullable=true;
  boolean nothingTypePresent=false;
  List<JetType> nullabilityStripped=new ArrayList<JetType>(types.size());
  for (  JetType type : types) {
    nothingTypePresent|=KotlinBuiltIns.getInstance().isNothingOrNullableNothing(type);
    allNullable&=type.isNullable();
    nullabilityStripped.add(makeNotNullable(type));
  }
  if (nothingTypePresent) {
    return allNullable ? KotlinBuiltIns.getInstance().getNullableNothingType() : KotlinBuiltIns.getInstance().getNothingType();
  }
  List<JetType> resultingTypes=new ArrayList<JetType>();
  outer:   for (  JetType type : nullabilityStripped) {
    if (!canHaveSubtypes(typeChecker,type)) {
      for (      JetType other : nullabilityStripped) {
        if (!TypeUnifier.mayBeEqual(type,other) && !typeChecker.isSubtypeOf(type,other) && !typeChecker.isSubtypeOf(other,type)) {
          return null;
        }
      }
      return makeNullableAsSpecified(type,allNullable);
    }
 else {
      for (      JetType other : nullabilityStripped) {
        if (!type.equals(other) && typeChecker.isSubtypeOf(other,type)) {
          continue outer;
        }
      }
    }
    for (    JetType other : resultingTypes) {
      if (typeChecker.equalTypes(other,type)) {
        continue outer;
      }
    }
    resultingTypes.add(type);
  }
  if (resultingTypes.size() == 1) {
    return makeNullableAsSpecified(resultingTypes.get(0),allNullable);
  }
  TypeConstructor constructor=new IntersectionTypeConstructor(Annotations.EMPTY,resultingTypes);
  JetScope[] scopes=new JetScope[resultingTypes.size()];
  int i=0;
  for (  JetType type : resultingTypes) {
    scopes[i]=type.getMemberScope();
    i++;
  }
  return new JetTypeImpl(Annotations.EMPTY,constructor,allNullable,Collections.<TypeProjection>emptyList(),new ChainedScope(null,"member scope for intersection type " + constructor,scopes));
}
