{
  if (allDescriptors == null) {
    allDescriptors=Sets.newHashSet();
    final PsiPackage javaPackage=semanticServices.getDescriptorResolver().findPackage(packageFQN);
    if (javaPackage != null) {
      boolean isKotlinNamespace=semanticServices.getKotlinNamespaceDescriptor(javaPackage.getQualifiedName()) != null;
      final JavaDescriptorResolver descriptorResolver=semanticServices.getDescriptorResolver();
      for (      PsiPackage psiSubPackage : javaPackage.getSubPackages()) {
        if (semanticServices.getKotlinNamespaceDescriptor(psiSubPackage.getQualifiedName()) == null) {
          allDescriptors.add(descriptorResolver.resolveNamespace(psiSubPackage.getQualifiedName()));
        }
      }
      for (      PsiClass psiClass : javaPackage.getClasses()) {
        if (isKotlinNamespace && JvmAbi.PACKAGE_CLASS.equals(psiClass.getName())) {
          continue;
        }
        ClassDescriptor kotlinClassDescriptor=semanticServices.getKotlinClassDescriptor(psiClass.getQualifiedName());
        if (kotlinClassDescriptor != null) {
          continue;
        }
        if (JvmAbi.PACKAGE_CLASS.equals(psiClass.getName())) {
          HashSet<String> methodNames=new HashSet<String>();
          for (          PsiMethod psiMethod : psiClass.getMethods()) {
            methodNames.add(psiMethod.getName());
          }
          for (          String methodName : methodNames) {
            try {
              allDescriptors.addAll(getFunctions(methodName));
            }
 catch (            ProcessCanceledException cancelException) {
              throw cancelException;
            }
catch (            RuntimeException ex) {
              LOG.error(ex);
            }
          }
        }
        if (psiClass.hasModifierProperty(PsiModifier.PUBLIC)) {
          ClassDescriptor classDescriptor=descriptorResolver.resolveClass(psiClass);
          if (classDescriptor != null) {
            allDescriptors.add(classDescriptor);
          }
        }
      }
    }
  }
  return allDescriptors;
}
