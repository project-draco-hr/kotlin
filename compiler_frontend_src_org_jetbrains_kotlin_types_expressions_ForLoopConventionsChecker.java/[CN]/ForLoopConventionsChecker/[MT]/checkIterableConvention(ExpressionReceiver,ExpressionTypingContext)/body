{
  KtExpression loopRangeExpression=loopRange.getExpression();
  Name iterator=Name.identifier("iterator");
  Pair<Call,OverloadResolutionResults<FunctionDescriptor>> calls=fakeCallResolver.makeAndResolveFakeCall(loopRange,context,Collections.<KtExpression>emptyList(),iterator,loopRangeExpression,FakeCallKind.ITERATOR,loopRangeExpression);
  OverloadResolutionResults<FunctionDescriptor> iteratorResolutionResults=calls.getSecond();
  if (iteratorResolutionResults.isSuccess()) {
    ResolvedCall<FunctionDescriptor> iteratorResolvedCall=iteratorResolutionResults.getResultingCall();
    context.trace.record(LOOP_RANGE_ITERATOR_RESOLVED_CALL,loopRangeExpression,iteratorResolvedCall);
    FunctionDescriptor iteratorFunction=iteratorResolvedCall.getResultingDescriptor();
    checkIfOperatorModifierPresent(loopRangeExpression,iteratorFunction,context.trace);
    symbolUsageValidator.validateCall(iteratorResolvedCall,iteratorFunction,context.trace,loopRangeExpression);
    KotlinType iteratorType=iteratorFunction.getReturnType();
    KotlinType hasNextType=checkConventionForIterator(context,loopRangeExpression,iteratorType,"hasNext",HAS_NEXT_FUNCTION_AMBIGUITY,HAS_NEXT_MISSING,HAS_NEXT_FUNCTION_NONE_APPLICABLE,LOOP_RANGE_HAS_NEXT_RESOLVED_CALL);
    if (hasNextType != null && !builtIns.isBooleanOrSubtype(hasNextType)) {
      context.trace.report(HAS_NEXT_FUNCTION_TYPE_MISMATCH.on(loopRangeExpression,hasNextType));
    }
    return checkConventionForIterator(context,loopRangeExpression,iteratorType,"next",NEXT_AMBIGUITY,NEXT_MISSING,NEXT_NONE_APPLICABLE,LOOP_RANGE_NEXT_RESOLVED_CALL);
  }
  return null;
}
