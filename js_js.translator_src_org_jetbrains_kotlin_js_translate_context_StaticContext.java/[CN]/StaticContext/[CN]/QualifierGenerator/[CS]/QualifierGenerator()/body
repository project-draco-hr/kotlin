{
  Rule<JsExpression> standardObjectsHaveKotlinQualifier=new Rule<JsExpression>(){
    @Override public JsExpression apply(    @NotNull DeclarationDescriptor descriptor){
      if (!standardClasses.isStandardObject(descriptor)) {
        return null;
      }
      return namer.kotlinObject();
    }
  }
;
  Rule<JsExpression> packageLevelDeclarationsHaveEnclosingPackagesNamesAsQualifier=new Rule<JsExpression>(){
    @Override public JsExpression apply(    @NotNull DeclarationDescriptor descriptor){
      if (isNativeObject(descriptor))       return null;
      DeclarationDescriptor containingDescriptor=getContainingDeclaration(descriptor);
      if (!(containingDescriptor instanceof PackageFragmentDescriptor)) {
        return null;
      }
      JsNameRef result=getQualifierForParentPackage(((PackageFragmentDescriptor)containingDescriptor).getFqName());
      String moduleName=getExternalModuleName(descriptor);
      if (moduleName == null) {
        return result;
      }
      if (LibrarySourcesConfig.UNKNOWN_EXTERNAL_MODULE_NAME.equals(moduleName)) {
        return null;
      }
      return JsAstUtils.replaceRootReference(result,new JsArrayAccess(namer.kotlin("modules"),program.getStringLiteral(moduleName)));
    }
    private String getExternalModuleName(    DeclarationDescriptor descriptor){
      if (isBuiltin(descriptor))       return BUILTINS_JS_MODULE_NAME;
      PsiElement element=descriptorToDeclaration(descriptor);
      if (element == null && descriptor instanceof PropertyAccessorDescriptor) {
        element=descriptorToDeclaration(((PropertyAccessorDescriptor)descriptor).getCorrespondingProperty());
      }
      if (element == null) {
        return null;
      }
      return element.getContainingFile().getUserData(LibrarySourcesConfig.EXTERNAL_MODULE_NAME);
    }
  }
;
  Rule<JsExpression> constructorOrDefaultObjectHasTheSameQualifierAsTheClass=new Rule<JsExpression>(){
    @Override public JsExpression apply(    @NotNull DeclarationDescriptor descriptor){
      if (descriptor instanceof ConstructorDescriptor || DescriptorUtils.isDefaultObject(descriptor)) {
        return getQualifierForDescriptor(descriptor.getContainingDeclaration());
      }
      return null;
    }
  }
;
  Rule<JsExpression> libraryObjectsHaveKotlinQualifier=new Rule<JsExpression>(){
    @Override public JsExpression apply(    @NotNull DeclarationDescriptor descriptor){
      if (isLibraryObject(descriptor)) {
        return namer.kotlinObject();
      }
      return null;
    }
  }
;
  Rule<JsExpression> nativeObjectsHaveNativePartOfFullQualifier=new Rule<JsExpression>(){
    @Override public JsExpression apply(    @NotNull DeclarationDescriptor descriptor){
      if (descriptor instanceof ConstructorDescriptor || !isNativeObject(descriptor))       return null;
      DeclarationDescriptor containingDeclaration=descriptor.getContainingDeclaration();
      if (containingDeclaration != null && isNativeObject(containingDeclaration)) {
        return getQualifiedReference(containingDeclaration);
      }
      return null;
    }
  }
;
  Rule<JsExpression> staticMembersHaveContainerQualifier=new Rule<JsExpression>(){
    @Override public JsExpression apply(    @NotNull DeclarationDescriptor descriptor){
      if (descriptor instanceof CallableDescriptor && !isNativeObject(descriptor)) {
        CallableDescriptor callableDescriptor=(CallableDescriptor)descriptor;
        if (DescriptorUtils.isStaticDeclaration(callableDescriptor)) {
          return getQualifiedReference(callableDescriptor.getContainingDeclaration());
        }
      }
      return null;
    }
  }
;
  addRule(libraryObjectsHaveKotlinQualifier);
  addRule(constructorOrDefaultObjectHasTheSameQualifierAsTheClass);
  addRule(standardObjectsHaveKotlinQualifier);
  addRule(packageLevelDeclarationsHaveEnclosingPackagesNamesAsQualifier);
  addRule(nativeObjectsHaveNativePartOfFullQualifier);
  addRule(staticMembersHaveContainerQualifier);
}
