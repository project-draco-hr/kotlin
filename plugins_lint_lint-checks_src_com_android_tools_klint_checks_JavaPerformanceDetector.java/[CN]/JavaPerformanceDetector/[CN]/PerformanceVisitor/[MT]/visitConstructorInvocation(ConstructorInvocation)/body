{
  String typeName=null;
  if (mCheckMaps) {
    TypeReference reference=node.astTypeReference();
    typeName=reference.astParts().last().astIdentifier().astValue();
    if (typeName.equals(HASH_MAP)) {
      checkHashMap(node,reference);
    }
 else     if (typeName.equals(SPARSE_ARRAY)) {
      checkSparseArray(node,reference);
    }
  }
  if (mCheckValueOf) {
    if (typeName == null) {
      TypeReference reference=node.astTypeReference();
      typeName=reference.astParts().last().astIdentifier().astValue();
    }
    if ((typeName.equals(INTEGER) || typeName.equals(BOOLEAN) || typeName.equals(FLOAT)|| typeName.equals(CHARACTER)|| typeName.equals(LONG)|| typeName.equals(DOUBLE)|| typeName.equals(BYTE)) && node.astTypeReference().astParts().size() == 1 && node.astArguments().size() == 1) {
      String argument=node.astArguments().first().toString();
      mContext.report(USE_VALUE_OF,node,mContext.getLocation(node),getUseValueOfErrorMessage(typeName,argument));
    }
  }
  if (mFlagAllocations && !(node.getParent() instanceof Throw) && mCheckAllocations) {
    Node method=node;
    while (method != null) {
      if (method instanceof MethodDeclaration) {
        break;
      }
      method=method.getParent();
    }
    if (method != null && isBlockedAllocationMethod(((MethodDeclaration)method)) && !isLazilyInitialized(node)) {
      reportAllocation(node);
    }
  }
  return super.visitConstructorInvocation(node);
}
