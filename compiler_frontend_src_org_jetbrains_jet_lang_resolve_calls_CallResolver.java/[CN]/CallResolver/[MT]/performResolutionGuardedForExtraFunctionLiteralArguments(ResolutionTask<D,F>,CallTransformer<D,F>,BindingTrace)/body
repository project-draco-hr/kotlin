{
  OverloadResolutionResultsImpl<F> results=performResolution(task,callTransformer,traceForResolutionCache);
  ImmutableSet<OverloadResolutionResults.Code> someFailed=ImmutableSet.of(OverloadResolutionResults.Code.MANY_FAILED_CANDIDATES,OverloadResolutionResults.Code.SINGLE_CANDIDATE_ARGUMENT_MISMATCH);
  if (someFailed.contains(results.getResultCode()) && !task.call.getFunctionLiteralArguments().isEmpty() && task.resolveMode == ResolveMode.TOP_LEVEL_CALL) {
    ResolutionTask<D,F> newTask=new ResolutionTask<D,F>(task.getCandidates(),task.reference,task.tracing,TemporaryBindingTrace.create(task.trace,"trace for resolution guarded for extra function literal arguments"),task.scope,new DelegatingCall(task.call){
      @NotNull @Override public List<JetExpression> getFunctionLiteralArguments(){
        return Collections.emptyList();
      }
    }
,task.expectedType,task.dataFlowInfo,task.resolveMode,task.checkArguments,task.expressionPosition,task.resolutionResultsCache);
    OverloadResolutionResultsImpl<F> resultsWithFunctionLiteralsStripped=performResolution(newTask,callTransformer,traceForResolutionCache);
    if (resultsWithFunctionLiteralsStripped.isSuccess() || resultsWithFunctionLiteralsStripped.isAmbiguity()) {
      task.tracing.danglingFunctionLiteralArgumentSuspected(task.trace,task.call.getFunctionLiteralArguments());
    }
  }
  return results;
}
