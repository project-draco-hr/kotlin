{
  OverloadResolutionResultsImpl<F> results=performResolution(task,callTransformer);
  ImmutableSet<OverloadResolutionResults.Code> someFailed=ImmutableSet.of(MANY_FAILED_CANDIDATES,SINGLE_CANDIDATE_ARGUMENT_MISMATCH);
  if (someFailed.contains(results.getResultCode()) && !task.call.getFunctionLiteralArguments().isEmpty() && task.contextDependency == ContextDependency.INDEPENDENT) {
    DelegatingCall callWithoutFLArgs=new DelegatingCall(task.call){
      @NotNull @Override public List<? extends ValueArgument> getValueArguments(){
        return CallUtilPackage.getValueArgumentsInParentheses(task.call);
      }
      @NotNull @Override public List<JetFunctionLiteralArgument> getFunctionLiteralArguments(){
        return Collections.emptyList();
      }
    }
;
    TemporaryBindingTrace temporaryTrace=TemporaryBindingTrace.create(task.trace,"trace for resolution guarded for extra function literal arguments");
    ResolutionTask<D,F> newTask=new ResolutionTask<D,F>(task.getCandidates(),task.toBasic(),task.tracing).replaceBindingTrace(temporaryTrace).replaceCall(callWithoutFLArgs);
    OverloadResolutionResultsImpl<F> resultsWithFunctionLiteralsStripped=performResolution(newTask,callTransformer);
    if (resultsWithFunctionLiteralsStripped.isSuccess() || resultsWithFunctionLiteralsStripped.isAmbiguity()) {
      task.tracing.danglingFunctionLiteralArgumentSuspected(task.trace,task.call.getFunctionLiteralArguments());
    }
  }
  return results;
}
