{
  if (resultsWithIncompleteTypeInference.getResultCode() != OverloadResolutionResults.Code.INCOMPLETE_TYPE_INFERENCE)   return resultsWithIncompleteTypeInference;
  Set<ResolvedCallWithTrace<D>> successful=Sets.newLinkedHashSet();
  Set<ResolvedCallWithTrace<D>> failed=Sets.newLinkedHashSet();
  for (  ResolvedCall<? extends D> call : resultsWithIncompleteTypeInference.getResultingCalls()) {
    if (!(call instanceof ResolvedCallImpl))     continue;
    ResolvedCallImpl<D> resolvedCall=(ResolvedCallImpl<D>)call;
    if (!resolvedCall.hasUnknownTypeParameters()) {
      if (resolvedCall.getStatus().isSuccess()) {
        successful.add(resolvedCall);
      }
 else {
        failed.add(resolvedCall);
      }
      continue;
    }
    completeTypeInferenceDependentOnExpectedTypeForCall(resolvedCall,context,tracing,successful,failed);
  }
  OverloadResolutionResultsImpl<D> results=computeResultAndReportErrors(context.trace,tracing,successful,failed);
  if (!results.isSingleResult()) {
    checkTypesWithNoCallee(context);
  }
  return results;
}
