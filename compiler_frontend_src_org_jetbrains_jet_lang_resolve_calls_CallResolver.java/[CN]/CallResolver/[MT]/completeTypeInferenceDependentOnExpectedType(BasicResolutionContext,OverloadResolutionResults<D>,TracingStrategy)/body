{
  if (resultsWithIncompleteTypeInference.getResultCode() != OverloadResolutionResults.Code.INCOMPLETE_TYPE_INFERENCE)   return resultsWithIncompleteTypeInference;
  Set<ResolvedCallWithTrace<D>> successful=Sets.newLinkedHashSet();
  Set<ResolvedCallWithTrace<D>> failed=Sets.newLinkedHashSet();
  for (  ResolvedCall<? extends D> call : resultsWithIncompleteTypeInference.getResultingCalls()) {
    if (!(call instanceof ResolvedCallImpl))     continue;
    ResolvedCallImpl<D> resolvedCall=(ResolvedCallImpl<D>)call;
    if (!resolvedCall.hasUnknownTypeParameters()) {
      if (resolvedCall.getStatus().isSuccess()) {
        successful.add(resolvedCall);
      }
 else {
        failed.add(resolvedCall);
      }
      continue;
    }
    completeTypeInferenceDependentOnExpectedTypeForCall(resolvedCall,context,tracing,successful,failed);
  }
  if (resultsWithIncompleteTypeInference.getResultingCalls().size() > 1) {
    for (    ResolvedCallWithTrace<D> call : successful) {
      if (call instanceof ResolvedCallImpl) {
        ((ResolvedCallImpl)call).addStatus(ResolutionStatus.TYPE_INFERENCE_ERROR);
        failed.add(call);
      }
    }
    successful.clear();
  }
  OverloadResolutionResultsImpl<D> results=computeResultAndReportErrors(context.trace,tracing,successful,failed);
  if (!results.isSingleResult()) {
    checkTypesWithNoCallee(context);
  }
  return results;
}
