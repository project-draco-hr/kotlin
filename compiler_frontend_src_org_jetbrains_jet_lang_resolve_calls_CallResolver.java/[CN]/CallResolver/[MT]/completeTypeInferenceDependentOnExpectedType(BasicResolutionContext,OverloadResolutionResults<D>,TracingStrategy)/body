{
  if (resultsWithIncompleteTypeInference.getResultCode() != OverloadResolutionResults.Code.INCOMPLETE_TYPE_INFERENCE)   return resultsWithIncompleteTypeInference;
  Set<ResolvedCallWithTrace<D>> successful=Sets.newLinkedHashSet();
  Set<ResolvedCallWithTrace<D>> failed=Sets.newLinkedHashSet();
  for (  ResolvedCall<? extends D> call : resultsWithIncompleteTypeInference.getResultingCalls()) {
    if (!(call instanceof ResolvedCallImpl))     continue;
    ResolvedCallImpl<D> resolvedCall=CallResolverUtil.copy((ResolvedCallImpl<D>)call,context);
    if (!resolvedCall.hasUnknownTypeParameters()) {
      if (resolvedCall.getStatus().isSuccess()) {
        successful.add(resolvedCall);
      }
 else {
        failed.add(resolvedCall);
      }
      continue;
    }
    candidateResolver.completeTypeInferenceDependentOnExpectedTypeForCall(CallResolutionContext.create(context,tracing,resolvedCall),successful,failed);
  }
  OverloadResolutionResultsImpl<D> results=resolutionResultsHandler.computeResultAndReportErrors(context.trace,tracing,successful,failed);
  if (!results.isSingleResult()) {
    candidateResolver.checkTypesWithNoCallee(context);
  }
  return results;
}
