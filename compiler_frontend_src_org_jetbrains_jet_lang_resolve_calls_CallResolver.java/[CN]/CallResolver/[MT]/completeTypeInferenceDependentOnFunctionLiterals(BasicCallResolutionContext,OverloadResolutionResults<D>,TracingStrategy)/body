{
  if (resultsWithIncompleteTypeInference.getResultCode() != OverloadResolutionResults.Code.INCOMPLETE_TYPE_INFERENCE) {
    return resultsWithIncompleteTypeInference;
  }
  Set<ResolvedCallWithTrace<D>> candidates=Sets.newLinkedHashSet((Collection<? extends ResolvedCallWithTrace<D>>)resultsWithIncompleteTypeInference.getResultingCalls());
  ResolvedCallWithTrace<D> maximallySpecific=OverloadingConflictResolver.INSTANCE.findMaximallySpecific(candidates,false);
  if (maximallySpecific != null && maximallySpecific instanceof ResolvedCallImpl) {
    candidateResolver.completeTypeInferenceDependentOnFunctionLiteralsForCall(CallCandidateResolutionContext.createForCallBeingAnalyzed((ResolvedCallImpl<D>)maximallySpecific,context,tracing));
    for (    ResolvedCallWithTrace<D> callWithUnknownTypeParameters : candidates) {
      if (callWithUnknownTypeParameters != maximallySpecific) {
        ((ResolvedCallImpl<D>)callWithUnknownTypeParameters).addStatus(ResolutionStatus.OTHER_ERROR);
      }
    }
    return OverloadResolutionResultsImpl.incompleteTypeInference(Collections.singleton(maximallySpecific));
  }
  for (  ResolvedCallWithTrace<D> callWithUnknownTypeParameters : candidates) {
    ResolvedCallImpl<D> resolvedCall=(ResolvedCallImpl<D>)callWithUnknownTypeParameters;
    resolvedCall.addStatus(ResolutionStatus.INCOMPLETE_TYPE_INFERENCE);
  }
  return OverloadResolutionResultsImpl.incompleteTypeInference(candidates);
}
