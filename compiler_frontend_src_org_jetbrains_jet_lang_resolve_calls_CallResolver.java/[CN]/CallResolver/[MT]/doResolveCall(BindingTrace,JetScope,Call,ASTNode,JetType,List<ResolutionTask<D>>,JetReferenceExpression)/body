{
  TemporaryBindingTrace traceForFirstNonemptyCandidateSet=null;
  OverloadResolutionResults<D> resultsForFirstNonemptyCandidateSet=null;
  TracingStrategy tracing=new TracingStrategy(){
    @Override public void bindReference(    @NotNull BindingTrace trace,    @NotNull ReceiverDescriptor receiver,    @NotNull CallableDescriptor descriptor){
      trace.record(REFERENCE_TARGET,reference,descriptor);
      trace.record(RECEIVER,reference,receiver);
      if (receiver instanceof AutoCastReceiver) {
        AutoCastReceiver autoCastReceiver=(AutoCastReceiver)receiver;
        ReceiverDescriptor original=autoCastReceiver.getOriginal();
        if (original instanceof ExpressionReceiver) {
          ExpressionReceiver expressionReceiver=(ExpressionReceiver)original;
          trace.record(AUTOCAST,expressionReceiver.getExpression(),autoCastReceiver.getType());
        }
      }
    }
    @Override public <D extends CallableDescriptor>void recordAmbiguity(    BindingTrace trace,    Collection<ResolvedCall<D>> candidates){
      trace.record(AMBIGUOUS_REFERENCE_TARGET,reference,candidates);
    }
    @Override public void unresolvedReference(    @NotNull BindingTrace trace){
      trace.report(UNRESOLVED_REFERENCE.on(reference));
    }
    @Override public void noValueForParameter(    @NotNull BindingTrace trace,    @NotNull ValueParameterDescriptor valueParameter){
      trace.report(NO_VALUE_FOR_PARAMETER.on(reference,valueParameter));
    }
    @Override public void missingReceiver(    @NotNull BindingTrace trace,    @NotNull ReceiverDescriptor expectedReceiver){
      trace.report(MISSING_RECEIVER.on(reference,expectedReceiver.getType()));
    }
    @Override public void noReceiverAllowed(    @NotNull BindingTrace trace){
      trace.report(NO_RECEIVER_ADMITTED.on(reference));
    }
    @Override public void wrongNumberOfTypeArguments(    @NotNull BindingTrace trace,    int expectedTypeArgumentCount){
      JetTypeArgumentList typeArgumentList=call.getTypeArgumentList();
      if (typeArgumentList != null) {
        trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(typeArgumentList,expectedTypeArgumentCount));
      }
 else {
        trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(reference,expectedTypeArgumentCount));
      }
    }
    @Override public <D extends CallableDescriptor>void ambiguity(    @NotNull BindingTrace trace,    @NotNull Set<ResolvedCall<D>> descriptors){
      trace.report(OVERLOAD_RESOLUTION_AMBIGUITY.on(callNode,descriptors));
    }
    @Override public <D extends CallableDescriptor>void noneApplicable(    @NotNull BindingTrace trace,    @NotNull Set<ResolvedCall<D>> descriptors){
      trace.report(NONE_APPLICABLE.on(callNode,descriptors));
    }
    @Override public void instantiationOfAbstractClass(    @NotNull BindingTrace trace){
      trace.report(CREATING_AN_INSTANCE_OF_ABSTRACT_CLASS.on(callNode));
    }
    @Override public void typeInferenceFailed(    @NotNull BindingTrace trace){
      trace.report(TYPE_INFERENCE_FAILED.on(callNode));
    }
  }
;
  for (  ResolutionTask<D> task : prioritizedTasks) {
    TemporaryBindingTrace temporaryTrace=TemporaryBindingTrace.create(trace);
    OverloadResolutionResults<D> results=performResolution(temporaryTrace,scope,expectedType,task,tracing);
    if (results.isSuccess()) {
      temporaryTrace.commit();
      return results.getResult();
    }
    if (traceForFirstNonemptyCandidateSet == null && !task.getCandidates().isEmpty()) {
      traceForFirstNonemptyCandidateSet=temporaryTrace;
      resultsForFirstNonemptyCandidateSet=results;
    }
  }
  if (traceForFirstNonemptyCandidateSet != null) {
    traceForFirstNonemptyCandidateSet.commit();
    if (resultsForFirstNonemptyCandidateSet.singleDescriptor()) {
      return resultsForFirstNonemptyCandidateSet.getResult();
    }
  }
 else {
    trace.report(UNRESOLVED_REFERENCE.on(reference));
    checkTypesWithNoCallee(trace,scope,call.getTypeArguments(),call.getValueArguments(),call.getFunctionLiteralArguments());
  }
  return null;
}
