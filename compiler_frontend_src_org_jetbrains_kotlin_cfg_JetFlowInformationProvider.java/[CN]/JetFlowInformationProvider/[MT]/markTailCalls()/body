{
  final DeclarationDescriptor subroutineDescriptor=trace.get(BindingContext.DECLARATION_TO_DESCRIPTOR,subroutine);
  if (!(subroutineDescriptor instanceof FunctionDescriptor))   return;
  if (!KotlinBuiltIns.isTailRecursive(subroutineDescriptor))   return;
class KindAndCall {
    TailRecursionKind kind;
    ResolvedCall<?> call;
    KindAndCall(    TailRecursionKind kind,    ResolvedCall<?> call){
      this.kind=kind;
      this.call=call;
    }
  }
  final Map<JetElement,KindAndCall> calls=new HashMap<JetElement,KindAndCall>();
  PseudocodeTraverserKt.traverse(pseudocode,FORWARD,new FunctionVoid1<Instruction>(){
    public void execute(    @NotNull Instruction instruction){
      if (!(instruction instanceof CallInstruction))       return;
      CallInstruction callInstruction=(CallInstruction)instruction;
      ResolvedCall<?> resolvedCall=CallUtilKt.getResolvedCall(callInstruction.getElement(),trace.getBindingContext());
      if (resolvedCall == null)       return;
      CallableDescriptor functionDescriptor=resolvedCall.getResultingDescriptor();
      if (!functionDescriptor.getOriginal().equals(subroutineDescriptor))       return;
      JetElement element=callInstruction.getElement();
      JetExpression parent=PsiTreeUtil.getParentOfType(element,JetTryExpression.class,JetFunction.class,JetClassInitializer.class);
      if (parent instanceof JetTryExpression) {
        calls.put(element,new KindAndCall(IN_TRY,resolvedCall));
        return;
      }
      boolean isTail=PseudocodeTraverserKt.traverseFollowingInstructions(callInstruction,new HashSet<Instruction>(),FORWARD,new TailRecursionDetector(subroutine,callInstruction));
      boolean sameDispatchReceiver=ResolvedCallUtilKt.hasThisOrNoDispatchReceiver(resolvedCall,trace.getBindingContext());
      TailRecursionKind kind=isTail && sameDispatchReceiver ? TAIL_CALL : NON_TAIL;
      KindAndCall kindAndCall=calls.get(element);
      calls.put(element,new KindAndCall(combineKinds(kind,kindAndCall == null ? null : kindAndCall.kind),resolvedCall));
    }
  }
);
  boolean hasTailCalls=false;
  for (  Map.Entry<JetElement,KindAndCall> entry : calls.entrySet()) {
    JetElement element=entry.getKey();
    KindAndCall kindAndCall=entry.getValue();
switch (kindAndCall.kind) {
case TAIL_CALL:
      trace.record(TAIL_RECURSION_CALL,kindAndCall.call,TailRecursionKind.TAIL_CALL);
    hasTailCalls=true;
  break;
case IN_TRY:
trace.report(Errors.TAIL_RECURSION_IN_TRY_IS_NOT_SUPPORTED.on(element));
break;
case NON_TAIL:
trace.report(Errors.NON_TAIL_RECURSIVE_CALL.on(element));
break;
}
}
if (!hasTailCalls) {
trace.report(Errors.NO_TAIL_CALLS_FOUND.on((JetNamedFunction)subroutine));
}
}
