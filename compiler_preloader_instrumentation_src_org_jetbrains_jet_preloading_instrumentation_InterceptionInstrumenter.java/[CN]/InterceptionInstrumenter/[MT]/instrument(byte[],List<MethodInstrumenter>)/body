{
  final ClassReader cr=new ClassReader(classData);
  ClassWriter cw=new ClassWriter(cr,0);
  cr.accept(new ClassVisitor(ASM4,cw){
    private final Map<MethodInstrumenter,String> matchedMethods=new HashMap<MethodInstrumenter,String>();
    @Override public MethodVisitor visitMethod(    final int access,    final String name,    final String desc,    String signature,    String[] exceptions){
      MethodVisitor mv=super.visitMethod(access,name,desc,signature,exceptions);
      if ((access & (ACC_BRIDGE | ACC_SYNTHETIC)) != 0)       return mv;
      List<MethodInstrumenter> applicableInstrumenters=new ArrayList<MethodInstrumenter>();
      for (      MethodInstrumenter instrumenter : instrumenters) {
        if (instrumenter.isApplicable(name,desc)) {
          applicableInstrumenters.add(instrumenter);
          instrumenter.reportApplication(cr.getClassName(),name,desc);
          checkMultipleMatches(instrumenter,name,desc);
          neverMatchedInstrumenters.remove(instrumenter);
        }
      }
      if (applicableInstrumenters.isEmpty())       return mv;
      final List<MethodData> exitData=new ArrayList<MethodData>();
      final List<MethodData> enterData=new ArrayList<MethodData>();
      int maxParamCount=0;
      for (      MethodInstrumenter instrumenter : applicableInstrumenters) {
        for (        MethodData methodData : instrumenter.getEnterData()) {
          if (maxParamCount < stackDepth(methodData)) {
            maxParamCount=stackDepth(methodData);
          }
          enterData.add(methodData);
        }
        for (        MethodData methodData : instrumenter.getExitData()) {
          if (maxParamCount < stackDepth(methodData)) {
            maxParamCount=stackDepth(methodData);
          }
          exitData.add(methodData);
        }
      }
      if (enterData.isEmpty() && exitData.isEmpty())       return mv;
      if (dumpInstrumentedMethods) {
        mv=getDumpingVisitorWrapper(mv,name,desc);
      }
      final boolean isConstructor="<init>".equals(name);
      final int finalMaxParamCount=maxParamCount;
      return new MethodVisitorWithUniversalHandler(ASM4,mv){
        private InstructionAdapter ia=null;
        private boolean enterDataWritten=false;
        private InstructionAdapter getInstructionAdapter(){
          if (ia == null) {
            ia=new InstructionAdapter(this);
          }
          return ia;
        }
        @Override public void visitMaxs(        int maxStack,        int maxLocals){
          int maxInstrumentedStack=finalMaxParamCount + 1;
          super.visitMaxs(Math.max(maxStack,maxInstrumentedStack),maxLocals);
        }
        @Override protected boolean visitAnyInsn(        int opcode){
          writeEnterData();
          return true;
        }
        private void writeEnterData(){
          if (enterDataWritten)           return;
          enterDataWritten=true;
          for (          MethodData methodData : enterData) {
            invokeMethod(access,name,desc,getInstructionAdapter(),methodData,isConstructor);
          }
        }
        @Override public void visitInsn(        int opcode){
          writeEnterData();
switch (opcode) {
case RETURN:
case IRETURN:
case LRETURN:
case FRETURN:
case DRETURN:
case ARETURN:
case ATHROW:
            for (            MethodData methodData : exitData) {
              boolean beforeThrowInConstructor=opcode == ATHROW && isConstructor;
              invokeMethod(access,name,desc,getInstructionAdapter(),methodData,beforeThrowInConstructor);
            }
          break;
      }
      super.visitInsn(opcode);
    }
  }
;
}
private int stackDepth(MethodData methodData){
  int allArgsStackDepth=methodData.getAllArgsParameterIndex() >= 0 ? 3 : 0;
  return methodData.getParameterCount() + 1 + allArgsStackDepth;
}
private void checkMultipleMatches(MethodInstrumenter instrumenter,String name,String desc){
  if (!instrumenter.allowsMultipleMatches()) {
    String erasedSignature=name + desc;
    String alreadyMatched=matchedMethods.put(instrumenter,erasedSignature);
    if (alreadyMatched != null) {
      throw new IllegalStateException(instrumenter + " matched two methods in " + cr.getClassName()+ ":\n"+ alreadyMatched+ "\n"+ erasedSignature);
    }
  }
}
private TraceMethodVisitor getDumpingVisitorWrapper(MethodVisitor mv,final String methodName,final String methodDesc){
  return new TraceMethodVisitor(mv,new Textifier(){
    @Override public void visitMethodEnd(){
      System.out.println(cr.getClassName() + ":" + methodName+ methodDesc);
      for (      Object line : getText()) {
        System.out.print(line);
      }
      System.out.println();
      System.out.println();
      super.visitMethodEnd();
    }
  }
);
}
}
,0);
return cw.toByteArray();
}
