{
  OwnerKind methodContextKind=methodContext.getContextKind();
  Method asmMethod=jvmSignature.getAsmMethod();
  int flags=getMethodAsmFlags(functionDescriptor,methodContextKind);
  MethodVisitor mv=v.newMethod(origin,flags,asmMethod.getName(),asmMethod.getDescriptor(),jvmSignature.getGenericsSignature(),getThrownExceptions(functionDescriptor,typeMapper));
  if (owner instanceof PackageFacadeContext) {
    Type ownerType=((PackageFacadeContext)owner).getDelegateToClassType();
    v.getSerializationBindings().put(IMPL_CLASS_NAME_FOR_CALLABLE,functionDescriptor,shortNameByAsmType(ownerType));
  }
 else {
    v.getSerializationBindings().put(METHOD_FOR_FUNCTION,functionDescriptor,asmMethod);
  }
  AnnotationCodegen.forMethod(mv,typeMapper).genAnnotations(functionDescriptor,asmMethod.getReturnType());
  generateParameterAnnotations(functionDescriptor,mv,jvmSignature);
  if (state.getClassBuilderMode() != ClassBuilderMode.LIGHT_CLASSES) {
    generateJetValueParameterAnnotations(mv,functionDescriptor,jvmSignature);
  }
  generateBridges(functionDescriptor);
  if (AnnotationsPackage.isPlatformStaticInClassObject(functionDescriptor)) {
    MemberCodegen<?> codegen=getParentCodegen().getParentCodegen();
    ((ImplementationBodyCodegen)codegen).addAdditionalTask(new PlatformStaticGenerator(functionDescriptor,origin,state));
  }
  if (state.getClassBuilderMode() == ClassBuilderMode.LIGHT_CLASSES || isAbstractMethod(functionDescriptor,methodContextKind)) {
    generateLocalVariableTable(mv,jvmSignature,functionDescriptor,getThisTypeForFunction(functionDescriptor,methodContext,typeMapper),new Label(),new Label(),methodContextKind);
    mv.visitEnd();
    return;
  }
  if ((flags & Opcodes.ACC_NATIVE) == 0) {
    generateMethodBody(mv,functionDescriptor,methodContext,jvmSignature,strategy,getParentCodegen());
  }
  endVisit(mv,null,origin.getElement());
  methodContext.recordSyntheticAccessorIfNeeded(functionDescriptor,bindingContext);
}
