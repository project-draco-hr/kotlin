{
  Method asmMethod=jvmSignature.getAsmMethod();
  MethodVisitor mv=v.newMethod(origin,getMethodAsmFlags(functionDescriptor,methodContext.getContextKind()),asmMethod.getName(),asmMethod.getDescriptor(),jvmSignature.getGenericsSignature(),null);
  OwnerKind contextKind=owner.getContextKind();
  if (contextKind instanceof OwnerKind.StaticDelegateKind) {
    FqName fqName=((OwnerKind.StaticDelegateKind)contextKind).getOwnerClass().getFqName();
    v.getMemberMap().recordSrcClassNameForCallable(functionDescriptor,fqName.shortName());
  }
 else {
    v.getMemberMap().recordMethodOfDescriptor(functionDescriptor,asmMethod);
  }
  AnnotationCodegen.forMethod(mv,typeMapper).genAnnotations(functionDescriptor);
  if (state.getClassBuilderMode() == ClassBuilderMode.SIGNATURES)   return;
  if (needJetAnnotations) {
    genJetAnnotations(mv,functionDescriptor,jvmSignature);
  }
  if (isAbstractMethod(functionDescriptor,methodContext.getContextKind()))   return;
  if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {
    genStubCode(mv);
    return;
  }
  generateMethodBody(mv,functionDescriptor,methodContext,jvmSignature,strategy);
  endVisit(mv,null,origin);
  generateBridgeIfNeeded(owner,state,v,jvmSignature.getAsmMethod(),functionDescriptor);
  methodContext.recordSyntheticAccessorIfNeeded(functionDescriptor,typeMapper);
}
