{
  if (functionDescriptor.getKind() == CallableMemberDescriptor.Kind.FAKE_OVERRIDE) {
    throw new IllegalStateException("must not generate code for fake overrides");
  }
  List<ValueParameterDescriptor> paramDescrs=functionDescriptor.getValueParameters();
  int flags=JetTypeMapper.getAccessModifiers(functionDescriptor,0);
  if (!functionDescriptor.getValueParameters().isEmpty() && functionDescriptor.getValueParameters().get(functionDescriptor.getValueParameters().size() - 1).getVarargElementType() != null) {
    flags|=ACC_VARARGS;
  }
  Modality modality=functionDescriptor.getModality();
  if (modality == Modality.FINAL) {
    DeclarationDescriptor containingDeclaration=functionDescriptor.getContainingDeclaration();
    if (!(containingDeclaration instanceof ClassDescriptor) || ((ClassDescriptor)containingDeclaration).getKind() != ClassKind.TRAIT) {
      flags|=ACC_FINAL;
    }
  }
  OwnerKind kind=context.getContextKind();
  if (kind == OwnerKind.TRAIT_IMPL) {
    needJetAnnotations=false;
  }
  ReceiverDescriptor expectedThisObject=functionDescriptor.getExpectedThisObject();
  ReceiverDescriptor receiverParameter=functionDescriptor.getReceiverParameter();
  if (kind != OwnerKind.TRAIT_IMPL || bodyExpressions != null) {
    boolean isStatic=kind == OwnerKind.NAMESPACE || kind instanceof OwnerKind.StaticDelegateKind;
    if (isStatic || kind == OwnerKind.TRAIT_IMPL) {
      flags|=ACC_STATIC;
    }
    boolean isAbstract=(modality == Modality.ABSTRACT || CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration())) && !isStatic && kind != OwnerKind.TRAIT_IMPL;
    if (isAbstract)     flags|=ACC_ABSTRACT;
    final MethodVisitor mv=v.newMethod(fun,flags,jvmSignature.getAsmMethod().getName(),jvmSignature.getAsmMethod().getDescriptor(),jvmSignature.getGenericsSignature(),null);
    AnnotationCodegen.forMethod(mv,state.getInjector().getJetTypeMapper()).genAnnotations(functionDescriptor);
    if (state.getClassBuilderMode() != ClassBuilderMode.SIGNATURES) {
      int start=0;
      if (needJetAnnotations) {
        if (functionDescriptor instanceof PropertyAccessorDescriptor) {
          PropertyCodegen.generateJetPropertyAnnotation(mv,propertyTypeSignature,jvmSignature.getKotlinTypeParameter(),((PropertyAccessorDescriptor)functionDescriptor).getCorrespondingProperty(),functionDescriptor.getVisibility());
        }
 else         if (functionDescriptor instanceof SimpleFunctionDescriptor) {
          if (propertyTypeSignature != null) {
            throw new IllegalStateException();
          }
          JetMethodAnnotationWriter aw=JetMethodAnnotationWriter.visitAnnotation(mv);
          BitSet kotlinFlags=CodegenUtil.getFlagsForVisibility(functionDescriptor.getVisibility());
          if (CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration()) && modality != Modality.ABSTRACT) {
            kotlinFlags.set(modality == Modality.FINAL ? JvmStdlibNames.FLAG_FORCE_FINAL_BIT : JvmStdlibNames.FLAG_FORCE_OPEN_BIT);
          }
          aw.writeFlags(kotlinFlags);
          aw.writeNullableReturnType(functionDescriptor.getReturnType().isNullable());
          aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());
          aw.writeReturnType(jvmSignature.getKotlinReturnType());
          aw.visitEnd();
        }
 else {
          throw new IllegalStateException();
        }
        if (receiverParameter.exists()) {
          JetValueParameterAnnotationWriter av=JetValueParameterAnnotationWriter.visitParameterAnnotation(mv,start++);
          av.writeName("this$receiver");
          av.writeNullable(receiverParameter.getType().isNullable());
          av.writeReceiver();
          if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(0) != null) {
            av.writeType(jvmSignature.getKotlinParameterTypes().get(0).getKotlinSignature());
          }
          av.visitEnd();
        }
        for (int i=0; i != paramDescrs.size(); ++i) {
          ValueParameterDescriptor parameterDescriptor=paramDescrs.get(i);
          AnnotationCodegen.forParameter(i,mv,state.getInjector().getJetTypeMapper()).genAnnotations(parameterDescriptor);
          JetValueParameterAnnotationWriter av=JetValueParameterAnnotationWriter.visitParameterAnnotation(mv,i + start);
          av.writeName(parameterDescriptor.getName().getName());
          av.writeHasDefaultValue(parameterDescriptor.declaresDefaultValue());
          av.writeNullable(parameterDescriptor.getType().isNullable());
          if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(i) != null) {
            av.writeType(jvmSignature.getKotlinParameterTypes().get(i + start).getKotlinSignature());
          }
          av.visitEnd();
        }
      }
    }
    if (!isAbstract && state.getClassBuilderMode() == ClassBuilderMode.STUBS) {
      StubCodegen.generateStubCode(mv);
    }
    if (!isAbstract && state.getClassBuilderMode() == ClassBuilderMode.FULL) {
      mv.visitCode();
      Label methodBegin=new Label();
      mv.visitLabel(methodBegin);
      FrameMap frameMap=context.prepareFrame(state.getInjector().getJetTypeMapper());
      ExpressionCodegen codegen=new ExpressionCodegen(mv,frameMap,jvmSignature.getAsmMethod().getReturnType(),context,state);
      Type[] argTypes=jvmSignature.getAsmMethod().getArgumentTypes();
      int add=0;
      if (kind == OwnerKind.TRAIT_IMPL) {
        add++;
      }
      if (receiverParameter.exists()) {
        add++;
      }
      for (int i=0; i < paramDescrs.size(); i++) {
        ValueParameterDescriptor parameter=paramDescrs.get(i);
        frameMap.enter(parameter,argTypes[i + add]);
      }
      if (!isStatic && (kind instanceof OwnerKind.DelegateKind) != (functionDescriptor.getKind() == FunctionDescriptor.Kind.DELEGATION)) {
        throw new IllegalStateException("mismatching kind in " + functionDescriptor);
      }
      Map<Name,Label> mapLabelsToDivideLocalVarVisibilityForSharedVar=new HashMap<Name,Label>();
      if (kind instanceof OwnerKind.StaticDelegateKind) {
        OwnerKind.StaticDelegateKind dk=(OwnerKind.StaticDelegateKind)kind;
        InstructionAdapter iv=new InstructionAdapter(mv);
        for (int i=0, k=0; i < argTypes.length; i++) {
          Type argType=argTypes[i];
          iv.load(k,argType);
          k+=argType.getSize();
        }
        iv.invokestatic(dk.getOwnerClass(),jvmSignature.getAsmMethod().getName(),jvmSignature.getAsmMethod().getDescriptor());
        iv.areturn(jvmSignature.getAsmMethod().getReturnType());
      }
 else       if (kind instanceof OwnerKind.DelegateKind) {
        OwnerKind.DelegateKind dk=(OwnerKind.DelegateKind)kind;
        InstructionAdapter iv=new InstructionAdapter(mv);
        iv.load(0,JetTypeMapper.TYPE_OBJECT);
        dk.getDelegate().put(JetTypeMapper.TYPE_OBJECT,iv);
        for (int i=0; i < argTypes.length; i++) {
          Type argType=argTypes[i];
          iv.load(i + 1,argType);
        }
        iv.invokeinterface(dk.getOwnerClass(),jvmSignature.getAsmMethod().getName(),jvmSignature.getAsmMethod().getDescriptor());
        iv.areturn(jvmSignature.getAsmMethod().getReturnType());
      }
 else {
        for (        ValueParameterDescriptor parameter : paramDescrs) {
          Type sharedVarType=state.getInjector().getJetTypeMapper().getSharedVarType(parameter);
          if (sharedVarType != null) {
            Type localVarType=state.getInjector().getJetTypeMapper().mapType(parameter.getType(),MapTypeMode.VALUE);
            int index=frameMap.getIndex(parameter);
            mv.visitTypeInsn(NEW,sharedVarType.getInternalName());
            mv.visitInsn(DUP);
            mv.visitInsn(DUP);
            mv.visitMethodInsn(INVOKESPECIAL,sharedVarType.getInternalName(),"<init>","()V");
            mv.visitVarInsn(localVarType.getOpcode(ILOAD),index);
            mv.visitFieldInsn(PUTFIELD,sharedVarType.getInternalName(),"ref",StackValue.refType(localVarType).getDescriptor());
            Label labelToDivideLocalVarForSharedVarVisibility=new Label();
            mv.visitLabel(labelToDivideLocalVarForSharedVarVisibility);
            mapLabelsToDivideLocalVarVisibilityForSharedVar.put(parameter.getName(),labelToDivideLocalVarForSharedVarVisibility);
            mv.visitVarInsn(sharedVarType.getOpcode(ISTORE),index);
          }
        }
        codegen.returnExpression(bodyExpressions);
      }
      Label methodEnd=new Label();
      mv.visitLabel(methodEnd);
      Collection<String> localVariableNames=new HashSet<String>();
      localVariableNames.addAll(codegen.getLocalVariableNamesForExpression());
      for (      ValueParameterDescriptor parameterDescriptor : paramDescrs) {
        localVariableNames.add(parameterDescriptor.getName().getName());
      }
      int k=0;
      if (expectedThisObject.exists()) {
        Type type=state.getInjector().getJetTypeMapper().mapType(expectedThisObject.getType(),MapTypeMode.VALUE);
        mv.visitLocalVariable("this",type.getDescriptor(),null,methodBegin,methodEnd,k++);
      }
 else       if (fun instanceof JetFunctionLiteralExpression || CodegenUtil.isLocalFun(functionDescriptor,state.getBindingContext())) {
        Type type=state.getInjector().getJetTypeMapper().mapType(context.getThisDescriptor().getDefaultType(),MapTypeMode.VALUE);
        mv.visitLocalVariable("this",type.getDescriptor(),null,methodBegin,methodEnd,k++);
      }
      if (receiverParameter.exists()) {
        Type type=state.getInjector().getJetTypeMapper().mapType(receiverParameter.getType(),MapTypeMode.VALUE);
        mv.visitLocalVariable("this$receiver",type.getDescriptor(),null,methodBegin,methodEnd,k);
        k+=type.getSize();
      }
      for (      ValueParameterDescriptor parameter : paramDescrs) {
        Type type=state.getInjector().getJetTypeMapper().mapType(parameter.getType(),MapTypeMode.VALUE);
        Label divideLabel=mapLabelsToDivideLocalVarVisibilityForSharedVar.get(parameter.getName());
        String parameterName=parameter.getName().getName();
        if (divideLabel != null) {
          Type sharedVarType=state.getInjector().getJetTypeMapper().getSharedVarType(parameter);
          mv.visitLocalVariable(parameterName,type.getDescriptor(),null,methodBegin,divideLabel,k);
          String nameForSharedVar=CodegenUtil.generateTmpVariableName(localVariableNames);
          localVariableNames.add(nameForSharedVar);
          mv.visitLocalVariable(nameForSharedVar,sharedVarType.getDescriptor(),null,divideLabel,methodEnd,k);
          k+=Math.max(type.getSize(),sharedVarType.getSize());
        }
 else {
          mv.visitLocalVariable(parameter.getName().getName(),type.getDescriptor(),null,methodBegin,methodEnd,k);
          k+=type.getSize();
        }
      }
      endVisit(mv,null,fun);
      mv.visitEnd();
      generateBridgeIfNeeded(owner,state,v,jvmSignature.getAsmMethod(),functionDescriptor,kind);
    }
  }
  generateDefaultIfNeeded(context,state,v,jvmSignature.getAsmMethod(),functionDescriptor,kind);
}
