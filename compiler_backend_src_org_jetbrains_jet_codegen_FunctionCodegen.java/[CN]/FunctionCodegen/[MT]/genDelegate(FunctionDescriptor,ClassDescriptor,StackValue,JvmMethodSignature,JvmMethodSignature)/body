{
  Method overriddenMethod=jvmOverriddenMethodSignature.getAsmMethod();
  Method delegateMethod=jvmDelegateMethodSignature.getAsmMethod();
  int flags=ACC_PUBLIC;
  MethodVisitor mv=v.newMethod(null,flags,delegateMethod.getName(),delegateMethod.getDescriptor(),null,CodegenUtil.getExceptions(functionDescriptor,typeMapper));
  if (state.getClassBuilderMode() != ClassBuilderMode.FULL)   return;
  mv.visitCode();
  Type[] argTypes=delegateMethod.getArgumentTypes();
  Type[] originalArgTypes=overriddenMethod.getArgumentTypes();
  InstructionAdapter iv=new InstructionAdapter(mv);
  iv.load(0,OBJECT_TYPE);
  field.put(field.type,iv);
  for (int i=0, reg=1; i < argTypes.length; i++) {
    StackValue.local(reg,argTypes[i]).put(originalArgTypes[i],iv);
    reg+=argTypes[i].getSize();
  }
  String internalName=typeMapper.mapType(toClass).getInternalName();
  if (toClass.getKind() == ClassKind.TRAIT) {
    iv.invokeinterface(internalName,overriddenMethod.getName(),overriddenMethod.getDescriptor());
  }
 else {
    iv.invokevirtual(internalName,overriddenMethod.getName(),overriddenMethod.getDescriptor());
  }
  StackValue.onStack(overriddenMethod.getReturnType()).put(delegateMethod.getReturnType(),iv);
  iv.areturn(delegateMethod.getReturnType());
  endVisit(mv,"Delegate method " + functionDescriptor + " to "+ jvmOverriddenMethodSignature,descriptorToDeclaration(bindingContext,functionDescriptor.getContainingDeclaration()));
  generateBridgeIfNeeded(functionDescriptor);
}
