{
  generateMethod(OtherOrigin(functionDescriptor),jvmDelegateMethodSignature,functionDescriptor,new FunctionGenerationStrategy(){
    @Override public void generateBody(    @NotNull MethodVisitor mv,    @NotNull FrameMap frameMap,    @NotNull JvmMethodSignature signature,    @NotNull MethodContext context,    @NotNull MemberCodegen<?> parentCodegen){
      Method overriddenMethod=jvmOverriddenMethodSignature.getAsmMethod();
      Method delegateMethod=jvmDelegateMethodSignature.getAsmMethod();
      Type[] argTypes=delegateMethod.getArgumentTypes();
      Type[] originalArgTypes=overriddenMethod.getArgumentTypes();
      InstructionAdapter iv=new InstructionAdapter(mv);
      iv.load(0,OBJECT_TYPE);
      field.put(field.type,iv);
      for (int i=0, reg=1; i < argTypes.length; i++) {
        StackValue.local(reg,argTypes[i]).put(originalArgTypes[i],iv);
        reg+=argTypes[i].getSize();
      }
      String internalName=typeMapper.mapType(toClass).getInternalName();
      if (toClass.getKind() == ClassKind.TRAIT) {
        iv.invokeinterface(internalName,overriddenMethod.getName(),overriddenMethod.getDescriptor());
      }
 else {
        iv.invokevirtual(internalName,overriddenMethod.getName(),overriddenMethod.getDescriptor());
      }
      StackValue.onStack(overriddenMethod.getReturnType()).put(delegateMethod.getReturnType(),iv);
      iv.areturn(delegateMethod.getReturnType());
    }
  }
);
}
