{
  Method overriddenMethod=jvmOverriddenMethodSignature.getAsmMethod();
  Method delegateMethod=jvmDelegateMethodSignature.getAsmMethod();
  int flags=ACC_PUBLIC | ACC_SYNTHETIC;
  MethodVisitor mv=v.newMethod(null,flags,delegateMethod.getName(),delegateMethod.getDescriptor(),null,null);
  if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {
    mv.visitCode();
    Type[] argTypes=delegateMethod.getArgumentTypes();
    Type[] originalArgTypes=overriddenMethod.getArgumentTypes();
    InstructionAdapter iv=new InstructionAdapter(mv);
    iv.load(0,OBJECT_TYPE);
    field.put(field.type,iv);
    for (int i=0, reg=1; i < argTypes.length; i++) {
      StackValue.local(reg,argTypes[i]).put(originalArgTypes[i],iv);
      reg+=argTypes[i].getSize();
    }
    String internalName=typeMapper.mapType(toClass).getInternalName();
    if (toClass.getKind() == ClassKind.TRAIT) {
      iv.invokeinterface(internalName,overriddenMethod.getName(),overriddenMethod.getDescriptor());
    }
 else {
      iv.invokevirtual(internalName,overriddenMethod.getName(),overriddenMethod.getDescriptor());
    }
    StackValue.onStack(overriddenMethod.getReturnType()).put(delegateMethod.getReturnType(),iv);
    iv.areturn(delegateMethod.getReturnType());
    endVisit(mv,"Delegate method " + functionDescriptor + " to "+ jvmOverriddenMethodSignature,descriptorToDeclaration(bindingContext,functionDescriptor.getContainingDeclaration()));
    generateBridgeIfNeeded(owner,state,v,jvmDelegateMethodSignature.getAsmMethod(),functionDescriptor);
  }
}
