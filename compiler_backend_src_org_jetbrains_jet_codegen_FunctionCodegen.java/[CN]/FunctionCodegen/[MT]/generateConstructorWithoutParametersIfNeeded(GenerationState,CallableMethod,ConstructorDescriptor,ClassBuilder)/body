{
  if (!isDefaultConstructorNeeded(state.getBindingContext(),constructorDescriptor)) {
    return;
  }
  int flags=getVisibilityAccessFlag(constructorDescriptor);
  MethodVisitor mv=classBuilder.newMethod(OtherOrigin(constructorDescriptor),flags,"<init>","()V",null,getThrownExceptions(constructorDescriptor,state.getTypeMapper()));
  if (state.getClassBuilderMode() == ClassBuilderMode.LIGHT_CLASSES)   return;
  InstructionAdapter v=new InstructionAdapter(mv);
  mv.visitCode();
  Type methodOwner=method.getOwner();
  v.load(0,methodOwner);
  int mask=0;
  List<Integer> masks=new ArrayList<Integer>(1);
  for (  ValueParameterDescriptor parameterDescriptor : constructorDescriptor.getValueParameters()) {
    Type paramType=state.getTypeMapper().mapType(parameterDescriptor.getType());
    pushDefaultValueOnStack(paramType,v);
    int i=parameterDescriptor.getIndex();
    if (i != 0 && i % Integer.SIZE == 0) {
      masks.add(mask);
      mask=0;
    }
    mask|=(1 << (i % Integer.SIZE));
  }
  masks.add(mask);
  for (  int m : masks) {
    v.iconst(m);
  }
  String desc=JetTypeMapper.getDefaultDescriptor(method.getAsmMethod(),false);
  v.invokespecial(methodOwner.getInternalName(),"<init>",desc,false);
  v.areturn(Type.VOID_TYPE);
  endVisit(mv,"default constructor for " + methodOwner.getInternalName(),null);
}
