{
  Method overriddenMethod=jvmOverriddenMethodSignature.getAsmMethod();
  Method delegateMethod=jvmDelegateMethodSignature.getAsmMethod();
  int flags=ACC_PUBLIC | ACC_SYNTHETIC;
  final MethodVisitor mv=v.newMethod(null,flags,delegateMethod.getName(),delegateMethod.getDescriptor(),null,null);
  if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {
    genStubCode(mv);
  }
 else   if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {
    mv.visitCode();
    Type[] argTypes=overriddenMethod.getArgumentTypes();
    InstructionAdapter iv=new InstructionAdapter(mv);
    iv.load(0,OBJECT_TYPE);
    field.put(field.type,iv);
    for (int i=0, reg=1; i < argTypes.length; i++) {
      Type argType=argTypes[i];
      iv.load(reg,argType);
      if (argType.getSort() == Type.OBJECT) {
        StackValue.onStack(OBJECT_TYPE).put(overriddenMethod.getArgumentTypes()[i],iv);
      }
 else       if (argType.getSort() == Type.ARRAY) {
        StackValue.onStack(JAVA_ARRAY_GENERIC_TYPE).put(overriddenMethod.getArgumentTypes()[i],iv);
      }
      reg+=argType.getSize();
    }
    ClassDescriptor classDescriptor=(ClassDescriptor)overriddenDescriptor.getContainingDeclaration();
    String internalName=state.getTypeMapper().mapType(classDescriptor).getInternalName();
    if (classDescriptor.getKind() == ClassKind.TRAIT) {
      iv.invokeinterface(internalName,overriddenMethod.getName(),overriddenMethod.getDescriptor());
    }
 else {
      iv.invokevirtual(internalName,overriddenMethod.getName(),overriddenMethod.getDescriptor());
    }
    StackValue.onStack(overriddenMethod.getReturnType()).put(delegateMethod.getReturnType(),iv);
    iv.areturn(delegateMethod.getReturnType());
    endVisit(mv,"delegate method",descriptorToDeclaration(bindingContext,functionDescriptor));
  }
}
