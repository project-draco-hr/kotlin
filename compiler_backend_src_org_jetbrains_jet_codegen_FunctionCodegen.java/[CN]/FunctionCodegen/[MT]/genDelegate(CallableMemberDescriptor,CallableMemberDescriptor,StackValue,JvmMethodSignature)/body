{
  Method method=jvmMethodSignature.getAsmMethod();
  int flags=ACC_PUBLIC | ACC_SYNTHETIC;
  final MethodVisitor mv=v.newMethod(null,flags,method.getName(),method.getDescriptor(),null,null);
  if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {
    StubCodegen.generateStubCode(mv);
  }
 else   if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {
    mv.visitCode();
    Type[] argTypes=method.getArgumentTypes();
    InstructionAdapter iv=new InstructionAdapter(mv);
    iv.load(0,OBJECT_TYPE);
    for (int i=0, reg=1; i < argTypes.length; i++) {
      Type argType=argTypes[i];
      iv.load(reg,argType);
      if (argType.getSort() == Type.OBJECT) {
        StackValue.onStack(OBJECT_TYPE).put(method.getArgumentTypes()[i],iv);
      }
 else       if (argType.getSort() == Type.ARRAY) {
        StackValue.onStack(JAVA_ARRAY_GENERIC_TYPE).put(method.getArgumentTypes()[i],iv);
      }
      reg+=argType.getSize();
    }
    iv.load(0,OBJECT_TYPE);
    field.put(field.type,iv);
    ClassDescriptor classDescriptor=(ClassDescriptor)overriddenDescriptor.getContainingDeclaration();
    String internalName=state.getTypeMapper().mapType(classDescriptor.getDefaultType(),JetTypeMapperMode.VALUE).getInternalName();
    if (classDescriptor.getKind() == ClassKind.TRAIT) {
      iv.invokeinterface(internalName,method.getName(),method.getDescriptor());
    }
 else {
      iv.invokevirtual(internalName,method.getName(),method.getDescriptor());
    }
    iv.areturn(method.getReturnType());
    endVisit(mv,"delegate method",descriptorToDeclaration(bindingContext,functionDescriptor));
  }
}
