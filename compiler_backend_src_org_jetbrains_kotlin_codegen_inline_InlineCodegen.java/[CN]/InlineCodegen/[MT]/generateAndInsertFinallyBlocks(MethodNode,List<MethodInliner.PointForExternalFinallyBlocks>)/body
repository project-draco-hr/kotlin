{
  if (!codegen.hasFinallyBlocks())   return;
  Map<AbstractInsnNode,MethodInliner.PointForExternalFinallyBlocks> extensionPoints=new HashMap<AbstractInsnNode,MethodInliner.PointForExternalFinallyBlocks>();
  for (  MethodInliner.PointForExternalFinallyBlocks insertPoint : insertPoints) {
    extensionPoints.put(insertPoint.beforeIns,insertPoint);
  }
  DefaultProcessor processor=new DefaultProcessor(intoNode);
  AbstractInsnNode curInstr=intoNode.instructions.getFirst();
  while (curInstr != null) {
    processor.processInstruction(curInstr,true);
    MethodInliner.PointForExternalFinallyBlocks extension=extensionPoints.get(curInstr);
    if (extension != null) {
      Label start=new Label();
      Label end=new Label();
      MethodNode finallyNode=InlineCodegenUtil.createEmptyMethodNode();
      finallyNode.visitLabel(start);
      ExpressionCodegen finallyCodegen=new ExpressionCodegen(finallyNode,codegen.getFrameMap(),codegen.getReturnType(),codegen.getContext(),codegen.getState(),codegen.getParentCodegen());
      finallyCodegen.addBlockStackElementsForNonLocalReturns(codegen.getBlockStackElements());
      finallyCodegen.generateFinallyBlocksIfNeeded(extension.returnType);
      finallyNode.visitLabel(end);
      InlineCodegenUtil.insertNodeBefore(finallyNode,intoNode,curInstr);
      SimpleInterval splitBy=new SimpleInterval((LabelNode)start.info,(LabelNode)end.info);
      processor.getTryBlocksMetaInfo().splitCurrentIntervals(splitBy,false);
      processor.getLocalVarsMetaInfo().splitCurrentIntervals(splitBy,false);
    }
    curInstr=curInstr.getNext();
  }
  processor.sortTryCatchBlocks();
  processor.substituteTryBlockNodes(intoNode);
}
