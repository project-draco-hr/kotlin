{
  MethodNode node=nodeAndSmap.getNode();
  ReifiedTypeParametersUsages reificationResult=reifiedTypeInliner.reifyInstructions(node);
  generateClosuresBodies();
  putClosureParametersOnStack();
  addInlineMarker(codegen.v,true);
  Parameters parameters=invocationParamBuilder.buildParameters();
  InliningContext info=new RootInliningContext(expressionMap,state,codegen.getInlineNameGenerator().subGenerator(functionDescriptor.getName().asString()),codegen.getContext(),callElement,codegen.getParentCodegen().getClassName(),reifiedTypeInliner);
  MethodInliner inliner=new MethodInliner(node,parameters,info,new FieldRemapper(null,null,parameters),isSameModule,"Method inlining " + callElement.getText(),createNestedSourceMapper(nodeAndSmap));
  LocalVarRemapper remapper=new LocalVarRemapper(parameters,initialFrameSize);
  MethodNode adapter=InlineCodegenUtil.createEmptyMethodNode();
  adapter.visitInsn(Opcodes.NOP);
  InlineResult result=inliner.doInline(adapter,remapper,true,LabelOwner.SKIP_ALL);
  result.getReifiedTypeParametersUsages().mergeAll(reificationResult);
  CallableMemberDescriptor descriptor=codegen.getContext().getContextDescriptor();
  final Set<String> labels=getDeclarationLabels(DescriptorToSourceUtils.descriptorToDeclaration(descriptor),descriptor);
  LabelOwner labelOwner=new LabelOwner(){
    @Override public boolean isMyLabel(    @NotNull String name){
      return labels.contains(name);
    }
  }
;
  List<MethodInliner.PointForExternalFinallyBlocks> infos=MethodInliner.processReturns(adapter,labelOwner,true,null);
  generateAndInsertFinallyBlocks(adapter,infos,((StackValue.Local)remapper.remap(parameters.getArgsSizeOnStack() + 1).value).index);
  removeFinallyMarkers(adapter);
  adapter.accept(new InliningInstructionAdapter(codegen.v));
  addInlineMarker(codegen.v,false);
  return result;
}
