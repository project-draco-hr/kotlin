{
  MethodNode node=nodeAndSmap.getNode();
  ReifiedTypeParametersUsages reificationResult=reifiedTypeInliner.reifyInstructions(node.instructions);
  generateClosuresBodies();
  putClosureParametersOnStack();
  addInlineMarker(codegen.v,true);
  Parameters parameters=invocationParamBuilder.buildParameters();
  InliningContext info=new RootInliningContext(expressionMap,state,codegen.getInlineNameGenerator().subGenerator(functionDescriptor.getName().asString()),codegen.getContext(),callElement,codegen.getParentCodegen().getClassName(),reifiedTypeInliner);
  MethodInliner inliner=new MethodInliner(node,parameters,info,new FieldRemapper(null,null,parameters),isSameModule,"Method inlining " + callElement.getText(),createNestedSourceMapper(nodeAndSmap));
  LocalVarRemapper remapper=new LocalVarRemapper(parameters,initialFrameSize);
  MethodNode adapter=InlineCodegenUtil.createEmptyMethodNode();
  InlineResult result=inliner.doInline(adapter,remapper,true,LabelOwner.SKIP_ALL);
  result.getReifiedTypeParametersUsages().mergeAll(reificationResult);
  LabelOwner labelOwner=new LabelOwner(){
    final CallableMemberDescriptor descriptor=codegen.getContext().getContextDescriptor();
    final boolean isLambda=isFunctionExpression(descriptor) || isFunctionLiteral(descriptor);
    @Override public boolean isMyLabel(    @NotNull String name){
      if (InlineCodegenUtil.ROOT_LABEL.equals(name)) {
        return !isLambda;
      }
 else {
        return descriptor.getName().asString().equals(name);
      }
    }
  }
;
  List<MethodInliner.PointForExternalFinallyBlocks> infos=MethodInliner.processReturns(adapter,labelOwner,true,null);
  generateAndInsertFinallyBlocks(adapter,infos);
  adapter.accept(new InliningInstructionAdapter(codegen.v));
  addInlineMarker(codegen.v,false);
  return result;
}
