{
  LOG.assertTrue(inferenceErrorData.constraintSystem.getStatus().hasConflictingConstraints(),renderDebugMessage("Conflicting substitutions inference error renderer is applied for incorrect status",inferenceErrorData));
  Collection<CallableDescriptor> substitutedDescriptors=Lists.newArrayList();
  Collection<TypeSubstitutor> substitutors=ConstraintsUtil.getSubstitutorsForConflictingParameters(inferenceErrorData.constraintSystem);
  for (  TypeSubstitutor substitutor : substitutors) {
    CallableDescriptor substitutedDescriptor=inferenceErrorData.descriptor.substitute(substitutor);
    substitutedDescriptors.add(substitutedDescriptor);
  }
  TypeParameterDescriptor firstConflictingParameter=ConstraintsUtil.getFirstConflictingParameter(inferenceErrorData.constraintSystem);
  if (firstConflictingParameter == null) {
    LOG.error(renderDebugMessage("There is no conflicting parameter for 'conflicting constraints' error.",inferenceErrorData));
    return result;
  }
  result.text(newText().normal("Cannot infer type parameter ").strong(firstConflictingParameter.getName()).normal(" in "));
  TableRenderer table=newTable();
  result.table(table);
  table.descriptor(inferenceErrorData.descriptor).text("None of the following substitutions");
  for (  CallableDescriptor substitutedDescriptor : substitutedDescriptors) {
    JetType receiverType=DescriptorUtils.getReceiverParameterType(substitutedDescriptor.getReceiverParameter());
    final Collection<ConstraintPosition> errorPositions=Sets.newHashSet();
    List<JetType> parameterTypes=Lists.newArrayList();
    for (    ValueParameterDescriptor valueParameterDescriptor : substitutedDescriptor.getValueParameters()) {
      parameterTypes.add(valueParameterDescriptor.getType());
      if (valueParameterDescriptor.getIndex() >= inferenceErrorData.valueArgumentsTypes.size())       continue;
      JetType actualType=inferenceErrorData.valueArgumentsTypes.get(valueParameterDescriptor.getIndex());
      if (!JetTypeChecker.DEFAULT.isSubtypeOf(actualType,valueParameterDescriptor.getType())) {
        errorPositions.add(ConstraintPosition.getValueParameterPosition(valueParameterDescriptor.getIndex()));
      }
    }
    if (receiverType != null && inferenceErrorData.receiverArgumentType != null && !JetTypeChecker.DEFAULT.isSubtypeOf(inferenceErrorData.receiverArgumentType,receiverType)) {
      errorPositions.add(ConstraintPosition.RECEIVER_POSITION);
    }
    Predicate<ConstraintPosition> isErrorPosition=new Predicate<ConstraintPosition>(){
      @Override public boolean apply(      @Nullable ConstraintPosition constraintPosition){
        return errorPositions.contains(constraintPosition);
      }
    }
;
    table.functionArgumentTypeList(receiverType,parameterTypes,isErrorPosition);
  }
  table.text("can be applied to").functionArgumentTypeList(inferenceErrorData.receiverArgumentType,inferenceErrorData.valueArgumentsTypes);
  return result;
}
