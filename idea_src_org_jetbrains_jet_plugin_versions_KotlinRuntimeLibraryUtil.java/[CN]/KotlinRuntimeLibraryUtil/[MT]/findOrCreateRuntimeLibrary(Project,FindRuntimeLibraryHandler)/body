{
  final LibraryTable table=ProjectLibraryTable.getInstance(project);
  final Library kotlinRuntime=table.getLibraryByName(LIBRARY_NAME);
  if (kotlinRuntime != null) {
    for (    VirtualFile root : kotlinRuntime.getFiles(OrderRootType.CLASSES)) {
      if (root.getName().equals(KOTLIN_RUNTIME_JAR)) {
        return kotlinRuntime;
      }
    }
  }
  File runtimePath=PathUtil.getKotlinPathsForIdeaPlugin().getRuntimePath();
  if (!runtimePath.exists()) {
    handler.runtimePathDoesNotExist(runtimePath);
    return null;
  }
  final File targetJar=handler.getRuntimeJarPath();
  if (targetJar == null)   return null;
  try {
    FileUtil.copy(runtimePath,targetJar);
    VirtualFile jarVfs=LocalFileSystem.getInstance().refreshAndFindFileByIoFile(targetJar);
    if (jarVfs != null) {
      jarVfs.refresh(false,false);
    }
  }
 catch (  IOException e) {
    handler.ioExceptionOnCopyingJar(e);
    return null;
  }
  return ApplicationManager.getApplication().runWriteAction(new Computable<Library>(){
    @Override public Library compute(){
      Library result=kotlinRuntime == null ? table.createLibrary("KotlinRuntime") : kotlinRuntime;
      Library.ModifiableModel model=result.getModifiableModel();
      model.addRoot(VfsUtil.getUrlForLibraryRoot(targetJar),OrderRootType.CLASSES);
      model.addRoot(VfsUtil.getUrlForLibraryRoot(targetJar) + "src",OrderRootType.SOURCES);
      model.commit();
      return result;
    }
  }
);
}
