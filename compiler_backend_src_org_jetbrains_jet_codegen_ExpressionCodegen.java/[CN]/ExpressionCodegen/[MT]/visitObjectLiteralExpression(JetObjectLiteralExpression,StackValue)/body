{
  FunctionOrClosureCodegen closureCodegen=new FunctionOrClosureCodegen(this,context,state);
  GeneratedAnonymousClassDescriptor closure=state.generateObjectLiteral(expression,closureCodegen);
  Type type=Type.getObjectType(closure.getClassname());
  v.anew(type);
  v.dup();
  final List<Type> consArgTypes=new LinkedList<Type>(Arrays.asList(closure.getConstructor().getArgumentTypes()));
  if (consArgTypes.size() > 0) {
    v.load(0,JetTypeMapper.TYPE_OBJECT);
  }
  for (  DeclarationDescriptor descriptor : closureCodegen.closure.keySet()) {
    Type sharedVarType=getSharedVarType(descriptor);
    if (sharedVarType == null)     sharedVarType=state.getTypeMapper().mapType(((VariableDescriptor)descriptor).getOutType());
    consArgTypes.add(sharedVarType);
    final EnclosedValueDescriptor valueDescriptor=closureCodegen.closure.get(descriptor);
    valueDescriptor.getOuterValue().put(sharedVarType,v);
  }
  Method cons=new Method("<init>",Type.VOID_TYPE,consArgTypes.toArray(new Type[consArgTypes.size()]));
  v.invokespecial(closure.getClassname(),"<init>",cons.getDescriptor());
  return StackValue.onStack(Type.getObjectType(closure.getClassname()));
}
