{
  ObjectOrClosureCodegen closureCodegen=new ObjectOrClosureCodegen(this,context,state);
  GeneratedAnonymousClassDescriptor closure=state.generateObjectLiteral(expression,closureCodegen);
  Type type=Type.getObjectType(closure.getClassname());
  v.anew(type);
  v.dup();
  final List<Type> consArgTypes=new LinkedList<Type>(Arrays.asList(closure.getConstructor().getArgumentTypes()));
  if (consArgTypes.size() > 0) {
    v.load(0,TYPE_OBJECT);
  }
  if (closureCodegen.captureReceiver != null) {
    v.load(context.isStatic() ? 0 : 1,closureCodegen.captureReceiver);
    consArgTypes.add(closureCodegen.captureReceiver);
  }
  for (  Map.Entry<DeclarationDescriptor,EnclosedValueDescriptor> entry : closureCodegen.closure.entrySet()) {
    if (entry.getKey() instanceof VariableDescriptor && !(entry.getKey() instanceof PropertyDescriptor)) {
      Type sharedVarType=typeMapper.getSharedVarType(entry.getKey());
      if (sharedVarType == null)       sharedVarType=state.getTypeMapper().mapType(((VariableDescriptor)entry.getKey()).getOutType());
      consArgTypes.add(sharedVarType);
      entry.getValue().getOuterValue().put(sharedVarType,v);
    }
  }
  if (closureCodegen.superCall != null) {
    ConstructorDescriptor superConstructor=(ConstructorDescriptor)bindingContext.get(BindingContext.REFERENCE_TARGET,closureCodegen.superCall.getCalleeExpression().getConstructorReferenceExpression());
    CallableMethod superCallable=typeMapper.mapToCallableMethod(superConstructor,OwnerKind.IMPLEMENTATION);
    Type[] argumentTypes=superCallable.getSignature().getAsmMethod().getArgumentTypes();
    Collections.addAll(consArgTypes,argumentTypes);
    ResolvedCall resolvedCall=bindingContext.get(BindingContext.RESOLVED_CALL,closureCodegen.superCall.getCalleeExpression());
    pushMethodArguments(resolvedCall,Arrays.asList(argumentTypes));
  }
  Method cons=new Method("<init>",Type.VOID_TYPE,consArgTypes.toArray(new Type[consArgTypes.size()]));
  v.invokespecial(closure.getClassname(),"<init>",cons.getDescriptor());
  return StackValue.onStack(Type.getObjectType(closure.getClassname()));
}
