{
  DeclarationDescriptor constructorDescriptor=bindingContext.get(BindingContext.REFERENCE_TARGET,constructorReference);
  final PsiElement declaration=bindingContext.get(BindingContext.DESCRIPTOR_TO_DECLARATION,constructorDescriptor);
  Type type;
  if (declaration instanceof PsiMethod) {
    type=generateJavaConstructorCall(expression,(PsiMethod)declaration);
  }
 else   if (constructorDescriptor instanceof ConstructorDescriptor) {
    JetType expressionType=bindingContext.get(BindingContext.EXPRESSION_TYPE,expression);
    type=typeMapper.mapType(expressionType,OwnerKind.IMPLEMENTATION);
    if (type.getSort() == Type.ARRAY) {
      generateNewArray(expression,expressionType);
    }
 else {
      ClassDescriptor classDecl=(ClassDescriptor)constructorDescriptor.getContainingDeclaration();
      receiver.put(receiver.type,v);
      v.anew(type);
      if (classDecl.getContainingDeclaration() instanceof ClassDescriptor) {
        if (!receiver.type.equals(Type.VOID_TYPE)) {
          v.dupX1();
          v.swap();
        }
 else {
          v.dup();
          v.load(0,JetTypeMapper.jetImplementationType(classDecl));
        }
      }
 else {
        v.dup();
      }
      CallableMethod method=typeMapper.mapToCallableMethod((ConstructorDescriptor)constructorDescriptor,OwnerKind.IMPLEMENTATION);
      invokeMethodWithArguments(method,expression,StackValue.none());
    }
  }
 else {
    throw new UnsupportedOperationException("don't know how to generate this new expression");
  }
  return StackValue.onStack(type);
}
