{
  v.anew(type);
  v.dup();
  receiver=StackValue.receiver(resolvedCall,receiver,this,null);
  receiver.put(receiver.type,v);
  ConstructorDescriptor constructorDescriptor=(ConstructorDescriptor)resolvedCall.getResultingDescriptor();
  MutableClosure closure=bindingContext.get(CLOSURE,constructorDescriptor.getContainingDeclaration());
  ClassDescriptor descriptor=getExpectedThisObjectForConstructorCall(constructorDescriptor,closure);
  if (receiver.type.getSort() != Type.VOID && descriptor == null) {
    v.pop();
  }
  pushClosureOnStack(closure,resolvedCall.getThisObject().exists() || resolvedCall.getReceiverArgument().exists());
  ConstructorDescriptor originalOfSamAdapter=(ConstructorDescriptor)SamCodegenUtil.getOriginalIfSamAdapter(constructorDescriptor);
  CallableMethod method=typeMapper.mapToCallableMethod(originalOfSamAdapter == null ? constructorDescriptor : originalOfSamAdapter);
  invokeMethodWithArguments(method,resolvedCall,null,StackValue.none());
  return StackValue.onStack(type);
}
