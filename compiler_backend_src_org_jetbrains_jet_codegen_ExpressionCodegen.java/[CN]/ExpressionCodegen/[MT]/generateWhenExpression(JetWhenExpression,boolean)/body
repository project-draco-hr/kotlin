{
  JetExpression expr=expression.getSubjectExpression();
  JetType subjectJetType=bindingContext.get(BindingContext.EXPRESSION_TYPE,expr);
  Type subjectType=asmTypeOrVoid(subjectJetType);
  Type resultType=isStatement ? Type.VOID_TYPE : expressionType(expression);
  if (canSwitchBeUsedIn(expression,subjectType)) {
    return generateSwitch(expression,subjectType,resultType,isStatement);
  }
  int subjectLocal=expr != null ? myFrameMap.enterTemp(subjectType) : -1;
  if (subjectLocal != -1) {
    gen(expr,subjectType);
    tempVariables.put(expr,StackValue.local(subjectLocal,subjectType));
    v.store(subjectLocal,subjectType);
  }
  Label end=new Label();
  boolean hasElse=JetPsiUtil.checkWhenExpressionHasSingleElse(expression);
  Label nextCondition=null;
  for (  JetWhenEntry whenEntry : expression.getEntries()) {
    if (nextCondition != null) {
      v.mark(nextCondition);
    }
    nextCondition=new Label();
    FrameMap.Mark mark=myFrameMap.mark();
    Label thisEntry=new Label();
    if (!whenEntry.isElse()) {
      JetWhenCondition[] conditions=whenEntry.getConditions();
      for (int i=0; i < conditions.length; i++) {
        StackValue conditionValue=generateWhenCondition(subjectType,subjectLocal,conditions[i]);
        conditionValue.condJump(nextCondition,true,v);
        if (i < conditions.length - 1) {
          v.goTo(thisEntry);
          v.mark(nextCondition);
          nextCondition=new Label();
        }
      }
    }
    v.visitLabel(thisEntry);
    gen(whenEntry.getExpression(),resultType);
    mark.dropTo();
    if (!whenEntry.isElse()) {
      v.goTo(end);
    }
  }
  if (!hasElse && nextCondition != null) {
    v.mark(nextCondition);
    if (!isStatement) {
      putUnitInstanceOntoStackForNonExhaustiveWhen(expression);
    }
  }
  markLineNumber(expression);
  v.mark(end);
  myFrameMap.leaveTemp(subjectType);
  tempVariables.remove(expr);
  return StackValue.onStack(resultType);
}
