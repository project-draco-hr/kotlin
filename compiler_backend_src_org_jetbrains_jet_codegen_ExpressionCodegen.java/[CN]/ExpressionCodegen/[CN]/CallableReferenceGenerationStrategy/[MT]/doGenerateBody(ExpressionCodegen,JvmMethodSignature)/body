{
  JetCallExpression fakeExpression=constructFakeFunctionCall();
  final List<? extends ValueArgument> fakeArguments=fakeExpression.getValueArguments();
  final ReceiverValue thisObject=computeAndSaveReceiver(signature,codegen,referencedFunction.getExpectedThisObject());
  final ReceiverValue extensionReceiver=computeAndSaveReceiver(signature,codegen,referencedFunction.getReceiverParameter());
  computeAndSaveArguments(fakeArguments,codegen);
  ResolvedCall<CallableDescriptor> fakeResolvedCall=new DelegatingResolvedCall<CallableDescriptor>(resolvedCall){
    @NotNull @Override public ReceiverValue getReceiverArgument(){
      return extensionReceiver;
    }
    @NotNull @Override public ReceiverValue getThisObject(){
      return thisObject;
    }
    @NotNull @Override public List<ResolvedValueArgument> getValueArgumentsByIndex(){
      List<ResolvedValueArgument> result=new ArrayList<ResolvedValueArgument>(fakeArguments.size());
      for (      ValueArgument argument : fakeArguments) {
        result.add(new ExpressionValueArgument(argument));
      }
      return result;
    }
  }
;
  StackValue result;
  Type returnType=codegen.returnType;
  if (referencedFunction instanceof ConstructorDescriptor) {
    if (returnType.getSort() == Type.ARRAY) {
      codegen.generateNewArray(fakeExpression,referencedFunction.getReturnType());
      result=StackValue.onStack(returnType);
    }
 else {
      result=codegen.generateConstructorCall(fakeResolvedCall,StackValue.none(),returnType);
    }
  }
 else {
    Call call=CallMaker.makeCall(fakeExpression,NO_RECEIVER,null,fakeExpression,fakeArguments);
    Callable callable=codegen.resolveToCallable(codegen.accessibleFunctionDescriptor(referencedFunction),false);
    StackValue receiver=generateCallee(codegen,callable);
    result=codegen.invokeFunctionWithCalleeOnStack(call,receiver,fakeResolvedCall,callable);
  }
  InstructionAdapter v=codegen.v;
  result.put(returnType,v);
  v.areturn(returnType);
}
