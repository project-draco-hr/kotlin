{
  PrintingMessageCollector messageCollector=new PrintingMessageCollector(stream,renderer,true);
  if (arguments.module == null) {
    stream.print(renderer.render(CompilerMessageSeverity.ERROR,"Module should be specified",NO_LOCATION));
    return ExitCode.INTERNAL_ERROR;
  }
  File directory=new File(arguments.module).getParentFile();
  List<Module> modules=CompileEnvironmentUtil.loadModuleScript(arguments.module,MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);
  for (  Module module : modules) {
    Disposable rootDisposable=CompileEnvironmentUtil.createMockDisposable();
    final JetCoreEnvironment environmentForJS=JetCoreEnvironment.getCoreEnvironmentForJS(rootDisposable);
    CompileEnvironmentUtil.addSourcesFromModuleToEnvironment(environmentForJS,module,directory);
    AnalyzerWithCompilerReport analyzerWithCompilerReport=new AnalyzerWithCompilerReport(messageCollector);
    final List<JetFile> sources=environmentForJS.getSourceFiles();
    analyzerWithCompilerReport.analyzeAndReport(new Function0<AnalyzeExhaust>(){
      @Override public AnalyzeExhaust invoke(){
        BindingContext context=AnalyzerFacadeForJS.analyzeFiles(sources,Predicates.<PsiFile>alwaysTrue(),new Config(environmentForJS.getProject()){
          @NotNull @Override protected List<JetFile> generateLibFiles(){
            return Collections.emptyList();
          }
        }
);
        return AnalyzeExhaust.success(context,JetStandardLibrary.getInstance());
      }
    }
,sources);
  }
  stream.print(renderer.render(CompilerMessageSeverity.ERROR,"Greeting",NO_LOCATION));
  return ExitCode.OK;
}
