{
  final Map<VariableDescriptor,VariableInitializers> initialMapForStartInstruction=prepareInitialMapForStartInstruction(data.usedVariables,data.declaredVariables);
  Map<Instruction,Edges<Map<VariableDescriptor,VariableInitializers>>> result=PseudocodeTraverser.collectInformationFromInstructionGraph(false,true,pseudocode,Collections.<VariableDescriptor,VariableInitializers>emptyMap(),initialMapForStartInstruction,new PseudocodeTraverser.InstructionDataMergeStrategy<Map<VariableDescriptor,VariableInitializers>>(){
    @Override public Edges<Map<VariableDescriptor,VariableInitializers>> execute(    @NotNull Instruction instruction,    @NotNull Collection<Map<VariableDescriptor,VariableInitializers>> incomingEdgesData){
      Map<VariableDescriptor,VariableInitializers> enterInstructionData=mergeIncomingEdgesData(incomingEdgesData);
      Map<VariableDescriptor,VariableInitializers> exitInstructionData=addVariableInitializerFromCurrentInstructionIfAny(instruction,enterInstructionData);
      return Edges.create(enterInstructionData,exitInstructionData);
    }
  }
);
  for (  LocalDeclarationInstruction localDeclarationInstruction : pseudocode.getLocalDeclarations()) {
    Pseudocode localPseudocode=localDeclarationInstruction.getBody();
    Map<Instruction,Edges<Map<VariableDescriptor,VariableInitializers>>> initializersForLocalDeclaration=collectVariableInitializers(localPseudocode,declarationDataMap.get(localPseudocode));
    for (    Instruction instruction : initializersForLocalDeclaration.keySet()) {
      if (!result.containsKey(instruction)) {
        result.put(instruction,initializersForLocalDeclaration.get(instruction));
      }
    }
    result.putAll(initializersForLocalDeclaration);
  }
  return result;
}
