{
  final Ref<AlternativeSignatureMismatchException> exception=new Ref<AlternativeSignatureMismatchException>();
  JetType result=alternativeTypeElement.accept(new JetVisitor<JetType,Void>(){
    @Override public JetType visitNullableType(    JetNullableType nullableType,    Void data){
      try {
        if (!autoType.isNullable()) {
          throw new AlternativeSignatureMismatchException(String.format("Auto type '%s' is not-null, while type in alternative signature is nullable: '%s'",DescriptorRenderer.TEXT.renderType(autoType),nullableType.getText()));
        }
        return TypeUtils.makeNullable(computeType(nullableType.getInnerType(),autoType));
      }
 catch (      AlternativeSignatureMismatchException e) {
        exception.set(e);
        return null;
      }
    }
    @Override public JetType visitFunctionType(    JetFunctionType type,    Void data){
      return visitCommonType(type.getReceiverTypeRef() == null ? JetStandardClasses.getFunction(type.getParameters().size()) : JetStandardClasses.getReceiverFunction(type.getParameters().size()),type);
    }
    @Override public JetType visitTupleType(    JetTupleType type,    Void data){
      return visitCommonType(JetStandardClasses.getTuple(type.getComponentTypeRefs().size()),type);
    }
    @Override public JetType visitUserType(    JetUserType type,    Void data){
      JetUserType qualifier=type.getQualifier();
      String shortName=type.getReferenceExpression().getReferencedName();
      String longName=(qualifier == null ? "" : qualifier.getText() + ".") + shortName;
      if (JetStandardClasses.UNIT_ALIAS.getName().equals(longName)) {
        return visitCommonType(JetStandardClasses.getTuple(0),type);
      }
      return visitCommonType(longName,type);
    }
    private JetType visitCommonType(    @NotNull ClassDescriptor classDescriptor,    @NotNull JetTypeElement type){
      return visitCommonType(DescriptorUtils.getFQName(classDescriptor).toSafe().getFqName(),type);
    }
    private JetType visitCommonType(    @NotNull String expectedFqNamePostfix,    @NotNull JetTypeElement type){
      try {
        String fqName=DescriptorUtils.getFQName(autoType.getConstructor().getDeclarationDescriptor()).toSafe().getFqName();
        if (!fqName.endsWith(expectedFqNamePostfix)) {
          throw new AlternativeSignatureMismatchException(String.format("Alternative signature type mismatch, expected: %s, actual: %s",expectedFqNamePostfix,fqName));
        }
        List<TypeProjection> arguments=autoType.getArguments();
        if (arguments.size() != type.getTypeArgumentsAsTypes().size()) {
          throw new AlternativeSignatureMismatchException(String.format("'%s' type in method signature has %d type arguments, while '%s' in alternative signature has %d of them",DescriptorRenderer.TEXT.renderType(autoType),arguments.size(),type.getText(),type.getTypeArgumentsAsTypes().size()));
        }
        List<TypeProjection> altArguments=new ArrayList<TypeProjection>();
        for (int i=0, size=arguments.size(); i < size; i++) {
          JetTypeElement argumentAlternativeTypeElement=type.getTypeArgumentsAsTypes().get(i).getTypeElement();
          TypeProjection argument=arguments.get(i);
          JetType alternativeType=computeType(argumentAlternativeTypeElement,argument.getType());
          Variance variance=argument.getProjectionKind();
          if (type instanceof JetUserType) {
            JetTypeProjection typeProjection=((JetUserType)type).getTypeArguments().get(i);
            Variance altVariance=Variance.INVARIANT;
switch (typeProjection.getProjectionKind()) {
case IN:
              altVariance=Variance.IN_VARIANCE;
            break;
case OUT:
          altVariance=Variance.OUT_VARIANCE;
        break;
case STAR:
      throw new AlternativeSignatureMismatchException("Star projection is not available in alternative signatures");
default :
  }
  if (altVariance != variance) {
    throw new AlternativeSignatureMismatchException(String.format("Variance mismatch, actual: %s, in alternative signature: %s",variance,altVariance));
  }
}
altArguments.add(new TypeProjection(variance,alternativeType));
}
return new JetTypeImpl(autoType.getAnnotations(),autoType.getConstructor(),false,altArguments,autoType.getMemberScope());
}
 catch (AlternativeSignatureMismatchException e) {
exception.set(e);
return null;
}
}
@Override public JetType visitSelfType(JetSelfType type,Void data){
throw new UnsupportedOperationException("Self-types are not supported yet");
}
}
,null);
if (exception.get() != null) {
throw exception.get();
}
return result;
}
