{
  List<PsiErrorElement> syntaxErrors=AnalyzingUtils.getSyntaxErrorRanges(altFunDeclaration);
  if (!syntaxErrors.isEmpty()) {
    String textSignature=String.format("%s(%s)",method.getName(),StringUtil.join(method.getPsiMethod().getSignature(PsiSubstitutor.EMPTY).getParameterTypes(),new Function<PsiType,String>(){
      @Override public String fun(      PsiType psiType){
        return psiType.getPresentableText();
      }
    }
,", "));
    int errorOffset=syntaxErrors.get(0).getTextOffset();
    String syntaxErrorDescription=syntaxErrors.get(0).getErrorDescription();
    String errorText=syntaxErrors.size() == 1 ? String.format("Alternative signature for %s has syntax error at %d: %s",textSignature,errorOffset,syntaxErrorDescription) : String.format("Alternative signature for %s has %d syntax errors, first is at %d: %s",textSignature,syntaxErrors.size(),errorOffset,syntaxErrorDescription);
    throw new AlternativeSignatureMismatchException(errorText);
  }
}
