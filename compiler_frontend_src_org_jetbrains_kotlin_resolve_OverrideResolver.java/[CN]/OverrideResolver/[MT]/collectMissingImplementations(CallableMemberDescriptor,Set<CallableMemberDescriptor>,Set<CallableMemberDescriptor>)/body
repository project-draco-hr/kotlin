{
  if (descriptor.getKind().isReal())   return;
  if (descriptor.getVisibility() == Visibilities.INVISIBLE_FAKE)   return;
  Collection<? extends CallableMemberDescriptor> directOverridden=descriptor.getOverriddenDescriptors();
  if (directOverridden.size() == 0) {
    throw new IllegalStateException("A 'fake override' must override something");
  }
  Map<CallableMemberDescriptor,Set<CallableMemberDescriptor>> overriddenDeclarationsByDirectParent=collectOverriddenDeclarations(directOverridden);
  List<CallableMemberDescriptor> allOverriddenDeclarations=ContainerUtil.flatten(overriddenDeclarationsByDirectParent.values());
  Set<CallableMemberDescriptor> allFilteredOverriddenDeclarations=filterOutOverridden(Sets.newLinkedHashSet(allOverriddenDeclarations));
  Set<CallableMemberDescriptor> relevantDirectlyOverridden=getRelevantDirectlyOverridden(overriddenDeclarationsByDirectParent,allFilteredOverriddenDeclarations);
  List<CallableMemberDescriptor> implementations=collectImplementations(relevantDirectlyOverridden);
  if (implementations.size() == 1 && isReturnTypeOkForOverride(descriptor,implementations.get(0)))   return;
  List<CallableMemberDescriptor> abstractOverridden=new ArrayList<CallableMemberDescriptor>(allFilteredOverriddenDeclarations.size());
  List<CallableMemberDescriptor> concreteOverridden=new ArrayList<CallableMemberDescriptor>(allFilteredOverriddenDeclarations.size());
  filterNotSynthesizedDescriptorsByModality(allFilteredOverriddenDeclarations,abstractOverridden,concreteOverridden);
  if (implementations.isEmpty()) {
    abstractNoImpl.addAll(abstractOverridden);
  }
 else   if (implementations.size() > 1) {
    manyImpl.addAll(concreteOverridden);
  }
 else {
    abstractNoImpl.addAll(collectAbstractMethodsWithMoreSpecificReturnType(abstractOverridden,implementations.get(0)));
  }
}
