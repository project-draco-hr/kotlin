{
  ConstraintSystem constraintSystem=inferenceErrorData.constraintSystem;
  TypeParameterDescriptor typeParameterWithCapturedConstraint=null;
  CapturedTypeConstructor capturedTypeConstructor=null;
  for (  TypeParameterDescriptor typeParameter : constraintSystem.getTypeVariables()) {
    TypeBounds typeBounds=constraintSystem.getTypeBounds(typeParameter);
    for (    TypeBounds.Bound bound : typeBounds.getBounds()) {
      TypeConstructor constructor=bound.getConstrainingType().getConstructor();
      if (constructor instanceof CapturedTypeConstructor) {
        typeParameterWithCapturedConstraint=typeParameter;
        capturedTypeConstructor=(CapturedTypeConstructor)constructor;
      }
    }
  }
  if (capturedTypeConstructor == null) {
    LOG.error(renderDebugMessage("There is no captured type in bounds, but there is an error 'cannot capture type parameter'",inferenceErrorData));
    return result;
  }
  String explanation;
  JetType upperBound=typeParameterWithCapturedConstraint.getUpperBoundsAsType();
  if (!KotlinBuiltIns.isNullableAny(upperBound) && capturedTypeConstructor.getTypeProjection().getProjectionKind() == Variance.IN_VARIANCE) {
    explanation="Type parameter has an upper bound '" + result.getTypeRenderer().render(upperBound) + "'"+ " that cannot be satisfied capturing 'in' projection";
  }
 else {
    explanation="Only top-level type projections can be captured";
  }
  result.text(newText().normal("'" + typeParameterWithCapturedConstraint.getName() + "'"+ " cannot capture "+ "'"+ capturedTypeConstructor.getTypeProjection()+ "'. "+ explanation));
  return result;
}
