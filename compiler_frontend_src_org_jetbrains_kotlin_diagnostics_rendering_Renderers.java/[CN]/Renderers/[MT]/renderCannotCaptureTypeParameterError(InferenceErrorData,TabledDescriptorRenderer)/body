{
  ConstraintSystemImpl constraintSystem=(ConstraintSystemImpl)inferenceErrorData.constraintSystem;
  List<ConstraintError> errors=constraintSystem.getConstraintErrors();
  TypeParameterDescriptor typeParameterWithCapturedConstraint=null;
  for (  ConstraintError error : errors) {
    if (error instanceof CannotCapture) {
      typeParameterWithCapturedConstraint=((CannotCapture)error).getTypeVariable();
    }
  }
  if (typeParameterWithCapturedConstraint == null) {
    LOG.error(renderDebugMessage("An error 'cannot capture type parameter' is not found in errors",inferenceErrorData));
    return result;
  }
  CapturedTypeConstructor capturedTypeConstructor=null;
  TypeBounds typeBounds=constraintSystem.getTypeBounds(typeParameterWithCapturedConstraint);
  for (  TypeBounds.Bound bound : typeBounds.getBounds()) {
    TypeConstructor constructor=bound.getConstrainingType().getConstructor();
    if (constructor instanceof CapturedTypeConstructor) {
      capturedTypeConstructor=(CapturedTypeConstructor)constructor;
    }
  }
  if (capturedTypeConstructor == null) {
    LOG.error(renderDebugMessage("There is no captured type in bounds, but there is an error 'cannot capture type parameter'",inferenceErrorData));
    return result;
  }
  String explanation;
  JetType upperBound=typeParameterWithCapturedConstraint.getUpperBoundsAsType();
  if (!KotlinBuiltIns.isNullableAny(upperBound) && capturedTypeConstructor.getTypeProjection().getProjectionKind() == Variance.IN_VARIANCE) {
    explanation="Type parameter has an upper bound '" + result.getTypeRenderer().render(upperBound) + "'"+ " that cannot be satisfied capturing 'in' projection";
  }
 else {
    explanation="Only top-level type projections can be captured";
  }
  result.text(newText().normal("'" + typeParameterWithCapturedConstraint.getName() + "'"+ " cannot capture "+ "'"+ capturedTypeConstructor.getTypeProjection()+ "'. "+ explanation));
  return result;
}
