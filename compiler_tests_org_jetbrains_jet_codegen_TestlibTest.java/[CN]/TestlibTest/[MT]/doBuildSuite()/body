{
  try {
    GenerationState generationState=KotlinToJVMBytecodeCompiler.analyzeAndGenerate(myEnvironment,false);
    if (generationState == null) {
      throw new RuntimeException("There were compilation errors");
    }
    ClassFileFactory classFileFactory=generationState.getFactory();
    final GeneratedClassLoader loader=new GeneratedClassLoader(classFileFactory,new URLClassLoader(new URL[]{ForTestCompileRuntime.runtimeJarForTests().toURI().toURL(),junitJar.toURI().toURL()},TestCase.class.getClassLoader()));
    JetTypeMapper typeMapper=generationState.getTypeMapper();
    TestSuite suite=new TestSuite("stdlib_test");
    try {
      for (      JetFile jetFile : myEnvironment.getSourceFiles()) {
        for (        JetDeclaration decl : jetFile.getDeclarations()) {
          if (decl instanceof JetClass) {
            JetClass jetClass=(JetClass)decl;
            ClassDescriptor descriptor=(ClassDescriptor)generationState.getBindingContext().get(BindingContext.DECLARATION_TO_DESCRIPTOR,jetClass);
            Set<JetType> allSuperTypes=new THashSet<JetType>();
            DescriptorUtils.addSuperTypes(descriptor.getDefaultType(),allSuperTypes);
            for (            JetType type : allSuperTypes) {
              String internalName=typeMapper.mapType(type,JetTypeMapperMode.IMPL).getInternalName();
              if (internalName.equals("junit/framework/Test")) {
                String name=typeMapper.mapType(descriptor.getDefaultType(),JetTypeMapperMode.IMPL).getInternalName();
                System.out.println(name);
                Class<TestCase> aClass=(Class<TestCase>)loader.loadClass(name.replace('/','.'));
                if ((aClass.getModifiers() & Modifier.ABSTRACT) == 0 && (aClass.getModifiers() & Modifier.PUBLIC) != 0) {
                  try {
                    Constructor<TestCase> constructor=aClass.getConstructor();
                    if (constructor != null && (constructor.getModifiers() & Modifier.PUBLIC) != 0) {
                      suite.addTestSuite(aClass);
                    }
                  }
 catch (                  NoSuchMethodException e) {
                  }
                }
                break;
              }
            }
          }
        }
      }
    }
  finally {
      typeMapper=null;
    }
    return suite;
  }
 catch (  Exception e) {
    throw ExceptionUtils.rethrow(e);
  }
}
