{
  String isApplicableString=InTextDirectivesUtils.findStringWithPrefixes(fileText,"// IS_APPLICABLE: ");
  boolean isApplicableExpected=isApplicableString == null || isApplicableString.equals("true");
  Assert.assertTrue("isAvailable() for " + intentionAction.getClass() + " should return "+ isApplicableExpected,isApplicableExpected == intentionAction.isAvailable(getProject(),getEditor(),getFile()));
  String intentionTextString=InTextDirectivesUtils.findStringWithPrefixes(fileText,"// INTENTION_TEXT: ");
  if (intentionTextString != null) {
    assertEquals("Intention text mismatch.",intentionTextString,intentionAction.getText());
  }
  String shouldFailString=InTextDirectivesUtils.findStringWithPrefixes(fileText,"// SHOULD_FAIL_WITH: ");
  try {
    if (isApplicableExpected) {
      ApplicationPackage.executeWriteCommand(getProject(),intentionAction.getText(),new Function0<Object>(){
        @Override public Object invoke(){
          intentionAction.invoke(getProject(),getEditor(),getFile());
          return null;
        }
      }
);
      if (shouldFailString == null) {
        for (        Map.Entry<String,PsiFile> entry : pathToFile.entrySet()) {
          myFile=entry.getValue();
          String canonicalPathToExpectedFile=PathUtil.getCanonicalPath(entry.getKey() + ".after");
          checkResultByFile(canonicalPathToExpectedFile);
        }
      }
    }
    assertNull("Expected test to fail.",shouldFailString);
  }
 catch (  IntentionTestException e) {
    assertEquals("Failure message mismatch.",shouldFailString,e.getMessage());
  }
catch (  BaseRefactoringProcessor.ConflictsInTestsException e) {
    assertEquals("Failure message mismatch.",shouldFailString,StringUtil.join(e.getMessages(),", "));
  }
}
