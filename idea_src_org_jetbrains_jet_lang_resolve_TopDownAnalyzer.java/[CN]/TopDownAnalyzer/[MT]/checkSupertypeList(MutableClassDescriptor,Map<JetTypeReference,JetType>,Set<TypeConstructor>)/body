{
  Set<TypeConstructor> typeConstructors=Sets.newHashSet();
  boolean classAppeared=false;
  for (  Map.Entry<JetTypeReference,JetType> entry : supertypes.entrySet()) {
    JetTypeReference typeReference=entry.getKey();
    JetType supertype=entry.getValue();
    ClassDescriptor classDescriptor=TypeUtils.getClassDescriptor(supertype);
    if (classDescriptor != null) {
      if (!classDescriptor.getModifiers().isTrait()) {
        if (classAppeared) {
          trace.getErrorHandler().genericError(typeReference.getNode(),"Only one class may appear in a supertype list");
        }
 else {
          classAppeared=true;
        }
      }
    }
 else {
      trace.getErrorHandler().genericError(typeReference.getNode(),"Only classes and traits may serve as supertypes");
    }
    TypeConstructor constructor=supertype.getConstructor();
    if (!typeConstructors.add(constructor)) {
      trace.getErrorHandler().genericError(typeReference.getNode(),"A supertype appears twice");
    }
    if (constructor.isSealed() && !allowedFinalSupertypes.contains(constructor)) {
      trace.getErrorHandler().genericError(typeReference.getNode(),"This type is final, so it cannot be inherited from");
    }
  }
}
