{
  for (  JetDeclaration declaration : declarations) {
    declaration.accept(new JetVisitor(){
      @Override public void visitNamespace(      JetNamespace namespace){
        String name=namespace.getName();
        if (name == null) {
          name="<no name provided>";
        }
        NamespaceDescriptorImpl namespaceDescriptor=owner.getNamespace(name);
        if (namespaceDescriptor == null) {
          namespaceDescriptor=new NamespaceDescriptorImpl(owner.getOriginal(),Collections.<Annotation>emptyList(),name);
          namespaceDescriptor.initialize(new WritableScopeImpl(JetScope.EMPTY,namespaceDescriptor,trace.getErrorHandler()));
          owner.addNamespace(namespaceDescriptor);
          trace.recordDeclarationResolution(namespace,namespaceDescriptor);
        }
        namespaceDescriptors.put(namespace,namespaceDescriptor);
        WriteThroughScope namespaceScope=new WriteThroughScope(outerScope,namespaceDescriptor.getMemberScope(),trace.getErrorHandler());
        namespaceScopes.put(namespace,namespaceScope);
        processImports(namespace,namespaceScope,outerScope);
        collectNamespacesAndClassifiers(namespaceScope,namespaceDescriptor,namespace.getDeclarations());
      }
      @Override public void visitClass(      JetClass klass){
        visitClassOrObject(klass,(Map)classes,owner,outerScope,new MutableClassDescriptor(trace,owner,outerScope));
      }
      @Override public void visitObjectDeclaration(      JetObjectDeclaration declaration){
        createClassDescriptorForObject(declaration);
      }
      private MutableClassDescriptor createClassDescriptorForObject(      @NotNull JetObjectDeclaration declaration){
        MutableClassDescriptor mutableClassDescriptor=new MutableClassDescriptor(trace,owner,outerScope){
          @Override public ClassObjectStatus setClassObjectDescriptor(          @NotNull MutableClassDescriptor classObjectDescriptor){
            return ClassObjectStatus.NOT_ALLOWED;
          }
        }
;
        visitClassOrObject(declaration,(Map)objects,owner,outerScope,mutableClassDescriptor);
        ConstructorDescriptorImpl constructorDescriptor=new ConstructorDescriptorImpl(mutableClassDescriptor,Collections.<Annotation>emptyList(),true);
        constructorDescriptor.initialize(Collections.<ValueParameterDescriptor>emptyList());
        mutableClassDescriptor.setPrimaryConstructor(constructorDescriptor);
        trace.recordDeclarationResolution(declaration,mutableClassDescriptor);
        return mutableClassDescriptor;
      }
      private void visitClassOrObject(      @NotNull JetClassOrObject declaration,      Map<JetClassOrObject,MutableClassDescriptor> map,      NamespaceLike owner,      JetScope outerScope,      MutableClassDescriptor mutableClassDescriptor){
        mutableClassDescriptor.setName(JetPsiUtil.safeName(declaration.getName()));
        if (declaration instanceof JetClass) {
          owner.addClassifierDescriptor(mutableClassDescriptor);
        }
        map.put(declaration,mutableClassDescriptor);
        declaringScopes.put((JetDeclaration)declaration,outerScope);
        JetScope classScope=mutableClassDescriptor.getScopeForMemberResolution();
        collectNamespacesAndClassifiers(classScope,mutableClassDescriptor,declaration.getDeclarations());
      }
      @Override public void visitTypedef(      JetTypedef typedef){
        trace.getErrorHandler().genericError(typedef.getNode(),"Unsupported [TopDownAnalyzer]");
      }
      @Override public void visitExtension(      JetExtension extension){
        trace.getErrorHandler().genericError(extension.getNode(),"Unsupported [TopDownAnalyzer]");
      }
      @Override public void visitClassObject(      JetClassObject classObject){
        JetObjectDeclaration objectDeclaration=classObject.getObjectDeclaration();
        if (objectDeclaration != null) {
          NamespaceLike.ClassObjectStatus status=owner.setClassObjectDescriptor(createClassDescriptorForObject(objectDeclaration));
switch (status) {
case DUPLICATE:
            trace.getErrorHandler().genericError(classObject.getNode(),"Only one class object is allowed per class");
          break;
case NOT_ALLOWED:
        trace.getErrorHandler().genericError(classObject.getNode(),"A class object is not allowed here");
      break;
  }
}
}
}
);
}
}
