{
  if (node == null) {
    return;
  }
  int flags=node.astModifiers().getEffectiveModifierFlags();
  if ((flags & Modifier.ABSTRACT) != 0) {
    return;
  }
  if ((flags & Modifier.PUBLIC) == 0) {
    String message=String.format("This fragment class should be public (%1$s)",cls.getName());
    context.report(ISSUE,node,context.getLocation(node.astName()),message);
    return;
  }
  if (cls.getContainingClass() != null && (flags & Modifier.STATIC) == 0) {
    String message=String.format("This fragment inner class should be static (%1$s)",cls.getName());
    context.report(ISSUE,node,context.getLocation(node.astName()),message);
    return;
  }
  boolean hasDefaultConstructor=false;
  boolean hasConstructor=false;
  NormalTypeBody body=node.astBody();
  if (body != null) {
    for (    TypeMember member : body.astMembers()) {
      if (member instanceof ConstructorDeclaration) {
        hasConstructor=true;
        ConstructorDeclaration constructor=(ConstructorDeclaration)member;
        if (constructor.astParameters().isEmpty()) {
          if (constructor.astModifiers().isPublic()) {
            hasDefaultConstructor=true;
          }
 else {
            Location location=context.getLocation(constructor.astTypeName());
            context.report(ISSUE,constructor,location,"The default constructor must be public");
            hasDefaultConstructor=true;
          }
        }
 else {
          Location location=context.getLocation(constructor.astTypeName());
          String message="Avoid non-default constructors in fragments: " + "use a default constructor plus " + "`Fragment#setArguments(Bundle)` instead";
          context.report(ISSUE,constructor,location,message);
        }
      }
    }
  }
  if (!hasDefaultConstructor && hasConstructor) {
    String message=String.format("This fragment should provide a default constructor (a public " + "constructor with no arguments) (`%1$s`)",cls.getName());
    context.report(ISSUE,node,context.getLocation(node.astName()),message);
  }
}
