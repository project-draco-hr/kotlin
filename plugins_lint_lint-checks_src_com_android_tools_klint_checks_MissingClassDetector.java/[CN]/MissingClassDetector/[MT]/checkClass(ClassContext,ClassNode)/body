{
  if (!mHaveClasses && !context.isFromClassLibrary() && context.getProject() == context.getMainProject()) {
    mHaveClasses=true;
  }
  String curr=classNode.name;
  if (mReferencedClasses != null && mReferencedClasses.containsKey(curr)) {
    boolean isCustomView=mCustomViews.contains(curr);
    removeReferences(curr);
    if ((classNode.access & Opcodes.ACC_PUBLIC) == 0) {
      context.report(INSTANTIATABLE,context.getLocation(classNode),String.format("This class should be public (%1$s)",ClassContext.createSignature(classNode.name,null,null)));
      return;
    }
    if (classNode.name.indexOf('$') != -1 && !LintUtils.isStaticInnerClass(classNode)) {
      context.report(INSTANTIATABLE,context.getLocation(classNode),String.format("This inner class should be static (%1$s)",ClassContext.createSignature(classNode.name,null,null)));
      return;
    }
    boolean hasDefaultConstructor=false;
    @SuppressWarnings("rawtypes") List methodList=classNode.methods;
    for (    Object m : methodList) {
      MethodNode method=(MethodNode)m;
      if (method.name.equals(CONSTRUCTOR_NAME)) {
        if (method.desc.equals("()V")) {
          if ((method.access & Opcodes.ACC_PUBLIC) != 0) {
            hasDefaultConstructor=true;
          }
 else {
            context.report(INSTANTIATABLE,context.getLocation(method,classNode),"The default constructor must be public");
            hasDefaultConstructor=true;
          }
        }
      }
    }
    if (!hasDefaultConstructor && !isCustomView && !context.isFromClassLibrary()&& context.getProject().getReportIssues()) {
      context.report(INSTANTIATABLE,context.getLocation(classNode),String.format("This class should provide a default constructor (a public " + "constructor with no arguments) (%1$s)",ClassContext.createSignature(classNode.name,null,null)));
    }
  }
}
