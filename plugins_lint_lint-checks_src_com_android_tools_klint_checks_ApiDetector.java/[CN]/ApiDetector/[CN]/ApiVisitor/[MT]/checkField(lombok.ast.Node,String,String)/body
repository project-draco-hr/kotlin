{
  int api=mApiDatabase.getFieldVersion(owner,name);
  if (api != -1) {
    int minSdk=getMinSdk(mContext);
    if (api > minSdk && api > getLocalMinSdk(node)) {
      if (isBenignConstantUsage(node,name,owner)) {
        return true;
      }
      Location location=mContext.getLocation(node);
      String fqcn=getFqcn(owner) + '#' + name;
      if (node instanceof ImportDeclaration) {
        ImportDeclaration d=(ImportDeclaration)node;
        int startOffset=d.astParts().first().getPosition().getStart();
        Position start=location.getStart();
        int startColumn=start.getColumn();
        int startLine=start.getLine();
        start=new DefaultPosition(startLine,startColumn + startOffset - start.getOffset(),startOffset);
        int fqcnLength=fqcn.length();
        Position end=new DefaultPosition(startLine,start.getColumn() + fqcnLength,start.getOffset() + fqcnLength);
        location=Location.create(location.getFile(),start,end);
      }
      String message=String.format("Field requires API level %1$d (current min is %2$d): `%3$s`",api,minSdk,fqcn);
      LintDriver driver=mContext.getDriver();
      if (driver.isSuppressed(mContext,INLINED,node)) {
        return true;
      }
      if (driver.isSuppressed(mContext,UNSUPPORTED,node)) {
        return true;
      }
      if (mPendingFields == null) {
        mPendingFields=Maps.newHashMapWithExpectedSize(20);
      }
      List<Pair<String,Location>> list=mPendingFields.get(fqcn);
      if (list == null) {
        list=new ArrayList<Pair<String,Location>>();
        mPendingFields.put(fqcn,list);
      }
 else {
        for (        Pair<String,Location> pair : list) {
          Location existingLocation=pair.getSecond();
          if (location.getFile().equals(existingLocation.getFile())) {
            Position start=location.getStart();
            Position existingStart=existingLocation.getStart();
            if (start != null && existingStart != null && start.getLine() == existingStart.getLine()) {
              return true;
            }
          }
        }
      }
      list.add(Pair.of(message,location));
    }
    return true;
  }
  return false;
}
