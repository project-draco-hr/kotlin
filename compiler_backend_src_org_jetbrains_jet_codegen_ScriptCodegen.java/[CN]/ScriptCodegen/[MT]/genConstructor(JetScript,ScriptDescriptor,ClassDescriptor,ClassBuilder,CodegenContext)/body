{
  Type blockType=jetTypeMapper.mapType(scriptDescriptor.getReturnType(),MapTypeMode.VALUE);
  classBuilder.newField(null,Opcodes.ACC_PUBLIC,LAST_EXPRESSION_VALUE_FIELD_NAME,blockType.getDescriptor(),null,null);
  JvmMethodSignature jvmSignature=jetTypeMapper.mapScriptSignature(scriptDescriptor);
  state.setScriptConstructorMethod(jvmSignature.getAsmMethod());
  MethodVisitor mv=classBuilder.newMethod(scriptDeclaration,Opcodes.ACC_PUBLIC,jvmSignature.getAsmMethod().getName(),jvmSignature.getAsmMethod().getDescriptor(),null,null);
  mv.visitCode();
  InstructionAdapter instructionAdapter=new InstructionAdapter(mv);
  JvmClassName className=closureAnnotator.classNameForClassDescriptor(classDescriptorForScript);
  instructionAdapter.load(0,className.getAsmType());
  instructionAdapter.invokespecial(JdkNames.JL_OBJECT.getInternalName(),"<init>","()V");
  instructionAdapter.load(0,className.getAsmType());
  FrameMap frameMap=context.prepareFrame(jetTypeMapper);
  Type[] argTypes=jvmSignature.getAsmMethod().getArgumentTypes();
  int add=0;
  for (int i=0; i < scriptDescriptor.getValueParameters().size(); i++) {
    ValueParameterDescriptor parameter=scriptDescriptor.getValueParameters().get(i);
    frameMap.enter(parameter,argTypes[i + add].getSize());
  }
  ImplementationBodyCodegen.generateInitializers(new ExpressionCodegen(instructionAdapter,frameMap,Type.VOID_TYPE,context,state),instructionAdapter,scriptDeclaration.getDeclarations(),bindingContext,jetTypeMapper);
  StackValue stackValue=new ExpressionCodegen(mv,frameMap,Type.VOID_TYPE,context,state).gen(scriptDeclaration.getBlockExpression());
  if (stackValue.type != Type.VOID_TYPE) {
    stackValue.put(stackValue.type,instructionAdapter);
    instructionAdapter.putfield(className.getInternalName(),LAST_EXPRESSION_VALUE_FIELD_NAME,blockType.getDescriptor());
  }
  instructionAdapter.areturn(Type.VOID_TYPE);
  mv.visitMaxs(-1,-1);
  mv.visitEnd();
}
