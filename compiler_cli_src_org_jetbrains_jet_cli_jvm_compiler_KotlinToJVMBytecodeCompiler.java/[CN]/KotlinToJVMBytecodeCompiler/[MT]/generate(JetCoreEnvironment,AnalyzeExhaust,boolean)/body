{
  Project project=environment.getProject();
  final CompilerConfiguration configuration=environment.getConfiguration();
  Progress backendProgress=new Progress(){
    @Override public void reportOutput(    @NotNull Collection<File> sourceFiles,    @Nullable File outputFile){
      if (outputFile == null)       return;
      MessageCollector messageCollector=configuration.get(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY);
      if (messageCollector == null)       return;
      messageCollector.report(CompilerMessageSeverity.OUTPUT,OutputMessageUtil.formatOutputMessage(sourceFiles,outputFile),CompilerMessageLocation.NO_LOCATION);
    }
  }
;
  GenerationState generationState=new GenerationState(project,ClassBuilderFactories.binaries(stubs),backendProgress,exhaust.getBindingContext(),environment.getSourceFiles(),configuration.get(JVMConfigurationKeys.BUILTIN_TO_JAVA_TYPES_MAPPING_KEY,BuiltinToJavaTypesMapping.ENABLED),configuration.get(JVMConfigurationKeys.GENERATE_NOT_NULL_ASSERTIONS,false),configuration.get(JVMConfigurationKeys.GENERATE_NOT_NULL_PARAMETER_ASSERTIONS,false),true);
  KotlinCodegenFacade.compileCorrectFiles(generationState,CompilationErrorHandler.THROW_EXCEPTION);
  CompilerPluginContext context=new CompilerPluginContext(project,exhaust.getBindingContext(),environment.getSourceFiles());
  for (  CompilerPlugin plugin : configuration.getList(CLIConfigurationKeys.COMPILER_PLUGINS)) {
    plugin.processFiles(context);
  }
  return generationState;
}
