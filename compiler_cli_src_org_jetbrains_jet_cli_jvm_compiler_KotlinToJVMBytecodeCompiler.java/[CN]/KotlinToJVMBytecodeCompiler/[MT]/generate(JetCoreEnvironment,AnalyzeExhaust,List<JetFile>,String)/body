{
  CompilerConfiguration configuration=environment.getConfiguration();
  File incrementalCacheDir=configuration.get(JVMConfigurationKeys.INCREMENTAL_CACHE_BASE_DIR);
  IncrementalCacheProvider incrementalCacheProvider=IncrementalCacheProvider.object$.getInstance();
  Collection<FqName> packagesWithRemovedFiles=incrementalCacheDir == null || moduleId == null || incrementalCacheProvider == null ? null : IncrementalPackage.getPackagesWithRemovedFiles(incrementalCacheProvider.getIncrementalCache(incrementalCacheDir),moduleId,environment.getSourceFiles());
  BindingTraceContext diagnosticHolder=new BindingTraceContext();
  GenerationState generationState=new GenerationState(environment.getProject(),ClassBuilderFactories.BINARIES,Progress.DEAF,exhaust.getModuleDescriptor(),exhaust.getBindingContext(),sourceFiles,configuration.get(JVMConfigurationKeys.GENERATE_NOT_NULL_ASSERTIONS,false),configuration.get(JVMConfigurationKeys.GENERATE_NOT_NULL_PARAMETER_ASSERTIONS,false),GenerationState.GenerateClassFilter.GENERATE_ALL,configuration.get(JVMConfigurationKeys.ENABLE_INLINE,InlineCodegenUtil.DEFAULT_INLINE_FLAG),packagesWithRemovedFiles,moduleId,diagnosticHolder);
  KotlinCodegenFacade.compileCorrectFiles(generationState,CompilationErrorHandler.THROW_EXCEPTION);
  AnalyzerWithCompilerReport.reportDiagnostics(new FilteredJvmDiagnostics(diagnosticHolder.getBindingContext().getDiagnostics(),exhaust.getBindingContext().getDiagnostics()),environment.getConfiguration().get(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY));
  return generationState;
}
