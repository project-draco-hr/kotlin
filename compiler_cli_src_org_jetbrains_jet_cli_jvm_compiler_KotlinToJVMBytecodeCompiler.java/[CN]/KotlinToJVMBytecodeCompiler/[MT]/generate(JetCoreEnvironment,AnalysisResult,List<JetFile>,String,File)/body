{
  CompilerConfiguration configuration=environment.getConfiguration();
  IncrementalCacheProvider incrementalCacheProvider=configuration.get(JVMConfigurationKeys.INCREMENTAL_CACHE_PROVIDER);
  Collection<FqName> packagesWithRemovedFiles;
  if (moduleId == null || incrementalCacheProvider == null) {
    packagesWithRemovedFiles=null;
  }
 else {
    IncrementalCache incrementalCache=incrementalCacheProvider.getIncrementalCache(moduleId);
    packagesWithRemovedFiles=IncrementalPackage.getPackagesWithRemovedFiles(incrementalCache,environment.getSourceFiles());
  }
  BindingTraceContext diagnosticHolder=new BindingTraceContext();
  GenerationState generationState=new GenerationState(environment.getProject(),ClassBuilderFactories.BINARIES,Progress.DEAF,result.getModuleDescriptor(),result.getBindingContext(),sourceFiles,configuration.get(JVMConfigurationKeys.DISABLE_CALL_ASSERTIONS,false),configuration.get(JVMConfigurationKeys.DISABLE_PARAM_ASSERTIONS,false),GenerationState.GenerateClassFilter.GENERATE_ALL,configuration.get(JVMConfigurationKeys.DISABLE_INLINE,false),configuration.get(JVMConfigurationKeys.DISABLE_OPTIMIZATION,false),packagesWithRemovedFiles,moduleId,diagnosticHolder,outputDirectory);
  KotlinCodegenFacade.compileCorrectFiles(generationState,CompilationErrorHandler.THROW_EXCEPTION);
  AnalyzerWithCompilerReport.reportDiagnostics(new FilteredJvmDiagnostics(diagnosticHolder.getBindingContext().getDiagnostics(),result.getBindingContext().getDiagnostics()),environment.getConfiguration().get(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY));
  return generationState;
}
