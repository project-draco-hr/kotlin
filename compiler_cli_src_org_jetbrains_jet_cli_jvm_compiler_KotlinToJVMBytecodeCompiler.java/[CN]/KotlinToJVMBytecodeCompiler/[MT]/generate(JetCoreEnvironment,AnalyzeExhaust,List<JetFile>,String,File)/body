{
  CompilerConfiguration configuration=environment.getConfiguration();
  File incrementalCacheDir=configuration.get(JVMConfigurationKeys.INCREMENTAL_CACHE_BASE_DIR);
  IncrementalCacheProvider incrementalCacheProvider=IncrementalCacheProvider.OBJECT$.getInstance();
  Collection<FqName> packagesWithRemovedFiles;
  if (incrementalCacheDir == null || moduleId == null || incrementalCacheProvider == null) {
    packagesWithRemovedFiles=null;
  }
 else {
    IncrementalCache incrementalCache=incrementalCacheProvider.getIncrementalCache(incrementalCacheDir);
    try {
      packagesWithRemovedFiles=IncrementalPackage.getPackagesWithRemovedFiles(incrementalCache,moduleId,environment.getSourceFiles());
    }
  finally {
      incrementalCache.close();
    }
  }
  BindingTraceContext diagnosticHolder=new BindingTraceContext();
  GenerationState generationState=new GenerationState(environment.getProject(),ClassBuilderFactories.BINARIES,Progress.DEAF,exhaust.getModuleDescriptor(),exhaust.getBindingContext(),sourceFiles,configuration.get(JVMConfigurationKeys.GENERATE_NOT_NULL_ASSERTIONS,false),configuration.get(JVMConfigurationKeys.GENERATE_NOT_NULL_PARAMETER_ASSERTIONS,false),GenerationState.GenerateClassFilter.GENERATE_ALL,configuration.get(JVMConfigurationKeys.ENABLE_INLINE,InlineCodegenUtil.DEFAULT_INLINE_FLAG),configuration.get(JVMConfigurationKeys.ENABLE_OPTIMIZATION,OptimizationUtils.DEFAULT_OPTIMIZATION_FLAG),packagesWithRemovedFiles,moduleId,diagnosticHolder,outputDirectory);
  KotlinCodegenFacade.compileCorrectFiles(generationState,CompilationErrorHandler.THROW_EXCEPTION);
  AnalyzerWithCompilerReport.reportDiagnostics(new FilteredJvmDiagnostics(diagnosticHolder.getBindingContext().getDiagnostics(),exhaust.getBindingContext().getDiagnostics()),environment.getConfiguration().get(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY));
  return generationState;
}
