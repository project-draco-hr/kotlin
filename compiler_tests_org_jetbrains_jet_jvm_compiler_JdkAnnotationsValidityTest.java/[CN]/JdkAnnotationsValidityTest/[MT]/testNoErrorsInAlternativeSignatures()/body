{
  List<FqName> affectedClasses=getAffectedClasses("file://jdk-annotations");
  Map<String,List<String>> errors=Maps.newLinkedHashMap();
  for (int chunkIndex=0; chunkIndex < affectedClasses.size() / CLASSES_IN_CHUNK + 1; chunkIndex++) {
    Disposable parentDisposable=Disposer.newDisposable();
    try {
      JetCoreEnvironment commonEnvironment=createEnvironment(parentDisposable);
      BindingTrace trace=new BindingTraceContext();
      InjectorForJavaDescriptorResolver injector=new InjectorForJavaDescriptorResolver(commonEnvironment.getProject(),trace);
      BindingContext bindingContext=trace.getBindingContext();
      JavaDescriptorResolver javaDescriptorResolver=injector.getJavaDescriptorResolver();
      AlternativeSignatureErrorFindingVisitor visitor=new AlternativeSignatureErrorFindingVisitor(bindingContext,errors);
      int chunkStart=chunkIndex * CLASSES_IN_CHUNK;
      for (      FqName javaClass : affectedClasses.subList(chunkStart,Math.min(chunkStart + CLASSES_IN_CHUNK,affectedClasses.size()))) {
        ClassDescriptor topLevelClass=javaDescriptorResolver.resolveClass(javaClass,IGNORE_KOTLIN_SOURCES);
        NamespaceDescriptor topLevelNamespace=javaDescriptorResolver.resolveNamespace(javaClass,IGNORE_KOTLIN_SOURCES);
        if (topLevelClass == null) {
          continue;
        }
        topLevelClass.acceptVoid(visitor);
        if (topLevelNamespace != null) {
          topLevelNamespace.acceptVoid(visitor);
        }
      }
    }
  finally {
      Disposer.dispose(parentDisposable);
    }
  }
  if (!errors.isEmpty()) {
    StringBuilder sb=new StringBuilder("Error(s) in JDK alternative signatures: \n");
    for (    Map.Entry<String,List<String>> entry : errors.entrySet()) {
      sb.append(entry.getKey()).append(" : ").append(entry.getValue()).append("\n");
    }
    fail(sb.toString());
  }
}
