{
  JetExpression callee=expression.getCalleeExpression();
  if (callee instanceof JetSimpleNameExpression) {
    DeclarationDescriptor funDescriptor=bindingContext.resolveReferenceExpression((JetSimpleNameExpression)callee);
    if (funDescriptor instanceof ConstructorDescriptor) {
      generateConstructorCall(expression,(JetSimpleNameExpression)callee);
    }
 else     if (funDescriptor instanceof FunctionDescriptor) {
      final DeclarationDescriptor functionParent=funDescriptor.getContainingDeclaration();
      if (isNumberPrimitive(functionParent)) {
        if (funDescriptor.getName().equals("inv")) {
          final StackValue value=myStack.pop();
          final Type asmType=expressionType(expression);
          value.put(asmType,v);
          generateInv(asmType);
          return;
        }
      }
      PsiElement declarationPsiElement=bindingContext.getDeclarationPsiElement(funDescriptor);
      final FunctionDescriptor fd=(FunctionDescriptor)funDescriptor;
      if (declarationPsiElement == null && isClass(functionParent,"String")) {
        final Project project=expression.getProject();
        PsiClass jlString=JavaPsiFacade.getInstance(project).findClass("java.lang.String",ProjectScope.getAllScope(project));
        final PsiMethod[] methods=jlString.findMethodsByName(funDescriptor.getName(),false);
        final int arity=fd.getUnsubstitutedValueParameters().size();
        for (        PsiMethod method : methods) {
          if (method.getParameterList().getParametersCount() == arity) {
            declarationPsiElement=method;
          }
        }
      }
      if (declarationPsiElement == null) {
        throw new UnsupportedOperationException("couldn't find declaration for " + funDescriptor);
      }
      Method methodDescriptor;
      if (declarationPsiElement instanceof PsiMethod) {
        PsiMethod psiMethod=(PsiMethod)declarationPsiElement;
        String owner=JetTypeMapper.jvmName(psiMethod.getContainingClass());
        methodDescriptor=getMethodDescriptor(psiMethod);
        final boolean isStatic=psiMethod.hasModifierProperty(PsiModifier.STATIC);
        if (!isStatic) {
          ensureReceiverOnStack(expression,null);
          if (expression.getParent() instanceof JetQualifiedExpression) {
            final JetExpression receiver=((JetQualifiedExpression)expression.getParent()).getReceiverExpression();
            JetType expressionType=bindingContext.getExpressionType(receiver);
            DeclarationDescriptor declarationDescriptor=expressionType.getConstructor().getDeclarationDescriptor();
            PsiElement ownerDeclaration=bindingContext.getDeclarationPsiElement(declarationDescriptor);
            if (ownerDeclaration instanceof PsiClass) {
              owner=typeMapper.mapType(expressionType).getInternalName();
            }
          }
        }
        pushMethodArguments(expression,methodDescriptor);
        v.visitMethodInsn(isStatic ? Opcodes.INVOKESTATIC : Opcodes.INVOKEVIRTUAL,owner,methodDescriptor.getName(),methodDescriptor.getDescriptor());
      }
 else       if (declarationPsiElement instanceof JetFunction) {
        final JetFunction jetFunction=(JetFunction)declarationPsiElement;
        methodDescriptor=typeMapper.mapSignature(jetFunction);
        if (functionParent instanceof NamespaceDescriptorImpl) {
          if (jetFunction.getReceiverTypeRef() != null) {
            ensureReceiverOnStack(expression,null);
          }
          pushMethodArguments(expression,methodDescriptor);
          final String owner=NamespaceCodegen.getJVMClassName(DescriptorRenderer.getFQName(functionParent));
          v.invokestatic(owner,methodDescriptor.getName(),methodDescriptor.getDescriptor());
        }
 else         if (functionParent instanceof ClassDescriptor) {
          ensureReceiverOnStack(expression,(ClassDescriptor)functionParent);
          pushMethodArguments(expression,methodDescriptor);
          final String owner=JetTypeMapper.jvmNameForInterface((ClassDescriptor)functionParent);
          v.invokeinterface(owner,methodDescriptor.getName(),methodDescriptor.getDescriptor());
        }
 else {
          throw new UnsupportedOperationException("don't know how to generate call to " + declarationPsiElement);
        }
      }
 else {
        gen(callee,Type.getObjectType(ClosureCodegen.getInternalClassName(fd)));
        boolean isExtensionFunction=fd.getReceiverType() != null;
        int paramCount=fd.getUnsubstitutedValueParameters().size();
        if (isExtensionFunction) {
          ensureReceiverOnStack(expression,null);
          paramCount++;
        }
        methodDescriptor=ClosureCodegen.erasedInvokeSignature(fd);
        pushMethodArguments(expression,methodDescriptor);
        v.invokevirtual(ClosureCodegen.getInternalClassName(fd),"invoke",methodDescriptor.getDescriptor());
      }
      if (methodDescriptor.getReturnType() != Type.VOID_TYPE) {
        final Type retType=typeMapper.mapType(fd.getUnsubstitutedReturnType());
        StackValue.onStack(methodDescriptor.getReturnType()).put(retType,v);
        myStack.push(StackValue.onStack(retType));
      }
    }
 else {
      throw new CompilationException();
    }
  }
 else {
    throw new UnsupportedOperationException("Don't know how to generate a call");
  }
}
