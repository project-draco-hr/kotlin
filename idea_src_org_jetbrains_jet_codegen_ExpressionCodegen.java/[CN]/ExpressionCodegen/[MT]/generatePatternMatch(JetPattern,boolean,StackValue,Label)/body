{
  if (pattern instanceof JetTypePattern) {
    JetTypeReference typeReference=((JetTypePattern)pattern).getTypeReference();
    JetType jetType=bindingContext.resolveTypeReference(typeReference);
    expressionToMatch.dupReceiver(v,0);
    generateInstanceOf(expressionToMatch,jetType,false);
    StackValue value=StackValue.onStack(Type.BOOLEAN_TYPE);
    return negated ? StackValue.not(value) : value;
  }
 else   if (pattern instanceof JetTuplePattern) {
    return generateTuplePatternMatch((JetTuplePattern)pattern,negated,expressionToMatch,nextEntry);
  }
 else   if (pattern instanceof JetExpressionPattern) {
    final Type subjectType=expressionToMatch.type;
    expressionToMatch.dupReceiver(v,0);
    expressionToMatch.put(subjectType,v);
    JetExpression condExpression=((JetExpressionPattern)pattern).getExpression();
    Type condType=isNumberPrimitive(subjectType) ? expressionType(condExpression) : OBJECT_TYPE;
    gen(condExpression,condType);
    generateEqualsForExpressionsOnStack(JetTokens.EQEQ,subjectType,condType);
    return myStack.pop();
  }
 else   if (pattern instanceof JetWildcardPattern) {
    return StackValue.constant(!negated,Type.BOOLEAN_TYPE);
  }
 else   if (pattern instanceof JetBindingPattern) {
    final JetProperty var=((JetBindingPattern)pattern).getVariableDeclaration();
    final VariableDescriptor variableDescriptor=bindingContext.getVariableDescriptor(var);
    final Type varType=typeMapper.mapType(variableDescriptor.getOutType());
    myMap.enter(variableDescriptor,varType.getSize());
    expressionToMatch.dupReceiver(v,0);
    expressionToMatch.put(varType,v);
    final int varIndex=myMap.getIndex(variableDescriptor);
    v.store(varIndex,varType);
    return generateWhenCondition(varType,varIndex,((JetBindingPattern)pattern).getCondition(),null);
  }
 else {
    throw new UnsupportedOperationException("Unsupported pattern type: " + pattern);
  }
}
