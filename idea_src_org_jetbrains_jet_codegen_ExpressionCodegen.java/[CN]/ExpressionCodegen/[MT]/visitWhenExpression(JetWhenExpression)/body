{
  JetExpression expr=expression.getSubjectExpression();
  final Type subjectType=expressionType(expr);
  final int subjectLocal=myMap.enterTemp(subjectType.getSize());
  gen(expr,subjectType);
  v.store(subjectLocal,subjectType);
  Label end=new Label();
  Label nextEntry=null;
  boolean hasElse=false;
  for (  JetWhenEntry whenEntry : expression.getEntries()) {
    if (nextEntry != null) {
      v.mark(nextEntry);
    }
    nextEntry=new Label();
    FrameMap.Mark mark=myMap.mark();
    if (!whenEntry.isElse()) {
      final JetWhenCondition[] conditions=whenEntry.getConditions();
      if (conditions.length != 1) {
        throw new UnsupportedOperationException("TODO support multiple conditions in when entry");
      }
      StackValue conditionValue=generateWhenCondition(subjectType,subjectLocal,conditions[0],nextEntry);
      conditionValue.condJump(nextEntry,true,v);
    }
 else {
      hasElse=true;
    }
    genToJVMStack(whenEntry.getExpression());
    mark.dropTo();
    v.goTo(end);
  }
  if (!hasElse && nextEntry != null) {
    v.mark(nextEntry);
    throwNewException(CLASS_NO_PATTERN_MATCHED_EXCEPTION);
  }
  v.mark(end);
  final Type type=expressionType(expression);
  if (type.getSort() != Type.VOID) {
    myStack.push(StackValue.onStack(type));
  }
  myMap.leaveTemp(subjectType.getSize());
}
