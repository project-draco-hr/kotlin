{
  JetExpression expr=expression.getSubjectExpression();
  final Type subjectType=expressionType(expr);
  final int subjectLocal=myMap.enterTemp(subjectType.getSize());
  gen(expr,subjectType);
  v.store(subjectLocal,subjectType);
  Label end=new Label();
  Label nextCondition=null;
  boolean hasElse=false;
  for (  JetWhenEntry whenEntry : expression.getEntries()) {
    if (nextCondition != null) {
      v.mark(nextCondition);
    }
    nextCondition=new Label();
    FrameMap.Mark mark=myMap.mark();
    Label thisEntry=new Label();
    if (!whenEntry.isElse()) {
      final JetWhenCondition[] conditions=whenEntry.getConditions();
      for (int i=0; i < conditions.length; i++) {
        StackValue conditionValue=generateWhenCondition(subjectType,subjectLocal,conditions[i],nextCondition);
        conditionValue.condJump(nextCondition,true,v);
        if (i < conditions.length - 1) {
          v.goTo(thisEntry);
          v.mark(nextCondition);
          nextCondition=new Label();
        }
      }
    }
 else {
      hasElse=true;
    }
    v.visitLabel(thisEntry);
    genToJVMStack(whenEntry.getExpression());
    mark.dropTo();
    v.goTo(end);
  }
  if (!hasElse && nextCondition != null) {
    v.mark(nextCondition);
    throwNewException(CLASS_NO_PATTERN_MATCHED_EXCEPTION);
  }
  v.mark(end);
  final Type type=expressionType(expression);
  if (type.getSort() != Type.VOID) {
    myStack.push(StackValue.onStack(type));
  }
  myMap.leaveTemp(subjectType.getSize());
}
