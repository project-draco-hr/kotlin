{
  JetTypeReference typeReference=expression.getTypeReference();
  final JetUserType constructorType=(JetUserType)typeReference.getTypeElement();
  final JetSimpleNameExpression constructorReference=constructorType.getReferenceExpression();
  DeclarationDescriptor constructorDescriptor=bindingContext.resolveReferenceExpression(constructorReference);
  final PsiElement declaration=bindingContext.getDeclarationPsiElement(constructorDescriptor);
  Type type;
  if (declaration instanceof PsiMethod) {
    type=generateJavaConstructorCall(expression,(PsiMethod)declaration);
  }
 else   if (constructorDescriptor instanceof ConstructorDescriptor) {
    type=typeMapper.mapType(bindingContext.resolveTypeReference(typeReference),OwnerKind.IMPLEMENTATION);
    if (type.getSort() == Type.ARRAY) {
      generateNewArray(expression,type);
    }
 else {
      v.anew(type);
      v.dup();
      Method method=typeMapper.mapConstructorSignature((ConstructorDescriptor)constructorDescriptor,OwnerKind.IMPLEMENTATION);
      pushMethodArguments(expression,method);
      for (      JetTypeReference typeArgumentReference : constructorType.getTypeArgumentsAsTypes()) {
        JetType typeArgument=bindingContext.resolveTypeReference(typeArgumentReference);
        ClassCodegen.newTypeInfo(v,typeMapper.mapType(TypeUtils.makeNullable(typeArgument)));
      }
      ClassDescriptor classDecl=(ClassDescriptor)constructorDescriptor.getContainingDeclaration();
      v.invokespecial(JetTypeMapper.jvmNameForImplementation(classDecl),"<init>",method.getDescriptor());
    }
  }
 else {
    throw new UnsupportedOperationException("don't know how to generate this new expression");
  }
  myStack.push(StackValue.onStack(type));
}
