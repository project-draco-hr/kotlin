{
  final IElementType opToken=expression.getOperationReference().getReferencedNameElementType();
  if (opToken == JetTokens.EQ) {
    generateAssignmentExpression(expression);
  }
 else   if (JetTokens.AUGMENTED_ASSIGNMENTS.contains(opToken)) {
    generateAugmentedAssignment(expression);
  }
 else   if (opToken == JetTokens.ANDAND) {
    generateBooleanAnd(expression);
  }
 else   if (opToken == JetTokens.OROR) {
    generateBooleanOr(expression);
  }
 else   if (opToken == JetTokens.EQEQ || opToken == JetTokens.EXCLEQ || opToken == JetTokens.EQEQEQ || opToken == JetTokens.EXCLEQEQEQ) {
    generateEquals(expression.getLeft(),expression.getRight(),opToken);
  }
 else   if (opToken == JetTokens.LT || opToken == JetTokens.LTEQ || opToken == JetTokens.GT || opToken == JetTokens.GTEQ) {
    generateCompareOp(expression.getLeft(),expression.getRight(),opToken,expressionType(expression.getLeft()));
  }
 else   if (opToken == JetTokens.ELVIS) {
    generateElvis(expression);
  }
 else   if (opToken == JetTokens.RANGE) {
    generateRange(expression);
  }
 else {
    DeclarationDescriptor op=bindingContext.resolveReferenceExpression(expression.getOperationReference());
    if (op instanceof FunctionDescriptor) {
      final IntrinsicMethod intrinsic=intrinsics.getIntrinsic(op);
      if (intrinsic != null) {
        myStack.push(intrinsic.generate(this,v,expressionType(expression),expression,Arrays.asList(expression.getLeft(),expression.getRight()),false));
        return;
      }
    }
    throw new UnsupportedOperationException("Don't know how to generate binary op " + expression);
  }
}
