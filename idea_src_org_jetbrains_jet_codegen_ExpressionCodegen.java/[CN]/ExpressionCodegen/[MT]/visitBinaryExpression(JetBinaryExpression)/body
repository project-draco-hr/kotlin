{
  final IElementType opToken=expression.getOperationReference().getReferencedNameElementType();
  if (opToken == JetTokens.EQ) {
    generateAssignmentExpression(expression);
    return;
  }
  DeclarationDescriptor op=bindingContext.resolveReferenceExpression(expression.getOperationReference());
  if (op instanceof FunctionDescriptor) {
    DeclarationDescriptor cls=op.getContainingDeclaration();
    if (cls instanceof ClassDescriptor) {
      final String className=cls.getName();
      if (className.equals("Int")) {
        if (op.getName().equals("compareTo")) {
          generateCompareOp(expression,opToken);
        }
 else {
          int opcode=opcodeForMethod(op.getName());
          generateBinaryOp(expression,(FunctionDescriptor)op,opcode);
        }
        return;
      }
 else       if (className.equals("Hashable")) {
        if (op.getName().equals("equals")) {
          final Type leftType=typeMapper.mapType(bindingContext.getExpressionType(expression.getLeft()));
          final Type rightType=typeMapper.mapType(bindingContext.getExpressionType(expression.getRight()));
          if (leftType == Type.INT_TYPE && rightType == Type.INT_TYPE) {
            gen(expression.getLeft(),Type.INT_TYPE);
            gen(expression.getRight(),Type.INT_TYPE);
            myStack.push(StackValue.icmp(JetTokens.EQEQ));
            return;
          }
 else {
            throw new UnsupportedOperationException("Don't know how to generate equality for these types");
          }
        }
      }
 else {
        throw new UnsupportedOperationException("Don't know how to generate binary op for class " + className);
      }
    }
  }
  throw new UnsupportedOperationException("Don't know how to generate binary op " + expression);
}
