{
  if (context.checkArguments == CheckArgumentTypesMode.CHECK_VALUE_ARGUMENTS) {
    argumentTypeResolver.analyzeArgumentsAndRecordTypes(context);
  }
  List<KtTypeProjection> typeArguments=context.call.getTypeArguments();
  for (  KtTypeProjection projection : typeArguments) {
    if (projection.getProjectionKind() != KtProjectionKind.NONE) {
      context.trace.report(PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT.on(projection));
      ModifierCheckerCore.INSTANCE.check(projection,context.trace,null);
    }
    KotlinType type=argumentTypeResolver.resolveTypeRefWithDefault(projection.getTypeReference(),context.scope,context.trace,null);
    if (type != null) {
      ForceResolveUtil.forceResolveAllContents(type);
    }
  }
  Collection<ResolvedCall<F>> allCandidates=Lists.newArrayList();
  OverloadResolutionResultsImpl<F> successfulResults=null;
  TemporaryBindingTrace traceForFirstNonemptyCandidateSet=null;
  OverloadResolutionResultsImpl<F> resultsForFirstNonemptyCandidateSet=null;
  for (  ResolutionTask<D,F> task : prioritizedTasks) {
    if (task.getCandidates().isEmpty())     continue;
    TemporaryBindingTrace taskTrace=TemporaryBindingTrace.create(context.trace,"trace to resolve a task for",task.call.getCalleeExpression());
    OverloadResolutionResultsImpl<F> results=performResolution(task.replaceBindingTrace(taskTrace),callTransformer);
    allCandidates.addAll(task.getResolvedCalls());
    if (successfulResults != null)     continue;
    if (results.isSuccess() || results.isAmbiguity()) {
      taskTrace.commit();
      successfulResults=results;
    }
    if (results.getResultCode() == INCOMPLETE_TYPE_INFERENCE) {
      results.setTrace(taskTrace);
      successfulResults=results;
    }
    boolean updateResults=traceForFirstNonemptyCandidateSet == null || (resultsForFirstNonemptyCandidateSet.getResultCode() == CANDIDATES_WITH_WRONG_RECEIVER && results.getResultCode() != CANDIDATES_WITH_WRONG_RECEIVER);
    if (!task.getCandidates().isEmpty() && !results.isNothing() && updateResults) {
      traceForFirstNonemptyCandidateSet=taskTrace;
      resultsForFirstNonemptyCandidateSet=results;
    }
    if (successfulResults != null && !context.collectAllCandidates)     break;
  }
  OverloadResolutionResultsImpl<F> results;
  if (successfulResults != null) {
    results=successfulResults;
  }
 else   if (traceForFirstNonemptyCandidateSet == null) {
    tracing.unresolvedReference(context.trace);
    argumentTypeResolver.checkTypesWithNoCallee(context,SHAPE_FUNCTION_ARGUMENTS);
    results=OverloadResolutionResultsImpl.<F>nameNotFound();
  }
 else {
    traceForFirstNonemptyCandidateSet.commit();
    results=resultsForFirstNonemptyCandidateSet;
  }
  results.setAllCandidates(context.collectAllCandidates ? allCandidates : null);
  return results;
}
