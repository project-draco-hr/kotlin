{
  TemporaryBindingTrace traceForFirstNonemptyCandidateSet=null;
  TracingStrategy tracing=new TracingStrategy(){
    @Override public void bindReference(    @NotNull BindingTrace trace,    @NotNull CallableDescriptor descriptor){
      trace.record(REFERENCE_TARGET,reference,descriptor);
    }
    @Override public void reportOverallResolutionError(    @NotNull BindingTrace trace,    @NotNull String message){
      trace.getErrorHandler().genericError(callNode,message);
    }
    @Override public void reportWrongTypeArguments(    @NotNull BindingTrace trace,    @NotNull String message){
      JetTypeArgumentList typeArgumentList=call.getTypeArgumentList();
      if (typeArgumentList != null) {
        trace.getErrorHandler().genericError(typeArgumentList.getNode(),message);
      }
 else {
        reportOverallResolutionError(trace,message);
      }
    }
    @Override public void reportWrongValueArguments(    @NotNull BindingTrace trace,    @NotNull String message){
      ASTNode node;
      JetValueArgumentList valueArgumentList=call.getValueArgumentList();
      if (valueArgumentList != null) {
        node=valueArgumentList.getNode();
      }
 else       if (!call.getFunctionLiteralArguments().isEmpty()) {
        node=call.getFunctionLiteralArguments().get(0).getNode();
      }
 else {
        node=callNode;
      }
      trace.getErrorHandler().genericError(node,message);
    }
    @Override public void reportUnresolvedReference(    @NotNull BindingTrace trace){
      trace.getErrorHandler().unresolvedReference(reference);
    }
    @Override public void reportErrorOnReference(    BindingTrace trace,    String message){
      trace.getErrorHandler().genericError(reference.getNode(),message);
    }
  }
;
  for (  ResolutionTask<Descriptor> task : prioritizedTasks) {
    TemporaryBindingTrace temporaryTrace=TemporaryBindingTrace.create(trace);
    Descriptor descriptor=performResolution(temporaryTrace,scope,expectedType,task,tracing);
    if (descriptor != null) {
      temporaryTrace.commit();
      return descriptor;
    }
    if (traceForFirstNonemptyCandidateSet == null && !task.getCandidates().isEmpty()) {
      traceForFirstNonemptyCandidateSet=temporaryTrace;
    }
  }
  if (traceForFirstNonemptyCandidateSet != null) {
    traceForFirstNonemptyCandidateSet.commit();
  }
 else {
    trace.getErrorHandler().unresolvedReference(reference);
  }
  return null;
}
