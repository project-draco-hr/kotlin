{
  if (successfulCandidates.size() > 0) {
    if (successfulCandidates.size() == 1) {
      Map.Entry<Descriptor,Descriptor> entry=successfulCandidates.entrySet().iterator().next();
      Descriptor functionDescriptor=entry.getKey();
      Descriptor result=entry.getValue();
      TemporaryBindingTrace temporaryTrace=traces.get(functionDescriptor);
      temporaryTrace.commit();
      return OverloadResolutionResult.success(result);
    }
 else {
      Map<Descriptor,Descriptor> cleanCandidates=Maps.newLinkedHashMap(successfulCandidates);
      cleanCandidates.keySet().removeAll(dirtyCandidates);
      if (cleanCandidates.isEmpty()) {
        cleanCandidates=successfulCandidates;
      }
      Descriptor maximallySpecific=overloadingConflictResolver.findMaximallySpecific(cleanCandidates,traces,false);
      if (maximallySpecific != null) {
        return OverloadResolutionResult.success(maximallySpecific);
      }
      Descriptor maximallySpecificGenericsDiscriminated=overloadingConflictResolver.findMaximallySpecific(cleanCandidates,traces,true);
      if (maximallySpecificGenericsDiscriminated != null) {
        return OverloadResolutionResult.success(maximallySpecificGenericsDiscriminated);
      }
      if (dirtyCandidates.isEmpty()) {
        StringBuilder stringBuilder=new StringBuilder();
        for (        Descriptor functionDescriptor : successfulCandidates.keySet()) {
          stringBuilder.append(DescriptorRenderer.TEXT.render(functionDescriptor)).append(" ");
        }
        tracing.reportOverallResolutionError(trace,"Overload resolution ambiguity: " + stringBuilder);
      }
      tracing.recordAmbiguity(trace,successfulCandidates.keySet());
      return OverloadResolutionResult.ambiguity(successfulCandidates.keySet());
    }
  }
 else   if (!failedCandidates.isEmpty()) {
    if (failedCandidates.size() == 1) {
      Descriptor functionDescriptor=failedCandidates.iterator().next();
      TemporaryBindingTrace temporaryTrace=traces.get(functionDescriptor);
      temporaryTrace.commit();
      return OverloadResolutionResult.singleFailedCandidate(failedCandidates.iterator().next());
    }
 else {
      StringBuilder stringBuilder=new StringBuilder();
      for (      Descriptor functionDescriptor : failedCandidates) {
        stringBuilder.append(DescriptorRenderer.TEXT.render(functionDescriptor)).append(" ");
      }
      tracing.reportOverallResolutionError(trace,"None of the following functions can be called with the arguments supplied: " + stringBuilder);
      tracing.recordAmbiguity(trace,failedCandidates);
      return OverloadResolutionResult.manyFailedCandidates(failedCandidates);
    }
  }
 else {
    tracing.reportUnresolvedReference(trace);
    return OverloadResolutionResult.nameNotFound();
  }
}
