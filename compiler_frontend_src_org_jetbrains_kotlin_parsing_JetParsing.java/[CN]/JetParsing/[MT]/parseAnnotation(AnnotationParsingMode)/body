{
  if (at(LBRACKET)) {
    PsiBuilder.Marker annotation=mark();
    myBuilder.disableNewlines();
    advance();
    if (mode.isFileAnnotationParsingMode) {
      if (mode == FILE_ANNOTATIONS_WHEN_PACKAGE_OMITTED && !(at(FILE_KEYWORD) && lookahead(1) == COLON)) {
        annotation.rollbackTo();
        myBuilder.restoreNewlinesState();
        return false;
      }
      String message="Expecting \"" + FILE_KEYWORD.getValue() + COLON.getValue()+ "\" prefix for file annotations";
      expect(FILE_KEYWORD,message);
      expect(COLON,message,TokenSet.create(IDENTIFIER,RBRACKET));
    }
 else     if (at(FILE_KEYWORD) && lookahead(1) == COLON) {
      errorAndAdvance("File annotations are only allowed before package declaration",2);
    }
    if (!at(IDENTIFIER)) {
      error("Expecting a list of annotations");
    }
 else {
      parseAnnotationEntry();
      while (at(COMMA)) {
        errorAndAdvance("No commas needed to separate annotations");
      }
      while (at(IDENTIFIER)) {
        parseAnnotationEntry();
        while (at(COMMA)) {
          errorAndAdvance("No commas needed to separate annotations");
        }
      }
    }
    expect(RBRACKET,"Expecting ']' to close the annotation list");
    myBuilder.restoreNewlinesState();
    annotation.done(ANNOTATION);
    return true;
  }
 else   if (mode.allowShortAnnotations && at(IDENTIFIER)) {
    parseAnnotationEntry();
    return true;
  }
 else   if (mode.allowAtAnnotations && at(AT)) {
    if (myBuilder.rawLookup(1) == IDENTIFIER) {
      parseAnnotationEntry();
    }
 else {
      errorAndAdvance("Expected annotation identifier after '@'",1);
    }
    return true;
  }
  return false;
}
