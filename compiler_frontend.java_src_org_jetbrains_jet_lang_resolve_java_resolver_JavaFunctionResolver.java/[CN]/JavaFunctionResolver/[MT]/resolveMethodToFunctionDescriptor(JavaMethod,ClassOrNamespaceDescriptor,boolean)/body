{
  if (!DescriptorResolverUtils.isCorrectOwnerForEnumMember(ownerDescriptor,method)) {
    return null;
  }
  JavaType returnJavaType=method.getReturnType();
  if (returnJavaType == null) {
    return null;
  }
  SimpleFunctionDescriptor alreadyResolved=trace.get(BindingContext.FUNCTION,method.getPsi());
  if (alreadyResolved != null) {
    return alreadyResolved;
  }
  SimpleFunctionDescriptorImpl functionDescriptorImpl=new JavaMethodDescriptor(ownerDescriptor,annotationResolver.resolveAnnotations(method),method.getName());
  JavaTypeParameterResolver.Initializer typeParameterInitializer=typeParameterResolver.resolveTypeParameters(functionDescriptorImpl,method);
  typeParameterInitializer.initialize();
  List<TypeParameterDescriptor> methodTypeParameters=typeParameterInitializer.getDescriptors();
  TypeVariableResolver typeVariableResolver=new TypeVariableResolver(methodTypeParameters,functionDescriptorImpl);
  List<ValueParameterDescriptor> valueParameters=valueParameterResolver.resolveValueParameters(functionDescriptorImpl,method,typeVariableResolver);
  JetType returnType=makeReturnType(returnJavaType,method,typeVariableResolver);
  List<String> signatureErrors;
  List<FunctionDescriptor> superFunctions;
  ExternalSignatureResolver.AlternativeMethodSignature effectiveSignature;
  if (ownerDescriptor instanceof NamespaceDescriptor) {
    superFunctions=Collections.emptyList();
    effectiveSignature=externalSignatureResolver.resolveAlternativeMethodSignature(method,false,returnType,null,valueParameters,methodTypeParameters);
    signatureErrors=effectiveSignature.getErrors();
  }
 else   if (ownerDescriptor instanceof ClassDescriptor) {
    SignaturesPropagationData propagated=externalSignatureResolver.resolvePropagatedSignature(method,(ClassDescriptor)ownerDescriptor,returnType,null,valueParameters,methodTypeParameters);
    superFunctions=propagated.getSuperFunctions();
    effectiveSignature=externalSignatureResolver.resolveAlternativeMethodSignature(method,!superFunctions.isEmpty(),propagated.getModifiedReturnType(),propagated.getModifiedReceiverType(),propagated.getModifiedValueParameters(),propagated.getModifiedTypeParameters());
    signatureErrors=new ArrayList<String>(propagated.getSignatureErrors());
    signatureErrors.addAll(effectiveSignature.getErrors());
  }
 else {
    throw new IllegalStateException("Unknown class or namespace descriptor: " + ownerDescriptor);
  }
  functionDescriptorImpl.initialize(effectiveSignature.getReceiverType(),DescriptorUtils.getExpectedThisObjectIfNeeded(ownerDescriptor),effectiveSignature.getTypeParameters(),effectiveSignature.getValueParameters(),effectiveSignature.getReturnType(),Modality.convertFromFlags(method.isAbstract(),!method.isFinal()),method.getVisibility(),false);
  if (functionDescriptorImpl.getKind() == CallableMemberDescriptor.Kind.DECLARATION && record) {
    BindingContextUtils.recordFunctionDeclarationToDescriptor(trace,method.getPsi(),functionDescriptorImpl);
  }
  if (!RawTypesCheck.hasRawTypesInHierarchicalSignature(method) && JavaMethodSignatureUtil.isMethodReturnTypeCompatible(method) && !containsErrorType(superFunctions,functionDescriptorImpl)) {
    if (signatureErrors.isEmpty()) {
      checkFunctionsOverrideCorrectly(method,superFunctions,functionDescriptorImpl);
    }
 else     if (record) {
      externalSignatureResolver.reportSignatureErrors(functionDescriptorImpl,signatureErrors);
    }
  }
  return functionDescriptorImpl;
}
