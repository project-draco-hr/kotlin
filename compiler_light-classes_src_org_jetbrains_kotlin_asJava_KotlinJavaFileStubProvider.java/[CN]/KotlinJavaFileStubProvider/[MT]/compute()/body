{
  FqName packageFqName=stubGenerationStrategy.getPackageFqName();
  Collection<KtFile> files=stubGenerationStrategy.getFiles();
  checkForBuiltIns(packageFqName,files);
  LightClassConstructionContext context=stubGenerationStrategy.getContext(files);
  PsiJavaFileStub javaFileStub=createJavaFileStub(packageFqName,files);
  BindingContext bindingContext;
  BindingTraceContext forExtraDiagnostics=new BindingTraceContext();
  try {
    Stack<StubElement> stubStack=new Stack<StubElement>();
    stubStack.push(javaFileStub);
    GenerationState state=new GenerationState(project,new KotlinLightClassBuilderFactory(stubStack),context.getModule(),context.getBindingContext(),Lists.newArrayList(files),false,false,stubGenerationStrategy.getGenerateClassFilter(),false,false,false,forExtraDiagnostics);
    KotlinCodegenFacade.prepareForCompilation(state);
    bindingContext=state.getBindingContext();
    stubGenerationStrategy.generate(state,files);
    StubElement pop=stubStack.pop();
    if (pop != javaFileStub) {
      LOG.error("Unbalanced stack operations: " + pop);
    }
  }
 catch (  ProcessCanceledException e) {
    throw e;
  }
catch (  RuntimeException e) {
    logErrorWithOSInfo(e,packageFqName,null);
    throw e;
  }
  Diagnostics extraDiagnostics=forExtraDiagnostics.getBindingContext().getDiagnostics();
  return Result.create(stubGenerationStrategy.createLightClassData(javaFileStub,bindingContext,extraDiagnostics),local ? PsiModificationTracker.MODIFICATION_COUNT : PsiModificationTracker.OUT_OF_CODE_BLOCK_MODIFICATION_COUNT);
}
