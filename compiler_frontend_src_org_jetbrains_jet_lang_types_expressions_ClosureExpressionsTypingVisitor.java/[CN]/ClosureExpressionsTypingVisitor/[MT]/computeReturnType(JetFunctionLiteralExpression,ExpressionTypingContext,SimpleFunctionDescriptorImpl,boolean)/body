{
  TemporaryBindingTrace temporaryTrace=TemporaryBindingTrace.create(context.trace,"trace to resolve function literal expression",expression);
  JetType expectedReturnType=functionTypeExpected ? KotlinBuiltIns.getInstance().getReturnTypeFromFunctionType(context.expectedType) : null;
  JetType returnType=computeUnsafeReturnType(expression,context,functionDescriptor,temporaryTrace,expectedReturnType);
  temporaryTrace.commit(new TraceEntryFilter(){
    @Override public boolean accept(    @NotNull WritableSlice<?,?> slice,    Object key){
      return (slice != BindingContext.RESOLUTION_RESULTS_FOR_FUNCTION && slice != BindingContext.RESOLUTION_RESULTS_FOR_PROPERTY && slice != BindingContext.TRACE_DELTAS_CACHE);
    }
  }
,true);
  if (!expression.getFunctionLiteral().hasDeclaredReturnType() && functionTypeExpected) {
    if (KotlinBuiltIns.getInstance().isUnit(expectedReturnType)) {
      return KotlinBuiltIns.getInstance().getUnitType();
    }
  }
  return returnType == null ? CANNOT_BE_INFERRED : returnType;
}
