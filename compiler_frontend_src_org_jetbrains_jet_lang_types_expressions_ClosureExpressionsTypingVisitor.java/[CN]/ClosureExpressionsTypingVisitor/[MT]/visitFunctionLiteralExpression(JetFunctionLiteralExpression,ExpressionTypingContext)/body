{
  JetFunctionLiteral functionLiteral=expression.getFunctionLiteral();
  JetBlockExpression bodyExpression=functionLiteral.getBodyExpression();
  if (bodyExpression == null)   return null;
  JetType expectedType=context.expectedType;
  boolean functionTypeExpected=expectedType != TypeUtils.NO_EXPECTED_TYPE && KotlinBuiltIns.getInstance().isFunctionType(expectedType);
  SimpleFunctionDescriptorImpl functionDescriptor=createFunctionDescriptor(expression,context,functionTypeExpected);
  List<JetType> parameterTypes=Lists.newArrayList();
  List<ValueParameterDescriptor> valueParameters=functionDescriptor.getValueParameters();
  for (  ValueParameterDescriptor valueParameter : valueParameters) {
    parameterTypes.add(valueParameter.getType());
  }
  ReceiverDescriptor receiverParameter=functionDescriptor.getReceiverParameter();
  JetType receiver=receiverParameter != NO_RECEIVER ? receiverParameter.getType() : null;
  JetType returnType=TypeUtils.NO_EXPECTED_TYPE;
  JetScope functionInnerScope=FunctionDescriptorUtil.getFunctionInnerScope(context.scope,functionDescriptor,context.trace);
  JetTypeReference returnTypeRef=functionLiteral.getReturnTypeRef();
  TemporaryBindingTrace temporaryTrace=TemporaryBindingTrace.create(context.trace,"trace to resolve function literal expression",expression);
  if (returnTypeRef != null) {
    returnType=context.expressionTypingServices.getTypeResolver().resolveType(context.scope,returnTypeRef,context.trace,true);
    context.expressionTypingServices.checkFunctionReturnType(expression,context.replaceScope(functionInnerScope).replaceExpectedType(returnType).replaceBindingTrace(temporaryTrace),temporaryTrace);
  }
 else {
    if (functionTypeExpected) {
      returnType=KotlinBuiltIns.getInstance().getReturnTypeFromFunctionType(expectedType);
    }
    returnType=context.expressionTypingServices.getBlockReturnedType(functionInnerScope,bodyExpression,CoercionStrategy.COERCION_TO_UNIT,context.replaceExpectedType(returnType).replaceBindingTrace(temporaryTrace),temporaryTrace).getType();
  }
  temporaryTrace.commit(new TraceEntryFilter(){
    @Override public boolean accept(    @NotNull WritableSlice<?,?> slice,    Object key){
      return (slice != BindingContext.RESOLUTION_RESULTS_FOR_FUNCTION && slice != BindingContext.RESOLUTION_RESULTS_FOR_PROPERTY && slice != BindingContext.TRACE_DELTAS_CACHE);
    }
  }
,true);
  JetType safeReturnType=returnType == null ? ErrorUtils.createErrorType("<return type>") : returnType;
  functionDescriptor.setReturnType(safeReturnType);
  if (!functionLiteral.hasDeclaredReturnType() && functionTypeExpected) {
    JetType expectedReturnType=KotlinBuiltIns.getInstance().getReturnTypeFromFunctionType(expectedType);
    if (KotlinBuiltIns.getInstance().isUnit(expectedReturnType)) {
      functionDescriptor.setReturnType(KotlinBuiltIns.getInstance().getUnitType());
      return DataFlowUtils.checkType(KotlinBuiltIns.getInstance().getFunctionType(Collections.<AnnotationDescriptor>emptyList(),receiver,parameterTypes,KotlinBuiltIns.getInstance().getUnitType()),expression,context,context.dataFlowInfo);
    }
  }
  return DataFlowUtils.checkType(KotlinBuiltIns.getInstance().getFunctionType(Collections.<AnnotationDescriptor>emptyList(),receiver,parameterTypes,safeReturnType),expression,context,context.dataFlowInfo);
}
