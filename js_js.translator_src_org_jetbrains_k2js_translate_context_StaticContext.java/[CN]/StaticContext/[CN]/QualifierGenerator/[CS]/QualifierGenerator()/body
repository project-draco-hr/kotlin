{
  Rule<JsNameRef> standardObjectsHaveKotlinQualifier=new Rule<JsNameRef>(){
    @Override public JsNameRef apply(    @NotNull DeclarationDescriptor descriptor){
      if (!standardClasses.isStandardObject(descriptor)) {
        return null;
      }
      return namer.kotlinObject();
    }
  }
;
  Rule<JsNameRef> packageLevelDeclarationsHaveEnclosingPackagesNamesAsQualifier=new Rule<JsNameRef>(){
    @Override public JsNameRef apply(    @NotNull DeclarationDescriptor descriptor){
      if (isNativeObject(descriptor))       return null;
      DeclarationDescriptor containingDescriptor=getContainingDeclaration(descriptor);
      if (!(containingDescriptor instanceof PackageFragmentDescriptor)) {
        return null;
      }
      JsNameRef result=getQualifierForParentPackage(((PackageFragmentDescriptor)containingDescriptor).getFqName());
      String moduleName=getExternalModuleName(descriptor);
      if (moduleName == null) {
        return result;
      }
      if (LibrarySourcesConfig.UNKNOWN_EXTERNAL_MODULE_NAME.equals(moduleName)) {
        return null;
      }
      JsAstUtils.replaceRootReference(result,new JsArrayAccess(namer.kotlin("modules"),program.getStringLiteral(moduleName)));
      return result;
    }
    private String getExternalModuleName(    DeclarationDescriptor descriptor){
      PsiElement element=descriptorToDeclaration(descriptor);
      if (element == null && descriptor instanceof PropertyAccessorDescriptor) {
        element=descriptorToDeclaration(((PropertyAccessorDescriptor)descriptor).getCorrespondingProperty());
      }
      if (element == null) {
        return null;
      }
      return element.getContainingFile().getUserData(LibrarySourcesConfig.EXTERNAL_MODULE_NAME);
    }
  }
;
  Rule<JsNameRef> constructorOrClassObjectHasTheSameQualifierAsTheClass=new Rule<JsNameRef>(){
    @Override public JsNameRef apply(    @NotNull DeclarationDescriptor descriptor){
      if (descriptor instanceof ConstructorDescriptor || DescriptorUtils.isClassObject(descriptor)) {
        return getQualifierForDescriptor(descriptor.getContainingDeclaration());
      }
      return null;
    }
  }
;
  Rule<JsNameRef> libraryObjectsHaveKotlinQualifier=new Rule<JsNameRef>(){
    @Override public JsNameRef apply(    @NotNull DeclarationDescriptor descriptor){
      if (isLibraryObject(descriptor)) {
        return namer.kotlinObject();
      }
      return null;
    }
  }
;
  Rule<JsNameRef> nativeObjectsHaveNativePartOfFullQualifier=new Rule<JsNameRef>(){
    @Override public JsNameRef apply(    @NotNull DeclarationDescriptor descriptor){
      if (descriptor instanceof ConstructorDescriptor || !isNativeObject(descriptor))       return null;
      DeclarationDescriptor containingDeclaration=descriptor.getContainingDeclaration();
      if (containingDeclaration != null && isNativeObject(containingDeclaration)) {
        return getQualifiedReference(containingDeclaration);
      }
      return null;
    }
  }
;
  addRule(libraryObjectsHaveKotlinQualifier);
  addRule(constructorOrClassObjectHasTheSameQualifierAsTheClass);
  addRule(standardObjectsHaveKotlinQualifier);
  addRule(packageLevelDeclarationsHaveEnclosingPackagesNamesAsQualifier);
  addRule(nativeObjectsHaveNativePartOfFullQualifier);
}
