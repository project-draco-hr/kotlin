{
  ClassBuilder classBuilder=createClassBuilder();
  classBuilder.defineClass(null,V1_6,classAccess,newLambdaType.getInternalName(),signature,superName,interfaces);
  ParametersBuilder builder=ParametersBuilder.newBuilder();
  Parameters parameters=getLambdaParameters(builder,invocation);
  MethodVisitor invokeVisitor=newMethod(classBuilder,invoke);
  RegeneratedLambdaFieldRemapper remapper=new RegeneratedLambdaFieldRemapper(oldLambdaType.getInternalName(),newLambdaType.getInternalName(),parameters,invocation.getCapturedLambdasToInline(),parentRemapper);
  MethodInliner inliner=new MethodInliner(invoke,parameters,inliningContext.subInline(inliningContext.nameGenerator.subGenerator("lambda")),remapper,isSameModule,"Transformer for " + invocation.getOwnerInternalName());
  InlineResult result=inliner.doInline(invokeVisitor,new LocalVarRemapper(parameters,0),false);
  invokeVisitor.visitMaxs(-1,-1);
  generateConstructorAndFields(classBuilder,builder,invocation);
  if (bridge != null) {
    MethodVisitor invokeBridge=newMethod(classBuilder,bridge);
    bridge.accept(new MethodVisitor(ASM4,invokeBridge){
      @Override public void visitMethodInsn(      int opcode,      String owner,      String name,      String desc){
        if (owner.equals(oldLambdaType.getInternalName())) {
          super.visitMethodInsn(opcode,newLambdaType.getInternalName(),name,desc);
        }
 else {
          super.visitMethodInsn(opcode,owner,name,desc);
        }
      }
    }
);
  }
  classBuilder.done();
  invocation.setNewLambdaType(newLambdaType);
  return result;
}
