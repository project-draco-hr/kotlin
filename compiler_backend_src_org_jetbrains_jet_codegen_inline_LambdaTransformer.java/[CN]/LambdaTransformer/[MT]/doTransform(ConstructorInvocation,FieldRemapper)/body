{
  ClassBuilder classBuilder=createClassBuilder();
  final List<MethodNode> methodsToTransform=new ArrayList<MethodNode>();
  reader.accept(new ClassVisitor(InlineCodegenUtil.API,classBuilder.getVisitor()){
    @Override public MethodVisitor visitMethod(    int access,    @NotNull String name,    @NotNull String desc,    String signature,    String[] exceptions){
      MethodNode node=new MethodNode(access,name,desc,signature,exceptions);
      if (name.equals("<init>")) {
        if (constructor != null)         throw new RuntimeException("Lambda, SAM or anonymous object should have only one constructor");
        constructor=node;
      }
 else {
        methodsToTransform.add(node);
      }
      return node;
    }
    @Override public FieldVisitor visitField(    int access,    @NotNull String name,    @NotNull String desc,    String signature,    Object value){
      addUniqueField(name);
      if (InlineCodegenUtil.isCapturedFieldName(name)) {
        return null;
      }
 else {
        return super.visitField(access,name,desc,signature,value);
      }
    }
  }
,ClassReader.SKIP_FRAMES);
  ParametersBuilder allCapturedParamBuilder=ParametersBuilder.newBuilder();
  ParametersBuilder constructorParamBuilder=ParametersBuilder.newBuilder();
  extractParametersMappingAndPatchConstructor(constructor,allCapturedParamBuilder,constructorParamBuilder,invocation);
  InlineResult result=InlineResult.create();
  for (  MethodNode next : methodsToTransform) {
    MethodVisitor visitor=newMethod(classBuilder,next);
    InlineResult funResult=inlineMethod(invocation,parentRemapper,visitor,next,allCapturedParamBuilder);
    result.addAllClassesToRemove(funResult);
  }
  InlineResult constructorResult=generateConstructorAndFields(classBuilder,allCapturedParamBuilder,constructorParamBuilder,invocation,parentRemapper);
  result.addAllClassesToRemove(constructorResult);
  classBuilder.done();
  invocation.setNewLambdaType(newLambdaType);
  return result;
}
