{
  final JetType[] result=new JetType[1];
  if (typeElement != null) {
    typeElement.accept(new JetVisitorVoid(){
      @Override public void visitUserType(      JetUserType type){
        JetSimpleNameExpression referenceExpression=type.getReferenceExpression();
        String referencedName=type.getReferencedName();
        if (referenceExpression == null || referencedName == null) {
          return;
        }
        ClassifierDescriptor classifierDescriptor=resolveClass(scope,type,trace);
        if (classifierDescriptor == null) {
          resolveTypeProjections(scope,ErrorUtils.createErrorType("No type").getConstructor(),type.getTypeArguments(),trace,checkBounds);
          return;
        }
        trace.record(BindingContext.REFERENCE_TARGET,referenceExpression,classifierDescriptor);
        if (classifierDescriptor instanceof TypeParameterDescriptor) {
          TypeParameterDescriptor typeParameterDescriptor=(TypeParameterDescriptor)classifierDescriptor;
          JetScope scopeForTypeParameter=getScopeForTypeParameter(typeParameterDescriptor,checkBounds);
          if (scopeForTypeParameter instanceof ErrorUtils.ErrorScope) {
            result[0]=ErrorUtils.createErrorType("?");
          }
 else {
            result[0]=new JetTypeImpl(annotations,typeParameterDescriptor.getTypeConstructor(),TypeUtils.hasNullableLowerBound(typeParameterDescriptor),Collections.<TypeProjection>emptyList(),scopeForTypeParameter);
          }
          resolveTypeProjections(scope,ErrorUtils.createErrorType("No type").getConstructor(),type.getTypeArguments(),trace,checkBounds);
          DeclarationDescriptor containing=typeParameterDescriptor.getContainingDeclaration();
          if (containing instanceof ClassDescriptor) {
            DescriptorResolver.checkHasOuterClassInstance(scope,trace,referenceExpression,(ClassDescriptor)containing);
          }
        }
 else         if (classifierDescriptor instanceof ClassDescriptor) {
          ClassDescriptor classDescriptor=(ClassDescriptor)classifierDescriptor;
          TypeConstructor typeConstructor=classifierDescriptor.getTypeConstructor();
          List<TypeProjection> arguments=resolveTypeProjections(scope,typeConstructor,type.getTypeArguments(),trace,checkBounds);
          List<TypeParameterDescriptor> parameters=typeConstructor.getParameters();
          int expectedArgumentCount=parameters.size();
          int actualArgumentCount=arguments.size();
          if (ErrorUtils.isError(typeConstructor)) {
            result[0]=ErrorUtils.createErrorType("[Error type: " + typeConstructor + "]");
          }
 else {
            if (actualArgumentCount != expectedArgumentCount) {
              if (actualArgumentCount == 0) {
                if (rhsOfIsExpression(type) || rhsOfIsPattern(type)) {
                  trace.report(NO_TYPE_ARGUMENTS_ON_RHS_OF_IS_EXPRESSION.on(type,expectedArgumentCount,allStarProjectionsString(typeConstructor)));
                }
 else {
                  trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(type,expectedArgumentCount));
                }
              }
 else {
                trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(type.getTypeArgumentList(),expectedArgumentCount));
              }
            }
 else {
              result[0]=new JetTypeImpl(annotations,typeConstructor,false,arguments,classDescriptor.getMemberScope(arguments));
              if (checkBounds) {
                TypeSubstitutor substitutor=TypeSubstitutor.create(result[0]);
                for (int i=0, parametersSize=parameters.size(); i < parametersSize; i++) {
                  TypeParameterDescriptor parameter=parameters.get(i);
                  JetType argument=arguments.get(i).getType();
                  JetTypeReference typeReference=type.getTypeArguments().get(i).getTypeReference();
                  if (typeReference != null) {
                    descriptorResolver.checkBounds(typeReference,argument,parameter,substitutor,trace);
                  }
                }
              }
            }
          }
        }
      }
      @Override public void visitNullableType(      JetNullableType nullableType){
        JetType baseType=resolveTypeElement(scope,annotations,nullableType.getInnerType(),trace,checkBounds);
        if (baseType.isNullable()) {
          trace.report(REDUNDANT_NULLABLE.on(nullableType));
        }
 else         if (TypeUtils.hasNullableSuperType(baseType)) {
          trace.report(BASE_WITH_NULLABLE_UPPER_BOUND.on(nullableType,baseType));
        }
        result[0]=TypeUtils.makeNullable(baseType);
      }
      @Override public void visitTupleType(      JetTupleType type){
        if (type.getComponentTypeRefs().size() <= 3) {
          trace.report(TUPLES_ARE_NOT_SUPPORTED.on(type));
        }
 else {
          trace.report(TUPLES_ARE_NOT_SUPPORTED_BIG.on(type));
        }
        result[0]=KotlinBuiltIns.getInstance().getTupleType(resolveTypes(scope,type.getComponentTypeRefs(),trace,checkBounds));
      }
      @Override public void visitFunctionType(      JetFunctionType type){
        JetTypeReference receiverTypeRef=type.getReceiverTypeRef();
        JetType receiverType=receiverTypeRef == null ? null : resolveType(scope,receiverTypeRef,trace,checkBounds);
        List<JetType> parameterTypes=new ArrayList<JetType>();
        for (        JetParameter parameter : type.getParameters()) {
          parameterTypes.add(resolveType(scope,parameter.getTypeReference(),trace,checkBounds));
        }
        JetTypeReference returnTypeRef=type.getReturnTypeRef();
        JetType returnType;
        if (returnTypeRef != null) {
          returnType=resolveType(scope,returnTypeRef,trace,checkBounds);
        }
 else {
          returnType=KotlinBuiltIns.getInstance().getUnitType();
        }
        result[0]=KotlinBuiltIns.getInstance().getFunctionType(annotations,receiverType,parameterTypes,returnType);
      }
      @Override public void visitJetElement(      JetElement element){
        trace.report(UNSUPPORTED.on(element,"Self-types are not supported yet"));
      }
    }
);
  }
  if (result[0] == null) {
    return ErrorUtils.createErrorType(typeElement == null ? "No type element" : typeElement.getText());
  }
  return result[0];
}
