{
  List<TypeProjection> arguments=new ArrayList<TypeProjection>();
  for (int i=0, argumentElementsSize=argumentElements.size(); i < argumentElementsSize; i++) {
    JetTypeProjection argumentElement=argumentElements.get(i);
    JetProjectionKind projectionKind=argumentElement.getProjectionKind();
    JetType type;
    if (projectionKind == JetProjectionKind.STAR) {
      List<TypeParameterDescriptor> parameters=constructor.getParameters();
      if (parameters.size() > i) {
        TypeParameterDescriptor parameterDescriptor=parameters.get(i);
        arguments.add(SubstitutionUtils.makeStarProjection(parameterDescriptor));
      }
 else {
        arguments.add(new TypeProjection(OUT_VARIANCE,ErrorUtils.createErrorType("*")));
      }
    }
 else {
      type=resolveType(scope,argumentElement.getTypeReference(),trace,checkBounds);
      Variance kind=resolveProjectionKind(projectionKind);
      if (constructor.getParameters().size() > i) {
        TypeParameterDescriptor parameterDescriptor=constructor.getParameters().get(i);
        if (kind != INVARIANT && parameterDescriptor.getVariance() != INVARIANT) {
          if (kind == parameterDescriptor.getVariance()) {
            trace.report(REDUNDANT_PROJECTION.on(argumentElement,constructor.getDeclarationDescriptor()));
          }
 else {
            trace.report(CONFLICTING_PROJECTION.on(argumentElement,constructor.getDeclarationDescriptor()));
          }
        }
      }
      arguments.add(new TypeProjection(kind,type));
    }
  }
  return arguments;
}
