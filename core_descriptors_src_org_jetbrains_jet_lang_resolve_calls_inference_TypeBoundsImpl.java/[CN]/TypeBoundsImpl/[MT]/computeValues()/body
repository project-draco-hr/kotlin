{
  Set<JetType> values=new LinkedHashSet<JetType>();
  if (bounds.isEmpty()) {
    return Collections.emptyList();
  }
  boolean hasStrongBound=KotlinPackage.any(bounds,new Function1<Bound,Boolean>(){
    @Override public Boolean invoke(    Bound bound){
      return bound.position.isStrong();
    }
  }
);
  if (!hasStrongBound) {
    return Collections.emptyList();
  }
  Set<JetType> exactBounds=filterBounds(bounds,BoundKind.EXACT_BOUND,values);
  JetType bestFit=TypesPackage.singleBestRepresentative(exactBounds);
  if (bestFit != null) {
    if (tryPossibleAnswer(bestFit)) {
      return Collections.singleton(bestFit);
    }
  }
  values.addAll(exactBounds);
  Collection<JetType> numberLowerBounds=new LinkedHashSet<JetType>();
  Collection<JetType> generalLowerBounds=new LinkedHashSet<JetType>();
  filterNumberTypes(filterBounds(bounds,LOWER_BOUND,values),numberLowerBounds,generalLowerBounds);
  JetType superTypeOfLowerBounds=CommonSupertypes.commonSupertypeForNonDenotableTypes(generalLowerBounds);
  if (tryPossibleAnswer(superTypeOfLowerBounds)) {
    return Collections.singleton(superTypeOfLowerBounds);
  }
  UtilsPackage.addIfNotNull(values,superTypeOfLowerBounds);
  JetType superTypeOfNumberLowerBounds=TypeUtils.commonSupertypeForNumberTypes(numberLowerBounds);
  if (tryPossibleAnswer(superTypeOfNumberLowerBounds)) {
    return Collections.singleton(superTypeOfNumberLowerBounds);
  }
  UtilsPackage.addIfNotNull(values,superTypeOfNumberLowerBounds);
  if (superTypeOfLowerBounds != null && superTypeOfNumberLowerBounds != null) {
    JetType superTypeOfAllLowerBounds=CommonSupertypes.commonSupertypeForNonDenotableTypes(Arrays.asList(superTypeOfLowerBounds,superTypeOfNumberLowerBounds));
    if (tryPossibleAnswer(superTypeOfAllLowerBounds)) {
      return Collections.singleton(superTypeOfAllLowerBounds);
    }
  }
  Set<JetType> upperBounds=filterBounds(bounds,BoundKind.UPPER_BOUND,values);
  JetType intersectionOfUpperBounds=TypeUtils.intersect(JetTypeChecker.DEFAULT,upperBounds);
  if (!upperBounds.isEmpty() && intersectionOfUpperBounds != null) {
    if (tryPossibleAnswer(intersectionOfUpperBounds)) {
      return Collections.singleton(intersectionOfUpperBounds);
    }
  }
  values.addAll(filterBounds(bounds,BoundKind.UPPER_BOUND));
  return values;
}
