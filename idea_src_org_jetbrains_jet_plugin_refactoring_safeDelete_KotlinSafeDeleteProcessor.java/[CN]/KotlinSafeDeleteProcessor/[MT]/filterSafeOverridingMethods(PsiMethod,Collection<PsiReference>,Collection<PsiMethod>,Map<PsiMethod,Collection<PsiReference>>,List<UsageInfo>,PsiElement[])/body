{
  Set<PsiMethod> validOverriding=new LinkedHashSet<PsiMethod>(overridingMethods);
  boolean anyNewBadRefs;
  do {
    anyNewBadRefs=false;
    for (    PsiMethod overridingMethod : overridingMethods) {
      if (validOverriding.contains(overridingMethod)) {
        Collection<PsiReference> overridingReferences=methodToReferences.get(overridingMethod);
        boolean anyOverridingRefs=false;
        for (        PsiReference overridingReference : overridingReferences) {
          PsiElement element=overridingReference.getElement();
          if (!isInside(element,allElementsToDelete) && !isInside(element,validOverriding)) {
            anyOverridingRefs=true;
            break;
          }
        }
        if (!anyOverridingRefs && isMultipleInterfacesImplementation(overridingMethod,originalMethod,allElementsToDelete)) {
          anyOverridingRefs=true;
        }
        if (anyOverridingRefs) {
          validOverriding.remove(overridingMethod);
          anyNewBadRefs=true;
          for (          PsiReference reference : originalReferences) {
            PsiElement element=reference.getElement();
            if (!isInside(element,allElementsToDelete) && !isInside(element,overridingMethods)) {
              validOverriding.clear();
            }
          }
        }
      }
    }
  }
 while (anyNewBadRefs && !validOverriding.isEmpty());
  for (  PsiMethod method : validOverriding) {
    if (method != originalMethod) {
      usages.add(new KotlinSafeDeleteOverridingUsageInfo(method,originalMethod));
    }
  }
  return validOverriding;
}
