{
  Set<MutableResolvedCall<D>> successfulAndIncomplete=Sets.newLinkedHashSet();
  successfulAndIncomplete.addAll(successfulCandidates);
  successfulAndIncomplete.addAll(incompleteCandidates);
  OverloadResolutionResultsImpl<D> results=chooseAndReportMaximallySpecific(successfulAndIncomplete,true,checkArgumentsMode);
  if (results.isSingleResult()) {
    MutableResolvedCall<D> resultingCall=results.getResultingCall();
    resultingCall.getTrace().moveAllMyDataTo(context.trace);
    if (resultingCall.getStatus() == INCOMPLETE_TYPE_INFERENCE) {
      return OverloadResolutionResultsImpl.incompleteTypeInference(resultingCall);
    }
  }
  if (results.isAmbiguity()) {
    tracing.recordAmbiguity(context.trace,results.getResultingCalls());
    boolean allCandidatesIncomplete=allIncomplete(results.getResultingCalls());
    if (context.checkArguments != CheckArgumentTypesMode.CHECK_VALUE_ARGUMENTS || !CallUtilKt.hasUnresolvedArguments(context.call,context)) {
      if (allCandidatesIncomplete) {
        tracing.cannotCompleteResolve(context.trace,results.getResultingCalls());
      }
 else {
        tracing.ambiguity(context.trace,results.getResultingCalls());
      }
    }
    if (allCandidatesIncomplete) {
      return OverloadResolutionResultsImpl.incompleteTypeInference(results.getResultingCalls());
    }
  }
  return results;
}
