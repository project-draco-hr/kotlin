{
  super(containingDeclaration,annotations,name,source);
  this.variance=variance;
  this.reified=isReified;
  this.index=index;
  this.typeConstructor=storageManager.createLazyValue(new Function0<TypeConstructor>(){
    @Override public TypeConstructor invoke(){
      return createTypeConstructor();
    }
  }
);
  this.defaultType=storageManager.createLazyValue(new Function0<KotlinType>(){
    @Override public KotlinType invoke(){
      return KotlinTypeImpl.create(Annotations.Companion.getEMPTY(),getTypeConstructor(),false,Collections.<TypeProjection>emptyList(),new LazyScopeAdapter(storageManager.createLazyValue(new Function0<MemberScope>(){
        @Override public MemberScope invoke(){
          return TypeIntersectionScope.create("Scope for type parameter " + name.asString(),getUpperBounds());
        }
      }
)));
    }
  }
);
  this.upperBounds=storageManager.createLazyValueWithPostCompute(new Function0<List<KotlinType>>(){
    @Override public List<KotlinType> invoke(){
      return resolveUpperBounds();
    }
  }
,new Function1<Boolean,List<KotlinType>>(){
    @Override public List<KotlinType> invoke(    Boolean aBoolean){
      return FALLBACK_UPPER_BOUNDS_ON_RECURSION;
    }
  }
,new Function1<List<KotlinType>,Unit>(){
    @Override public Unit invoke(    List<KotlinType> types){
      getSupertypeLoopChecker().findLoopsInSupertypesAndDisconnect(getTypeConstructor(),types,new Function1<TypeConstructor,Iterable<? extends KotlinType>>(){
        @Override public Iterable<? extends KotlinType> invoke(        TypeConstructor typeConstructor){
          if (typeConstructor.getDeclarationDescriptor() instanceof AbstractTypeParameterDescriptor) {
            return ((AbstractTypeParameterDescriptor)typeConstructor.getDeclarationDescriptor()).resolveUpperBounds();
          }
          return typeConstructor.getSupertypes();
        }
      }
,new Function1<KotlinType,Unit>(){
        @Override public Unit invoke(        KotlinType type){
          reportCycleError(type);
          return Unit.INSTANCE;
        }
      }
);
      if (types.isEmpty()) {
        types.add(ErrorUtils.createErrorType("Cyclic upper bounds"));
      }
      return null;
    }
  }
);
}
