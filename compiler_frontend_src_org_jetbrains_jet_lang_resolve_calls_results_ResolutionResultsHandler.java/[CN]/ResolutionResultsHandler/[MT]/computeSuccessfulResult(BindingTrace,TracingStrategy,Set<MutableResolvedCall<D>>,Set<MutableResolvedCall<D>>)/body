{
  Set<MutableResolvedCall<D>> successfulAndIncomplete=Sets.newLinkedHashSet();
  successfulAndIncomplete.addAll(successfulCandidates);
  successfulAndIncomplete.addAll(incompleteCandidates);
  OverloadResolutionResultsImpl<D> results=chooseAndReportMaximallySpecific(successfulAndIncomplete,true);
  if (results.isSingleResult()) {
    MutableResolvedCall<D> resultingCall=results.getResultingCall();
    resultingCall.getTrace().moveAllMyDataTo(trace);
    if (resultingCall.getStatus() == INCOMPLETE_TYPE_INFERENCE) {
      return OverloadResolutionResultsImpl.incompleteTypeInference(resultingCall);
    }
  }
  if (results.isAmbiguity()) {
    tracing.recordAmbiguity(trace,results.getResultingCalls());
    if (allIncomplete(results.getResultingCalls())) {
      tracing.cannotCompleteResolve(trace,results.getResultingCalls());
      return OverloadResolutionResultsImpl.incompleteTypeInference(results.getResultingCalls());
    }
    if (allClean(results.getResultingCalls())) {
      tracing.ambiguity(trace,results.getResultingCalls());
    }
  }
  return results;
}
