{
  if (supertype.isNullable() || subtype.isNullable()) {
    return isCastErased(TypeUtils.makeNotNullable(supertype),TypeUtils.makeNotNullable(subtype),typeChecker);
  }
  if (typeChecker.isSubtypeOf(supertype,subtype))   return false;
  if (isTypeParameter(subtype))   return true;
  if (allParametersReified(subtype))   return false;
  JetType subtypeWithVariables=TypeUtils.makeUnsubstitutedType(subtype.getConstructor(),ErrorUtils.createErrorScope("Scope for intermediate type. This type shouldn't be used outside isCastErased()",true));
  JetType supertypeWithVariables=TypeCheckingProcedure.findCorrespondingSupertype(subtypeWithVariables,supertype);
  final List<TypeParameterDescriptor> variables=subtypeWithVariables.getConstructor().getParameters();
  Map<TypeConstructor,TypeProjection> substitution;
  if (supertypeWithVariables != null) {
    TypeUnifier.UnificationResult solution=TypeUnifier.unify(new TypeProjection(supertype),new TypeProjection(supertypeWithVariables),new Predicate<TypeConstructor>(){
      @Override public boolean apply(      TypeConstructor typeConstructor){
        ClassifierDescriptor descriptor=typeConstructor.getDeclarationDescriptor();
        return descriptor instanceof TypeParameterDescriptor && variables.contains(descriptor);
      }
    }
);
    substitution=Maps.newHashMap(solution.getSubstitution());
  }
 else {
    substitution=Maps.newHashMapWithExpectedSize(variables.size());
  }
  for (  TypeParameterDescriptor variable : variables) {
    TypeProjection value=substitution.get(variable.getTypeConstructor());
    if (value == null) {
      substitution.put(variable.getTypeConstructor(),SubstitutionUtils.makeStarProjection(variable));
    }
  }
  JetType staticallyKnownSubtype=TypeSubstitutor.create(substitution).substitute(subtypeWithVariables,Variance.INVARIANT);
  if (staticallyKnownSubtype == null)   return true;
  return !typeChecker.isSubtypeOf(staticallyKnownSubtype,subtype);
}
