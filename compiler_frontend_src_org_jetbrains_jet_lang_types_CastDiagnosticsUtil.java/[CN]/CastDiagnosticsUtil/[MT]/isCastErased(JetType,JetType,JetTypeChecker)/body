{
  if (supertype.isNullable() || subtype.isNullable()) {
    return isCastErased(TypeUtils.makeNotNullable(supertype),TypeUtils.makeNotNullable(subtype),typeChecker);
  }
  if (typeChecker.isSubtypeOf(supertype,subtype))   return false;
  if (isTypeParameter(subtype))   return true;
  if (allParametersReified(subtype))   return false;
  JetType subtypeWithVariables=TypeUtils.makeUnsubstitutedType(subtype.getConstructor(),ErrorUtils.createErrorScope("Scope for intermediate type. This type shouldn't be used outside isCastErased()",true));
  JetType supertypeWithVariables=TypeCheckingProcedure.findCorrespondingSupertype(subtypeWithVariables,supertype);
  if (supertypeWithVariables == null)   return true;
  final List<TypeParameterDescriptor> variables=subtypeWithVariables.getConstructor().getParameters();
  TypeUnifier.UnificationResult solution=TypeUnifier.unify(new TypeProjection(supertype),new TypeProjection(supertypeWithVariables),new Predicate<TypeConstructor>(){
    @Override public boolean apply(    TypeConstructor typeConstructor){
      ClassifierDescriptor descriptor=typeConstructor.getDeclarationDescriptor();
      return descriptor instanceof TypeParameterDescriptor && variables.contains(descriptor);
    }
  }
);
  Map<TypeConstructor,TypeProjection> substitution=Maps.newHashMap(solution.getSubstitution());
  for (  TypeParameterDescriptor variable : variables) {
    TypeProjection value=substitution.get(variable.getTypeConstructor());
    if (value == null) {
      substitution.put(variable.getTypeConstructor(),SubstitutionUtils.makeStarProjection(variable));
    }
  }
  JetType staticallyKnownSubtype=TypeSubstitutor.create(substitution).substitute(subtypeWithVariables,Variance.INVARIANT);
  if (staticallyKnownSubtype == null)   return true;
  return !typeChecker.isSubtypeOf(staticallyKnownSubtype,subtype);
}
