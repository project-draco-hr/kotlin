{
  ClassDescriptor classDecl=constructorDescriptor.getContainingDeclaration();
  iv.load(0,TYPE_OBJECT);
  if (classDecl.getKind() == ClassKind.ENUM_CLASS) {
    iv.load(1,JetTypeMapper.TYPE_OBJECT);
    iv.load(2,Type.INT_TYPE);
  }
  if (classDecl.getContainingDeclaration() instanceof ClassDescriptor) {
    iv.load(frameMap.getOuterThisIndex(),typeMapper.mapType(((ClassDescriptor)descriptor.getContainingDeclaration()).getDefaultType(),MapTypeMode.IMPL));
  }
  CallableMethod method=typeMapper.mapToCallableMethod(constructorDescriptor,kind,typeMapper.hasThis0(constructorDescriptor.getContainingDeclaration()));
  if (myClass instanceof JetObjectDeclaration && superCall instanceof JetDelegatorToSuperCall && ((JetObjectDeclaration)myClass).isObjectLiteral()) {
    ConstructorDescriptor superConstructor=(ConstructorDescriptor)bindingContext.get(BindingContext.REFERENCE_TARGET,((JetDelegatorToSuperCall)superCall).getCalleeExpression().getConstructorReferenceExpression());
    CallableMethod superCallable=typeMapper.mapToCallableMethod(superConstructor,OwnerKind.IMPLEMENTATION,typeMapper.hasThis0(superConstructor.getContainingDeclaration()));
    int nextVar=firstSuperArgument + 1;
    for (    Type t : superCallable.getSignature().getAsmMethod().getArgumentTypes()) {
      iv.load(nextVar,t);
      nextVar+=t.getSize();
    }
    method.invoke(codegen.v);
  }
 else {
    codegen.invokeMethodWithArguments(method,constructorCall,StackValue.none());
  }
}
