{
  DeclarationDescriptor containingDeclaration=fun.getContainingDeclaration();
  if (containingDeclaration instanceof ClassDescriptor) {
    ClassDescriptor declaration=(ClassDescriptor)containingDeclaration;
    PsiElement psiElement=BindingContextUtils.classDescriptorToDeclaration(bindingContext,declaration);
    if (psiElement instanceof JetClass) {
      JetClass jetClass=(JetClass)psiElement;
      if (jetClass.isTrait()) {
        int flags=ACC_PUBLIC;
        Method function;
        Method functionOriginal;
        if (fun instanceof PropertyAccessorDescriptor) {
          PropertyDescriptor property=((PropertyAccessorDescriptor)fun).getCorrespondingProperty();
          if (fun instanceof PropertyGetterDescriptor) {
            function=typeMapper.mapGetterSignature(property,OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();
            functionOriginal=typeMapper.mapGetterSignature(property.getOriginal(),OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();
          }
 else           if (fun instanceof PropertySetterDescriptor) {
            function=typeMapper.mapSetterSignature(property,OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();
            functionOriginal=typeMapper.mapSetterSignature(property.getOriginal(),OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();
          }
 else {
            throw new IllegalStateException("Accessor is neither getter, nor setter, what is it?");
          }
        }
 else {
          function=typeMapper.mapSignature(fun.getName(),fun).getAsmMethod();
          functionOriginal=typeMapper.mapSignature(fun.getName(),fun.getOriginal()).getAsmMethod();
        }
        final MethodVisitor mv=v.newMethod(myClass,flags,function.getName(),function.getDescriptor(),null,null);
        AnnotationCodegen.forMethod(mv,state.getInjector().getJetTypeMapper()).genAnnotations(fun);
        JvmMethodSignature jvmSignature=typeMapper.mapToCallableMethod(inheritedFun,false,OwnerKind.IMPLEMENTATION).getSignature();
        JetMethodAnnotationWriter aw=JetMethodAnnotationWriter.visitAnnotation(mv);
        if (fun instanceof PropertyAccessorDescriptor) {
          aw.writeFlags(JvmStdlibNames.JET_METHOD_FLAG_PROPERTY_BIT);
          aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());
          aw.writePropertyType(jvmSignature.getKotlinReturnType());
        }
 else {
          aw.writeFlags();
          aw.writeNullableReturnType(fun.getReturnType().isNullable());
          aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());
          aw.writeReturnType(jvmSignature.getKotlinReturnType());
        }
        aw.visitEnd();
        if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {
          StubCodegen.generateStubCode(mv);
        }
 else         if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {
          mv.visitCode();
          codegen.generateThisOrOuter(descriptor);
          Type[] argTypes=function.getArgumentTypes();
          InstructionAdapter iv=new InstructionAdapter(mv);
          iv.load(0,JetTypeMapper.TYPE_OBJECT);
          for (int i=0, reg=1; i < argTypes.length; i++) {
            Type argType=argTypes[i];
            iv.load(reg,argType);
            reg+=argType.getSize();
          }
          JetType jetType=TraitImplBodyCodegen.getSuperClass(declaration,bindingContext);
          Type type=typeMapper.mapType(jetType,MapTypeMode.IMPL);
          if (type.getInternalName().equals("java/lang/Object")) {
            jetType=declaration.getDefaultType();
            type=typeMapper.mapType(jetType,MapTypeMode.IMPL);
          }
          String fdescriptor=functionOriginal.getDescriptor().replace("(","(" + type.getDescriptor());
          Type type1=typeMapper.mapType(((ClassDescriptor)fun.getContainingDeclaration()).getDefaultType(),MapTypeMode.TRAIT_IMPL);
          iv.invokestatic(type1.getInternalName(),function.getName(),fdescriptor);
          if (function.getReturnType().getSort() == Type.OBJECT) {
            iv.checkcast(function.getReturnType());
          }
          iv.areturn(function.getReturnType());
          FunctionCodegen.endVisit(iv,"trait method",BindingContextUtils.callableDescriptorToDeclaration(bindingContext,fun));
        }
        FunctionCodegen.generateBridgeIfNeeded(context,state,v,function,fun,kind);
      }
    }
  }
}
