{
  DeclarationDescriptor containingDeclaration=fun.getContainingDeclaration();
  if (!(containingDeclaration instanceof ClassDescriptor)) {
    return;
  }
  ClassDescriptor containingClass=(ClassDescriptor)containingDeclaration;
  if (containingClass.getKind() != ClassKind.TRAIT) {
    return;
  }
  int flags=ACC_PUBLIC;
  Method methodToGenerate=typeMapper.mapSignature(fun).getAsmMethod();
  Method methodInTrait=typeMapper.mapSignature(fun.getOriginal()).getAsmMethod();
  PsiElement origin=descriptorToDeclaration(bindingContext,fun);
  MethodVisitor mv=v.newMethod(origin,flags,methodToGenerate.getName(),methodToGenerate.getDescriptor(),null,CodegenUtil.getExceptions(fun,typeMapper));
  AnnotationCodegen.forMethod(mv,typeMapper).genAnnotations(fun);
  if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {
    Type returnType=methodToGenerate.getReturnType();
    mv.visitCode();
    FrameMap frameMap=context.prepareFrame(typeMapper);
    ExpressionCodegen codegen=new ExpressionCodegen(mv,frameMap,returnType,context.intoFunction(inheritedFun),state,this);
    codegen.generateThisOrOuter(descriptor,false);
    Type[] argTypes=methodToGenerate.getArgumentTypes();
    Type[] originalArgTypes=methodInTrait.getArgumentTypes();
    InstructionAdapter iv=new InstructionAdapter(mv);
    iv.load(0,OBJECT_TYPE);
    for (int i=0, reg=1; i < argTypes.length; i++) {
      StackValue.local(reg,argTypes[i]).put(originalArgTypes[i],iv);
      reg+=argTypes[i].getSize();
    }
    Type type=getTraitImplThisParameterType(containingClass,typeMapper);
    String functionDescriptor=methodInTrait.getDescriptor().replace("(","(" + type.getDescriptor());
    iv.invokestatic(typeMapper.mapTraitImpl(containingClass).getInternalName(),methodToGenerate.getName(),functionDescriptor);
    StackValue.onStack(methodInTrait.getReturnType()).put(returnType,iv);
    iv.areturn(returnType);
    FunctionCodegen.endVisit(iv,"trait method",callableDescriptorToDeclaration(bindingContext,fun));
  }
  FunctionCodegen.generateBridgeIfNeeded(context,state,v,fun);
}
