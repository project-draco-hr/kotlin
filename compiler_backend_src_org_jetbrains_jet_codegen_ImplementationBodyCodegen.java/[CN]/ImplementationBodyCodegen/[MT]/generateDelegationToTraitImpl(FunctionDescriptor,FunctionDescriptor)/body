{
  DeclarationDescriptor containingDeclaration=fun.getContainingDeclaration();
  if (!(containingDeclaration instanceof ClassDescriptor)) {
    return;
  }
  ClassDescriptor containingClass=(ClassDescriptor)containingDeclaration;
  if (containingClass.getKind() != ClassKind.TRAIT) {
    return;
  }
  int flags=ACC_PUBLIC;
  Method function;
  Method functionOriginal;
  if (fun instanceof PropertyAccessorDescriptor) {
    PropertyDescriptor property=((PropertyAccessorDescriptor)fun).getCorrespondingProperty();
    PropertyDescriptor original=property.getOriginal();
    if (fun instanceof PropertyGetterDescriptor) {
      function=typeMapper.mapGetterSignature(property,OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();
      functionOriginal=typeMapper.mapGetterSignature(original,OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();
    }
 else     if (fun instanceof PropertySetterDescriptor) {
      function=typeMapper.mapSetterSignature(property,OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();
      functionOriginal=typeMapper.mapSetterSignature(original,OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();
    }
 else {
      throw new IllegalStateException("Accessor is neither getter, nor setter, what is it? " + fun);
    }
  }
 else {
    function=typeMapper.mapSignature(fun.getName(),fun).getAsmMethod();
    functionOriginal=typeMapper.mapSignature(fun.getName(),fun.getOriginal()).getAsmMethod();
  }
  MethodVisitor mv=v.newMethod(myClass,flags,function.getName(),function.getDescriptor(),null,null);
  AnnotationCodegen.forMethod(mv,state.getTypeMapper()).genAnnotations(fun);
  JvmMethodSignature jvmSignature=typeMapper.mapToCallableMethod(inheritedFun,false,isCallInsideSameClassAsDeclared(inheritedFun,context),isCallInsideSameModuleAsDeclared(inheritedFun,context),OwnerKind.IMPLEMENTATION).getSignature();
  JetMethodAnnotationWriter aw=JetMethodAnnotationWriter.visitAnnotation(mv);
  int kotlinFlags=getFlagsForVisibility(fun.getVisibility());
  if (fun instanceof PropertyAccessorDescriptor) {
    kotlinFlags|=JvmStdlibNames.FLAG_PROPERTY_BIT;
    aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());
    aw.writePropertyType(jvmSignature.getKotlinReturnType());
  }
 else {
    aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());
    aw.writeReturnType(jvmSignature.getKotlinReturnType());
  }
  kotlinFlags|=DescriptorKindUtils.kindToFlags(inheritedFun.getKind());
  aw.writeFlags(kotlinFlags);
  aw.visitEnd();
  if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {
    genStubCode(mv);
  }
 else   if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {
    mv.visitCode();
    FrameMap frameMap=context.prepareFrame(state.getTypeMapper());
    ExpressionCodegen codegen=new ExpressionCodegen(mv,frameMap,jvmSignature.getAsmMethod().getReturnType(),context,state);
    codegen.generateThisOrOuter(descriptor,false);
    Type[] argTypes=function.getArgumentTypes();
    List<Type> originalArgTypes=jvmSignature.getValueParameterTypes();
    InstructionAdapter iv=new InstructionAdapter(mv);
    iv.load(0,OBJECT_TYPE);
    for (int i=0, reg=1; i < argTypes.length; i++) {
      StackValue.local(reg,argTypes[i]).put(originalArgTypes.get(i),iv);
      reg+=argTypes[i].getSize();
    }
    Type type=getTraitImplThisParameterType(containingClass,typeMapper);
    String functionDescriptor=functionOriginal.getDescriptor().replace("(","(" + type.getDescriptor());
    Type tImplType=typeMapper.mapType(containingClass.getDefaultType(),JetTypeMapperMode.TRAIT_IMPL);
    iv.invokestatic(tImplType.getInternalName(),function.getName(),functionDescriptor);
    StackValue.onStack(functionOriginal.getReturnType()).put(function.getReturnType(),iv);
    iv.areturn(function.getReturnType());
    FunctionCodegen.endVisit(iv,"trait method",callableDescriptorToDeclaration(bindingContext,fun));
  }
  FunctionCodegen.generateBridgeIfNeeded(context,state,v,function,fun);
}
