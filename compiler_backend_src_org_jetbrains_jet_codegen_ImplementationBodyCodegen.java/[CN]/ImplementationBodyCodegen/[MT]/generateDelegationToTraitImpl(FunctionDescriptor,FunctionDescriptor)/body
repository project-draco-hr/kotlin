{
  functionCodegen.generateMethod(DelegationToTraitImpl(descriptorToDeclaration(traitFun),traitFun),typeMapper.mapSignature(inheritedFun),inheritedFun,new FunctionGenerationStrategy.CodegenBased<FunctionDescriptor>(state,inheritedFun){
    @Override public void doGenerateBody(    @NotNull ExpressionCodegen codegen,    @NotNull JvmMethodSignature signature){
      DeclarationDescriptor containingDeclaration=traitFun.getContainingDeclaration();
      if (!(containingDeclaration instanceof ClassDescriptor))       return;
      ClassDescriptor containingTrait=(ClassDescriptor)containingDeclaration;
      if (containingTrait.getKind() != ClassKind.TRAIT)       return;
      Method traitMethod=typeMapper.mapSignature(traitFun.getOriginal()).getAsmMethod();
      Type[] argTypes=signature.getAsmMethod().getArgumentTypes();
      Type[] originalArgTypes=traitMethod.getArgumentTypes();
      InstructionAdapter iv=codegen.v;
      iv.load(0,OBJECT_TYPE);
      for (int i=0, reg=1; i < argTypes.length; i++) {
        StackValue.local(reg,argTypes[i]).put(originalArgTypes[i],iv);
        reg+=argTypes[i].getSize();
      }
      Type type=getTraitImplThisParameterType(containingTrait,typeMapper);
      String desc=traitMethod.getDescriptor().replace("(","(" + type.getDescriptor());
      iv.invokestatic(typeMapper.mapTraitImpl(containingTrait).getInternalName(),traitMethod.getName(),desc);
      Type returnType=signature.getReturnType();
      StackValue.onStack(traitMethod.getReturnType()).put(returnType,iv);
      iv.areturn(returnType);
    }
  }
);
}
