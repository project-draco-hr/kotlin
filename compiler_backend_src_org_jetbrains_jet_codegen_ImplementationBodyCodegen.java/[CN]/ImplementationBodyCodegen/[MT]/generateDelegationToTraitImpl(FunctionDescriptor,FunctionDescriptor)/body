{
  DeclarationDescriptor containingDeclaration=fun.getContainingDeclaration();
  if (!(containingDeclaration instanceof ClassDescriptor)) {
    return;
  }
  ClassDescriptor containingClass=(ClassDescriptor)containingDeclaration;
  if (containingClass.getKind() != ClassKind.TRAIT) {
    return;
  }
  int flags=ACC_PUBLIC;
  TraitImplDelegateInfo delegateInfo=getTraitImplDelegateInfo(fun);
  Method methodToGenerate=delegateInfo.methodToGenerate;
  Method methodInTrait=delegateInfo.methodInTrait;
  PsiElement origin=descriptorToDeclaration(bindingContext,fun);
  MethodVisitor mv=v.newMethod(origin,flags,methodToGenerate.getName(),methodToGenerate.getDescriptor(),null,null);
  AnnotationCodegen.forMethod(mv,typeMapper).genAnnotations(fun);
  if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {
    genStubCode(mv);
  }
 else   if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {
    writeAnnotationForDelegateToTraitImpl(fun,inheritedFun,mv);
    Type returnType=methodToGenerate.getReturnType();
    mv.visitCode();
    FrameMap frameMap=context.prepareFrame(typeMapper);
    ExpressionCodegen codegen=new ExpressionCodegen(mv,frameMap,returnType,context.intoFunction(inheritedFun),state);
    codegen.generateThisOrOuter(descriptor,false);
    Type[] argTypes=methodToGenerate.getArgumentTypes();
    Type[] originalArgTypes=methodInTrait.getArgumentTypes();
    InstructionAdapter iv=new InstructionAdapter(mv);
    iv.load(0,OBJECT_TYPE);
    for (int i=0, reg=1; i < argTypes.length; i++) {
      StackValue.local(reg,argTypes[i]).put(originalArgTypes[i],iv);
      reg+=argTypes[i].getSize();
    }
    Type type=getTraitImplThisParameterType(containingClass,typeMapper);
    String functionDescriptor=methodInTrait.getDescriptor().replace("(","(" + type.getDescriptor());
    Type tImplType=typeMapper.mapType(containingClass.getDefaultType(),JetTypeMapperMode.TRAIT_IMPL);
    iv.invokestatic(tImplType.getInternalName(),methodToGenerate.getName(),functionDescriptor);
    StackValue.onStack(methodInTrait.getReturnType()).put(returnType,iv);
    iv.areturn(returnType);
    FunctionCodegen.endVisit(iv,"trait method",callableDescriptorToDeclaration(bindingContext,fun));
  }
  FunctionCodegen.generateBridgeIfNeeded(context,state,v,methodToGenerate,fun);
}
