{
  DeclarationDescriptor containingDeclaration=fun.getContainingDeclaration();
  if (!(containingDeclaration instanceof ClassDescriptor)) {
    return;
  }
  ClassDescriptor containingClass=(ClassDescriptor)containingDeclaration;
  if (containingClass.getKind() != ClassKind.TRAIT) {
    return;
  }
  int flags=ACC_PUBLIC;
  TraitImplDelegateInfo delegateInfo=getTraitImplDelegateInfo(fun);
  Method function=delegateInfo.delegate;
  Method functionOriginal=delegateInfo.original;
  MethodVisitor mv=v.newMethod(myClass,flags,function.getName(),function.getDescriptor(),null,null);
  AnnotationCodegen.forMethod(mv,state.getTypeMapper()).genAnnotations(fun);
  JvmMethodSignature jvmSignature=typeMapper.mapToCallableMethod(inheritedFun,false,isCallInsideSameClassAsDeclared(inheritedFun,context),isCallInsideSameModuleAsDeclared(inheritedFun,context),OwnerKind.IMPLEMENTATION).getSignature();
  writeAnnotationForDelegateToTraitImpl(fun,inheritedFun,mv,jvmSignature);
  if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {
    genStubCode(mv);
  }
 else   if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {
    mv.visitCode();
    FrameMap frameMap=context.prepareFrame(state.getTypeMapper());
    ExpressionCodegen codegen=new ExpressionCodegen(mv,frameMap,jvmSignature.getAsmMethod().getReturnType(),context,state);
    codegen.generateThisOrOuter(descriptor,false);
    Type[] argTypes=function.getArgumentTypes();
    List<Type> originalArgTypes=jvmSignature.getValueParameterTypes();
    InstructionAdapter iv=new InstructionAdapter(mv);
    iv.load(0,OBJECT_TYPE);
    for (int i=0, reg=1; i < argTypes.length; i++) {
      StackValue.local(reg,argTypes[i]).put(originalArgTypes.get(i),iv);
      reg+=argTypes[i].getSize();
    }
    Type type=getTraitImplThisParameterType(containingClass,typeMapper);
    String functionDescriptor=functionOriginal.getDescriptor().replace("(","(" + type.getDescriptor());
    Type tImplType=typeMapper.mapType(containingClass.getDefaultType(),JetTypeMapperMode.TRAIT_IMPL);
    iv.invokestatic(tImplType.getInternalName(),function.getName(),functionDescriptor);
    StackValue.onStack(functionOriginal.getReturnType()).put(function.getReturnType(),iv);
    iv.areturn(function.getReturnType());
    FunctionCodegen.endVisit(iv,"trait method",callableDescriptorToDeclaration(bindingContext,fun));
  }
  FunctionCodegen.generateBridgeIfNeeded(context,state,v,function,fun);
}
