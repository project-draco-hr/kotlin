{
  mv.visitCode();
  List<ValueParameterDescriptor> paramDescrs=constructorDescriptor != null ? constructorDescriptor.getValueParameters() : Collections.<ValueParameterDescriptor>emptyList();
  ConstructorFrameMap frameMap=new ConstructorFrameMap(callableMethod,constructorDescriptor,hasThis0);
  final InstructionAdapter iv=new InstructionAdapter(mv);
  ExpressionCodegen codegen=new ExpressionCodegen(mv,frameMap,Type.VOID_TYPE,constructorContext,state);
  Type classType=typeMapper.mapType(descriptor.getDefaultType(),MapTypeMode.IMPL);
  JvmClassName classname=JvmClassName.byType(classType);
  if (superCall == null) {
    genSimpleSuperCall(iv);
  }
 else   if (superCall instanceof JetDelegatorToSuperClass) {
    genSuperCallToDelegatorToSuperClass(iv);
  }
 else {
    ConstructorDescriptor constructorDescriptor1=(ConstructorDescriptor)bindingContext.get(BindingContext.REFERENCE_TARGET,((JetDelegatorToSuperCall)superCall).getCalleeExpression().getConstructorReferenceExpression());
    generateDelegatorToConstructorCall(iv,codegen,(JetDelegatorToSuperCall)superCall,constructorDescriptor1,frameMap,firstSuperArgument);
  }
  final ClassDescriptor outerDescriptor=typeMapper.getClosureAnnotator().getEclosingClassDescriptor(descriptor);
  final boolean hasOuterThis=typeMapper.hasThis0(descriptor) && outerDescriptor != null;
  if (hasOuterThis) {
    final Type type=typeMapper.mapType(outerDescriptor.getDefaultType(),MapTypeMode.VALUE);
    String interfaceDesc=type.getDescriptor();
    final String fieldName="this$0";
    v.newField(myClass,ACC_FINAL,fieldName,interfaceDesc,null,null);
    iv.load(0,classType);
    iv.load(frameMap.getOuterThisIndex(),type);
    iv.putfield(classname.getInternalName(),fieldName,interfaceDesc);
  }
  if (closure != null) {
    int k=hasOuterThis ? 2 : 1;
    if (closure.captureReceiver != null) {
      iv.load(0,JetTypeMapper.TYPE_OBJECT);
      iv.load(1,closure.captureReceiver);
      iv.putfield(typeMapper.mapType(descriptor.getDefaultType(),MapTypeMode.VALUE).getInternalName(),"receiver$0",closure.captureReceiver.getDescriptor());
      k+=closure.captureReceiver.getSize();
    }
    for (    DeclarationDescriptor varDescr : closure.closure.keySet()) {
      if (varDescr instanceof VariableDescriptor && !(varDescr instanceof PropertyDescriptor)) {
        Type sharedVarType=typeMapper.getSharedVarType(varDescr);
        if (sharedVarType == null) {
          sharedVarType=typeMapper.mapType(((VariableDescriptor)varDescr).getType(),MapTypeMode.VALUE);
        }
        iv.load(0,JetTypeMapper.TYPE_OBJECT);
        iv.load(k,StackValue.refType(sharedVarType));
        k+=StackValue.refType(sharedVarType).getSize();
        iv.putfield(typeMapper.mapType(descriptor.getDefaultType(),MapTypeMode.VALUE).getInternalName(),"$" + varDescr.getName(),sharedVarType.getDescriptor());
      }
    }
  }
  int n=0;
  for (  JetDelegationSpecifier specifier : myClass.getDelegationSpecifiers()) {
    if (specifier == superCall) {
      continue;
    }
    if (specifier instanceof JetDelegatorByExpressionSpecifier) {
      genCallToDelegatorByExpressionSpecifier(iv,codegen,classType,classname,n++,specifier);
    }
  }
  int curParam=0;
  List<JetParameter> constructorParameters=getPrimaryConstructorParameters();
  for (  JetParameter parameter : constructorParameters) {
    if (parameter.getValOrVarNode() != null) {
      VariableDescriptor descriptor=paramDescrs.get(curParam);
      Type type=typeMapper.mapType(descriptor.getType(),MapTypeMode.VALUE);
      iv.load(0,classType);
      iv.load(frameMap.getIndex(descriptor),type);
      iv.putfield(classname.getInternalName(),descriptor.getName().getName(),type.getDescriptor());
    }
    curParam++;
  }
  generateInitializers(codegen,iv,myClass.getDeclarations(),bindingContext,typeMapper);
  mv.visitInsn(RETURN);
  FunctionCodegen.endVisit(mv,"constructor",myClass);
  FunctionCodegen.generateDefaultIfNeeded(constructorContext,state,v,constructorMethod.getAsmMethod(),constructorDescriptor,OwnerKind.IMPLEMENTATION);
}
