{
  iv.load(0,OBJECT_TYPE);
  ResolvedCall<?> resolvedCall=getResolvedCallWithAssert(superCall,bindingContext);
  ConstructorDescriptor superConstructor=(ConstructorDescriptor)resolvedCall.getResultingDescriptor();
  CallableMethod superCallable=typeMapper.mapToCallableMethod(superConstructor);
  CallableMethod callable=typeMapper.mapToCallableMethod(constructorDescriptor);
  List<JvmMethodParameterSignature> superParameters=superCallable.getValueParameters();
  List<JvmMethodParameterSignature> parameters=callable.getValueParameters();
  int offset=1;
  int superIndex=0;
  for (  JvmMethodParameterSignature parameter : parameters) {
    if (superIndex >= superParameters.size())     break;
    JvmMethodParameterKind kind=parameter.getKind();
    Type type=parameter.getAsmType();
    if (superParameters.get(superIndex).getKind() == JvmMethodParameterKind.VALUE && kind == JvmMethodParameterKind.SUPER_CALL_PARAM) {
      break;
    }
    if (kind == JvmMethodParameterKind.SUPER_CALL_PARAM || kind == JvmMethodParameterKind.ENUM_NAME_OR_ORDINAL || (kind == JvmMethodParameterKind.OUTER && superConstructor.getContainingDeclaration().isInner())) {
      iv.load(offset,type);
      superIndex++;
    }
    offset+=type.getSize();
  }
  ArgumentGenerator argumentGenerator;
  if (isAnonymousObject(descriptor)) {
    List<JvmMethodParameterSignature> superValues=superParameters.subList(superIndex,superParameters.size());
    argumentGenerator=new ObjectSuperCallArgumentGenerator(superValues,iv,offset);
  }
 else {
    argumentGenerator=new CallBasedArgumentGenerator(codegen,codegen.defaultCallGenerator,superConstructor.getValueParameters(),superCallable.getValueParameterTypes());
  }
  codegen.invokeMethodWithArguments(superCallable,resolvedCall,StackValue.none(),codegen.defaultCallGenerator,argumentGenerator);
}
