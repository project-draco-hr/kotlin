{
  if (!(myClass instanceof JetClass) || ((JetClass)myClass).isTrait() || ((JetClass)myClass).hasModifier(JetTokens.ABSTRACT_KEYWORD))   return;
  HashSet<FunctionDescriptor> set=new HashSet<FunctionDescriptor>();
  getAbstractMethods(descriptor.getDefaultType(),set);
  for (  FunctionDescriptor fun : set) {
    int flags=Opcodes.ACC_PUBLIC;
    Method function=state.getTypeMapper().mapSignature(fun.getName(),fun);
    final MethodVisitor mv=v.visitMethod(flags,function.getName(),function.getDescriptor(),null,null);
    mv.visitCode();
    codegen.generateThisOrOuter(descriptor);
    Type[] argTypes=function.getArgumentTypes();
    InstructionAdapter iv=new InstructionAdapter(mv);
    iv.load(0,JetTypeMapper.TYPE_OBJECT);
    for (int i=0, reg=1; i < argTypes.length; i++) {
      Type argType=argTypes[i];
      iv.load(reg,argType);
      reg+=argType.getSize();
    }
    ClassDescriptor containingDeclaration=(ClassDescriptor)fun.getContainingDeclaration();
    JetType jetType=TraitImplBodyCodegen.getSuperClass(containingDeclaration,state.getBindingContext());
    Type type=state.getTypeMapper().mapType(jetType);
    if (type.getInternalName().equals("java/lang/Object")) {
      jetType=containingDeclaration.getDefaultType();
      type=state.getTypeMapper().mapType(jetType);
    }
    String fdescriptor=function.getDescriptor().replace("(","(" + type.getDescriptor());
    iv.invokestatic(state.getTypeMapper().jvmName((ClassDescriptor)fun.getContainingDeclaration(),OwnerKind.TRAIT_IMPL),function.getName(),fdescriptor);
    iv.areturn(function.getReturnType());
    mv.visitMaxs(0,0);
    mv.visitEnd();
  }
}
