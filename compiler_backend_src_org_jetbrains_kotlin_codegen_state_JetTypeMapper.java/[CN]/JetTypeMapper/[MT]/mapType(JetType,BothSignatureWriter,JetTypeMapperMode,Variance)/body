{
  Type known=mapBuiltinType(jetType);
  boolean projectionsAllowed=kind != JetTypeMapperMode.SUPER_TYPE;
  if (known != null) {
    if (kind == JetTypeMapperMode.VALUE || kind == JetTypeMapperMode.VALUE_FOR_ANNOTATION) {
      return mapKnownAsmType(jetType,known,signatureVisitor,howThisTypeIsUsed);
    }
 else     if (kind == JetTypeMapperMode.TYPE_PARAMETER || kind == JetTypeMapperMode.SUPER_TYPE || kind == JetTypeMapperMode.TYPE_PARAMETER_FOR_ANNOTATION) {
      return mapKnownAsmType(jetType,boxType(known),signatureVisitor,howThisTypeIsUsed,projectionsAllowed);
    }
 else     if (kind == JetTypeMapperMode.IMPL) {
      return mapKnownAsmType(jetType,known,signatureVisitor,howThisTypeIsUsed);
    }
 else {
      throw new IllegalStateException("unknown kind: " + kind);
    }
  }
  TypeConstructor constructor=jetType.getConstructor();
  DeclarationDescriptor descriptor=constructor.getDeclarationDescriptor();
  if (constructor instanceof IntersectionTypeConstructor) {
    jetType=CommonSupertypes.commonSupertype(new ArrayList<JetType>(constructor.getSupertypes()));
  }
  if (descriptor == null) {
    throw new UnsupportedOperationException("no descriptor for type constructor of " + jetType);
  }
  if (ErrorUtils.isError(descriptor)) {
    if (classBuilderMode != ClassBuilderMode.LIGHT_CLASSES) {
      throw new IllegalStateException(generateErrorMessageForErrorType(jetType,descriptor));
    }
    Type asmType=Type.getObjectType("error/NonExistentClass");
    if (signatureVisitor != null) {
      signatureVisitor.writeAsmType(asmType);
    }
    return asmType;
  }
  if (descriptor instanceof ClassDescriptor && KotlinBuiltIns.isArray(jetType)) {
    if (jetType.getArguments().size() != 1) {
      throw new UnsupportedOperationException("arrays must have one type argument");
    }
    TypeProjection memberProjection=jetType.getArguments().get(0);
    JetType memberType=memberProjection.getType();
    Type arrayElementType;
    if (memberProjection.getProjectionKind() == Variance.IN_VARIANCE) {
      arrayElementType=AsmTypes.OBJECT_TYPE;
      if (signatureVisitor != null) {
        signatureVisitor.writeArrayType();
        signatureVisitor.writeAsmType(arrayElementType);
        signatureVisitor.writeArrayEnd();
      }
    }
 else {
      arrayElementType=boxType(mapType(memberType,kind));
      if (signatureVisitor != null) {
        signatureVisitor.writeArrayType();
        JetTypeMapperMode newMode=kind.isForAnnotation() ? JetTypeMapperMode.TYPE_PARAMETER_FOR_ANNOTATION : JetTypeMapperMode.TYPE_PARAMETER;
        mapType(memberType,signatureVisitor,newMode,memberProjection.getProjectionKind());
        signatureVisitor.writeArrayEnd();
      }
    }
    return Type.getType("[" + arrayElementType.getDescriptor());
  }
  if (descriptor instanceof ClassDescriptor) {
    FqName companionObjectMappedFqName=IntrinsicObjects.mapType((ClassDescriptor)descriptor);
    if (companionObjectMappedFqName != null) {
      Type asmType=asmTypeByFqNameWithoutInnerClasses(companionObjectMappedFqName);
      if (signatureVisitor != null) {
        signatureVisitor.writeAsmType(asmType);
      }
      return asmType;
    }
    Type asmType=kind.isForAnnotation() && KotlinBuiltIns.isKClass((ClassDescriptor)descriptor) ? AsmTypes.JAVA_CLASS_TYPE : computeAsmType((ClassDescriptor)descriptor.getOriginal());
    writeGenericType(signatureVisitor,asmType,jetType,howThisTypeIsUsed,projectionsAllowed);
    return asmType;
  }
  if (descriptor instanceof TypeParameterDescriptor) {
    TypeParameterDescriptor typeParameterDescriptor=(TypeParameterDescriptor)descriptor;
    Type type=mapType(typeParameterDescriptor.getUpperBounds().iterator().next(),kind);
    if (signatureVisitor != null) {
      signatureVisitor.writeTypeVariable(typeParameterDescriptor.getName(),type);
    }
    return type;
  }
  throw new UnsupportedOperationException("Unknown type " + jetType);
}
