{
  assertRecursionDepth(recursionDepth,originalProjection,substitution);
  JetType type=originalProjection.getType();
  if (KotlinBuiltIns.getInstance().isNothing(type) || type.isError())   return originalProjection;
  TypeProjection replacement=substitution.get(type.getConstructor());
  if (replacement != null) {
    TypeParameterDescriptor typeParameter=(TypeParameterDescriptor)type.getConstructor().getDeclarationDescriptor();
switch (conflictType(originalProjection.getProjectionKind(),replacement.getProjectionKind())) {
case OUT_IN_IN_POSITION:
      throw new SubstitutionException("Out-projection in in-position");
case IN_IN_OUT_POSITION:
    return SubstitutionUtils.makeStarProjection(typeParameter);
case NO_CONFLICT:
  boolean resultingIsNullable=type.isNullable() || replacement.getType().isNullable();
JetType substitutedType=TypeUtils.makeNullableAsSpecified(replacement.getType(),resultingIsNullable);
Variance resultingProjectionKind=combine(originalProjection.getProjectionKind(),replacement.getProjectionKind());
return new TypeProjectionImpl(resultingProjectionKind,substitutedType);
default :
throw new IllegalStateException();
}
}
 else {
List<TypeProjection> substitutedArguments=substituteTypeArguments(type.getConstructor().getParameters(),type.getArguments(),recursionDepth);
JetType substitutedType=new JetTypeImpl(type.getAnnotations(),type.getConstructor(),type.isNullable(),substitutedArguments,new SubstitutingScope(type.getMemberScope(),this));
return new TypeProjectionImpl(originalProjection.getProjectionKind(),substitutedType);
}
}
