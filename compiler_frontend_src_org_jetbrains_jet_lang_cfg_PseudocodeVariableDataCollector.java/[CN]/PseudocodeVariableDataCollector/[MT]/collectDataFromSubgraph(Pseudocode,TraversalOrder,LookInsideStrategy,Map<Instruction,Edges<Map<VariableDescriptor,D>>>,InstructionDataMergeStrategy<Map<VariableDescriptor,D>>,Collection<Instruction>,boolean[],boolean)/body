{
  List<Instruction> instructions=getInstructions(pseudocode,traversalOrder);
  Instruction startInstruction=getStartInstruction(pseudocode,traversalOrder);
  for (  Instruction instruction : instructions) {
    boolean isStart=isStartInstruction(instruction,traversalOrder);
    if (!isLocal && isStart)     continue;
    Collection<Instruction> allPreviousInstructions;
    Collection<Instruction> previousInstructions=getPreviousInstruction(instruction,traversalOrder);
    if (instruction == startInstruction && !previousSubGraphInstructions.isEmpty()) {
      allPreviousInstructions=Lists.newArrayList(previousInstructions);
      allPreviousInstructions.addAll(previousSubGraphInstructions);
    }
 else {
      allPreviousInstructions=previousInstructions;
    }
    if (shouldLookInside(instruction,lookInside)) {
      LocalFunctionDeclarationInstruction functionInstruction=(LocalFunctionDeclarationInstruction)instruction;
      Pseudocode subroutinePseudocode=functionInstruction.getBody();
      collectDataFromSubgraph(subroutinePseudocode,traversalOrder,lookInside,edgesMap,instructionDataMergeStrategy,previousInstructions,changed,true);
      Instruction lastInstruction=getLastInstruction(subroutinePseudocode,traversalOrder);
      Edges<Map<VariableDescriptor,D>> previousValue=edgesMap.get(instruction);
      Edges<Map<VariableDescriptor,D>> newValue=edgesMap.get(lastInstruction);
      if (!previousValue.equals(newValue)) {
        changed[0]=true;
        edgesMap.put(instruction,newValue);
      }
      continue;
    }
    Edges<Map<VariableDescriptor,D>> previousDataValue=edgesMap.get(instruction);
    Collection<Map<VariableDescriptor,D>> incomingEdgesData=Sets.newHashSet();
    for (    Instruction previousInstruction : allPreviousInstructions) {
      Edges<Map<VariableDescriptor,D>> previousData=edgesMap.get(previousInstruction);
      if (previousData != null) {
        incomingEdgesData.add(previousData.out);
      }
    }
    Edges<Map<VariableDescriptor,D>> mergedData=instructionDataMergeStrategy.execute(instruction,incomingEdgesData);
    if (!mergedData.equals(previousDataValue)) {
      changed[0]=true;
      edgesMap.put(instruction,mergedData);
    }
  }
}
