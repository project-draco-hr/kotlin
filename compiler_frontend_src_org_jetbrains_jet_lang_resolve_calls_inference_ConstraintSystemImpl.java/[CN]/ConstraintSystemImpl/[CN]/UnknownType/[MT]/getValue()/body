{
  if (beingComputed) {
    throw new LoopInTypeVariableConstraintsException();
  }
  if (value == null) {
    beingComputed=true;
    JetTypeChecker typeChecker=JetTypeChecker.INSTANCE;
    try {
      if (positionVariance == Variance.IN_VARIANCE) {
        throw new UnsupportedOperationException();
      }
 else {
        Set<TypeValue> lowerBounds=getLowerBounds();
        if (!lowerBounds.isEmpty()) {
          Set<JetType> types=getTypes(lowerBounds);
          JetType commonSupertype=CommonSupertypes.commonSupertype(types);
          for (          TypeValue upperBound : getUpperBounds()) {
            if (!typeChecker.isSubtypeOf(commonSupertype,upperBound.getValue().getType())) {
              value=null;
            }
          }
          listener.log("minimal solution from lowerbounds for " + this + " is "+ commonSupertype);
          value=new KnownType(commonSupertype);
        }
 else {
          Set<TypeValue> upperBounds=getUpperBounds();
          Set<JetType> types=getTypes(upperBounds);
          JetType intersect=TypeUtils.intersect(typeChecker,types);
          value=new KnownType(intersect);
        }
      }
    }
  finally {
      beingComputed=false;
    }
  }
  return value;
}
