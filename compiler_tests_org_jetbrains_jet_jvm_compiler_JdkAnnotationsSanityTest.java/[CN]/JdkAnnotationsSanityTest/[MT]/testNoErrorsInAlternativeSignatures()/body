{
  InjectorForJavaSemanticServices injector=new InjectorForJavaSemanticServices(getProject());
  final BindingContext bindingContext=injector.getBindingTrace().getBindingContext();
  JavaDescriptorResolver javaDescriptorResolver=injector.getJavaDescriptorResolver();
  final Map<DeclarationDescriptor,String> errors=Maps.newHashMap();
  Iterable<FqName> affectedClasses=getAffectedClasses(kotlinAnnotationsRoot);
  AlternativeSignatureErrorFindingVisitor visitor=new AlternativeSignatureErrorFindingVisitor(bindingContext,errors);
  for (  FqName javaClass : affectedClasses) {
    ClassDescriptor topLevelClass=javaDescriptorResolver.resolveClass(javaClass);
    NamespaceDescriptor topLevelNamespace=javaDescriptorResolver.resolveNamespace(javaClass);
    assertNotNull("Class has annotation, but it is not found: " + javaClass,topLevelClass);
    topLevelClass.acceptVoid(visitor);
    if (topLevelNamespace != null) {
      topLevelNamespace.acceptVoid(visitor);
    }
  }
  if (!errors.isEmpty()) {
    StringBuilder sb=new StringBuilder("Error(s) in JDK alternative signatures: \n");
    for (    Map.Entry<DeclarationDescriptor,String> entry : errors.entrySet()) {
      sb.append(DescriptorRenderer.TEXT.render(entry.getKey())).append(" : ").append(entry.getValue()).append("\n");
    }
    fail(sb.toString());
  }
}
