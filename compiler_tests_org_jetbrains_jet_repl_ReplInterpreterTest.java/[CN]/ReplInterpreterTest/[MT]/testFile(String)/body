{
  CompilerConfiguration configuration=CompileCompilerDependenciesTest.compilerConfigurationForTests(ConfigurationKind.JDK_ONLY,TestJdkKind.FULL_JDK);
  configuration.add(JVMConfigurationKeys.CLASSPATH_KEY,new File("out/production/runtime"));
  ReplInterpreter repl=new ReplInterpreter(disposable,configuration);
  ReplSessionTestFile file=ReplSessionTestFile.load(new File("compiler/testData/repl/" + relativePath));
  for (  ReplSessionTestFile.OneLine t : file.getLines()) {
    String code=t.getCode();
    String expected=StringUtil.convertLineSeparators(t.getExpected()).replaceFirst("\n$","");
    ReplSessionTestFile.MatchType matchType=t.getMatchType();
    ReplInterpreter.LineResult lineResult=repl.eval(code);
    Object actual;
    if (lineResult.getType() == ReplInterpreter.LineResultType.SUCCESS) {
      actual=lineResult.getValue();
    }
 else     if (lineResult.getType() == ReplInterpreter.LineResultType.INCOMPLETE) {
      actual="incomplete";
    }
 else {
      actual=lineResult.getErrorText();
    }
    String actualString=StringUtil.convertLineSeparators(actual != null ? actual.toString() : "null").replaceFirst("\n$","");
    if (matchType == ReplSessionTestFile.MatchType.EQUALS) {
      Assert.assertEquals("after evaluation of: " + code,expected,actualString);
    }
 else     if (matchType == ReplSessionTestFile.MatchType.SUBSTRING) {
      Assert.assertTrue("must contain substring: " + expected + ", actual: "+ actualString,actualString.contains(expected));
    }
  }
}
