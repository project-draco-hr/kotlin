{
  JetSimpleNameExpression reference=expression.getCallableReference();
  boolean[] result=new boolean[1];
  CallableDescriptor descriptor=resolveCallableReferenceTarget(lhsType,context.replaceContextDependency(INDEPENDENT),expression,result);
  if (!result[0]) {
    context.trace.report(UNRESOLVED_REFERENCE.on(reference,reference));
  }
  if (descriptor == null)   return null;
  ReceiverParameterDescriptor extensionReceiver=descriptor.getExtensionReceiverParameter();
  ReceiverParameterDescriptor dispatchReceiver=descriptor.getDispatchReceiverParameter();
  if (extensionReceiver != null && dispatchReceiver != null && descriptor instanceof CallableMemberDescriptor) {
    context.trace.report(EXTENSION_IN_CLASS_REFERENCE_NOT_ALLOWED.on(reference,(CallableMemberDescriptor)descriptor));
    return null;
  }
  JetType receiverType=null;
  if (extensionReceiver != null) {
    receiverType=extensionReceiver.getType();
  }
 else   if (dispatchReceiver != null) {
    receiverType=dispatchReceiver.getType();
  }
  boolean isExtension=extensionReceiver != null;
  if (descriptor instanceof FunctionDescriptor) {
    return createFunctionReferenceType(expression,context,(FunctionDescriptor)descriptor,receiverType);
  }
 else   if (descriptor instanceof PropertyDescriptor) {
    return createPropertyReferenceType(expression,context,(PropertyDescriptor)descriptor,receiverType,isExtension);
  }
 else   if (descriptor instanceof VariableDescriptor) {
    context.trace.report(UNSUPPORTED.on(reference,"References to variables aren't supported yet"));
    return null;
  }
  throw new UnsupportedOperationException("Callable reference resolved to an unsupported descriptor: " + descriptor);
}
