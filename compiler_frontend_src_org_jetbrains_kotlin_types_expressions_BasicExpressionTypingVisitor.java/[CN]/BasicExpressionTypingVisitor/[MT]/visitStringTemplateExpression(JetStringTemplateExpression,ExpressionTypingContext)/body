{
  final ExpressionTypingContext context=contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE).replaceContextDependency(INDEPENDENT);
class StringTemplateVisitor extends JetVisitorVoid {
    private JetTypeInfo typeInfo=TypeInfoFactoryPackage.noTypeInfo(context);
    @Override public void visitStringTemplateEntryWithExpression(    @NotNull JetStringTemplateEntryWithExpression entry){
      JetExpression entryExpression=entry.getExpression();
      if (entryExpression != null) {
        typeInfo=facade.getTypeInfo(entryExpression,context.replaceDataFlowInfo(typeInfo.getDataFlowInfo()));
      }
    }
    @Override public void visitEscapeStringTemplateEntry(    @NotNull JetEscapeStringTemplateEntry entry){
      CompileTimeConstantChecker.CharacterWithDiagnostic value=CompileTimeConstantChecker.escapedStringToCharacter(entry.getText(),entry);
      Diagnostic diagnostic=value.getDiagnostic();
      if (diagnostic != null) {
        context.trace.report(diagnostic);
      }
    }
  }
  StringTemplateVisitor visitor=new StringTemplateVisitor();
  for (  JetStringTemplateEntry entry : expression.getEntries()) {
    entry.accept(visitor);
  }
  components.constantExpressionEvaluator.evaluateExpression(expression,context.trace,contextWithExpectedType.expectedType);
  return DataFlowUtils.checkType(visitor.typeInfo.replaceType(components.builtIns.getStringType()),expression,contextWithExpectedType);
}
