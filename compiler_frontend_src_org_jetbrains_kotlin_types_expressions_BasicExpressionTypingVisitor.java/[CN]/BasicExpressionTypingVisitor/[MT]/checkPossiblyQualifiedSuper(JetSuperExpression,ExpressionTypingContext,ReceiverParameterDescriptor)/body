{
  JetType result=null;
  JetType thisType=thisReceiver.getType();
  Collection<JetType> supertypes=thisType.getConstructor().getSupertypes();
  TypeSubstitutor substitutor=TypeSubstitutor.create(thisType);
  JetTypeReference superTypeQualifier=expression.getSuperTypeQualifier();
  if (superTypeQualifier != null) {
    JetTypeElement typeElement=superTypeQualifier.getTypeElement();
    DeclarationDescriptor classifierCandidate=null;
    JetType supertype=null;
    PsiElement redundantTypeArguments=null;
    if (typeElement instanceof JetUserType) {
      JetUserType userType=(JetUserType)typeElement;
      if (userType.getTypeArguments().isEmpty()) {
        classifierCandidate=components.typeResolver.resolveClass(context.scope,userType,context.trace);
      }
 else {
        supertype=components.typeResolver.resolveType(context.scope,superTypeQualifier,context.trace,true);
        redundantTypeArguments=userType.getTypeArgumentList();
      }
    }
 else {
      supertype=components.typeResolver.resolveType(context.scope,superTypeQualifier,context.trace,true);
    }
    if (supertype != null) {
      if (supertypes.contains(supertype)) {
        result=supertype;
      }
    }
 else     if (classifierCandidate instanceof ClassDescriptor) {
      ClassDescriptor superclass=(ClassDescriptor)classifierCandidate;
      for (      JetType declaredSupertype : supertypes) {
        if (declaredSupertype.getConstructor().equals(superclass.getTypeConstructor())) {
          result=substitutor.safeSubstitute(declaredSupertype,Variance.INVARIANT);
          break;
        }
      }
    }
    boolean validClassifier=classifierCandidate != null && !ErrorUtils.isError(classifierCandidate);
    boolean validType=supertype != null && !supertype.isError();
    if (result == null && (validClassifier || validType)) {
      context.trace.report(NOT_A_SUPERTYPE.on(superTypeQualifier));
    }
 else     if (redundantTypeArguments != null) {
      context.trace.report(TYPE_ARGUMENTS_REDUNDANT_IN_SUPER_QUALIFIER.on(redundantTypeArguments));
    }
  }
 else {
    if (UnqualifiedSuperPackage.isPossiblyAmbiguousUnqualifiedSuper(expression,supertypes)) {
      Collection<JetType> supertypesResolvedFromContext=UnqualifiedSuperPackage.resolveUnqualifiedSuperFromExpressionContext(expression,supertypes,components.builtIns.getAnyType());
      if (supertypesResolvedFromContext.size() == 1) {
        JetType singleResolvedType=supertypesResolvedFromContext.iterator().next();
        result=substitutor.substitute(singleResolvedType,Variance.INVARIANT);
      }
 else       if (supertypesResolvedFromContext.isEmpty()) {
        result=components.builtIns.getAnyType();
      }
 else {
        context.trace.report(AMBIGUOUS_SUPER.on(expression));
      }
    }
 else {
      JetType type=supertypes.isEmpty() ? components.builtIns.getAnyType() : supertypes.iterator().next();
      result=substitutor.substitute(type,Variance.INVARIANT);
    }
  }
  if (result != null) {
    if (DescriptorUtils.isInterface(thisType.getConstructor().getDeclarationDescriptor())) {
      if (DescriptorUtils.isClass(result.getConstructor().getDeclarationDescriptor())) {
        context.trace.report(SUPERCLASS_NOT_ACCESSIBLE_FROM_INTERFACE.on(expression));
      }
    }
    context.trace.recordType(expression.getInstanceReference(),result);
    context.trace.record(BindingContext.REFERENCE_TARGET,expression.getInstanceReference(),result.getConstructor().getDeclarationDescriptor());
  }
  BindingContextUtilPackage.recordScope(context.trace,context.scope,superTypeQualifier);
  return result;
}
