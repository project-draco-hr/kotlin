{
  return pseudocodeVariableDataCollector.collectData(TraversalOrder.BACKWARD,true,new InstructionDataMergeStrategy<VariableUseState>(){
    @NotNull @Override public Edges<Map<VariableDescriptor,VariableUseState>> invoke(    @NotNull Instruction instruction,    @NotNull Collection<? extends Map<VariableDescriptor,VariableUseState>> incomingEdgesData){
      Map<VariableDescriptor,VariableUseState> enterResult=Maps.newHashMap();
      for (      Map<VariableDescriptor,VariableUseState> edgeData : incomingEdgesData) {
        for (        Map.Entry<VariableDescriptor,VariableUseState> entry : edgeData.entrySet()) {
          VariableDescriptor variableDescriptor=entry.getKey();
          VariableUseState variableUseState=entry.getValue();
          enterResult.put(variableDescriptor,variableUseState.merge(enterResult.get(variableDescriptor)));
        }
      }
      VariableDescriptor variableDescriptor=PseudocodeUtil.extractVariableDescriptorIfAny(instruction,true,bindingContext);
      if (variableDescriptor == null || (!(instruction instanceof ReadValueInstruction) && !(instruction instanceof WriteValueInstruction))) {
        return new Edges<Map<VariableDescriptor,VariableUseState>>(enterResult,enterResult);
      }
      Map<VariableDescriptor,VariableUseState> exitResult=Maps.newHashMap(enterResult);
      if (instruction instanceof ReadValueInstruction) {
        exitResult.put(variableDescriptor,VariableUseState.READ);
      }
 else {
        VariableUseState variableUseState=enterResult.get(variableDescriptor);
        if (variableUseState == null) {
          variableUseState=VariableUseState.UNUSED;
        }
switch (variableUseState) {
case UNUSED:
case ONLY_WRITTEN_NEVER_READ:
          exitResult.put(variableDescriptor,VariableUseState.ONLY_WRITTEN_NEVER_READ);
        break;
case WRITTEN_AFTER_READ:
case READ:
      exitResult.put(variableDescriptor,VariableUseState.WRITTEN_AFTER_READ);
  }
}
return new Edges<Map<VariableDescriptor,VariableUseState>>(enterResult,exitResult);
}
}
);
}
