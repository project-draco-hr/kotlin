{
  JetSimpleNameExpression reference=expression.getCallableReference();
  if (lhsType == null) {
    return resolveCallableNotCheckingArguments(reference,NO_RECEIVER,context,result);
  }
  ClassifierDescriptor classifier=lhsType.getConstructor().getDeclarationDescriptor();
  if (!(classifier instanceof ClassDescriptor)) {
    context.trace.report(CALLABLE_REFERENCE_LHS_NOT_A_CLASS.on(expression));
    return null;
  }
  JetScope staticScope=((ClassDescriptor)classifier).getStaticScope();
  TemporaryTraceAndCache temporaryForStatic=TemporaryTraceAndCache.create(context,"trace to resolve callable reference in static scope",reference);
  CallableDescriptor possibleStatic=resolveCallableNotCheckingArguments(reference,NO_RECEIVER,context.replaceTraceAndCache(temporaryForStatic).replaceScope(staticScope),result);
  if (result[0]) {
    temporaryForStatic.commit();
    return possibleStatic;
  }
  JetScope staticNestedClasses=getStaticNestedClassesScope((ClassDescriptor)classifier);
  TemporaryTraceAndCache temporaryForNested=TemporaryTraceAndCache.create(context,"trace to resolve callable reference in static nested classes scope",reference);
  CallableDescriptor possibleNestedClassConstructor=resolveCallableNotCheckingArguments(reference,NO_RECEIVER,context.replaceTraceAndCache(temporaryForNested).replaceScope(staticNestedClasses),result);
  if (result[0]) {
    temporaryForNested.commit();
    return possibleNestedClassConstructor;
  }
  ReceiverValue receiver=new TransientReceiver(lhsType);
  TemporaryTraceAndCache temporaryWithReceiver=TemporaryTraceAndCache.create(context,"trace to resolve callable reference with receiver",reference);
  CallableDescriptor descriptor=resolveCallableNotCheckingArguments(reference,receiver,context.replaceTraceAndCache(temporaryWithReceiver),result);
  if (result[0]) {
    temporaryWithReceiver.commit();
    return descriptor;
  }
  return null;
}
