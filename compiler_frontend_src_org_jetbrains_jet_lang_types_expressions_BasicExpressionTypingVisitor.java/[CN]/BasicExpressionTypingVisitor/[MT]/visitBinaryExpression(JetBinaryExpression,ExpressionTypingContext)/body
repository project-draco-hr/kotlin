{
  ExpressionTypingContext context=contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE);
  JetSimpleNameExpression operationSign=expression.getOperationReference();
  JetExpression left=expression.getLeft();
  JetExpression right=expression.getRight();
  IElementType operationType=operationSign.getReferencedNameElementType();
  JetTypeInfo leftTypeInfo=left != null ? facade.getTypeInfo(left,context) : JetTypeInfo.create(null,context.dataFlowInfo);
  JetType result=null;
  DataFlowInfo dataFlowInfo=context.dataFlowInfo;
  if (operationType == JetTokens.IDENTIFIER) {
    Name referencedName=operationSign.getReferencedNameAsName();
    JetTypeInfo typeInfo=getTypeInfoForBinaryCall(context.scope,referencedName,context,expression);
    result=typeInfo.getType();
    dataFlowInfo=typeInfo.getDataFlowInfo();
  }
 else   if (OperatorConventions.BINARY_OPERATION_NAMES.containsKey(operationType)) {
    JetTypeInfo typeInfo=getTypeInfoForBinaryCall(context.scope,OperatorConventions.BINARY_OPERATION_NAMES.get(operationType),context,expression);
    result=typeInfo.getType();
    dataFlowInfo=typeInfo.getDataFlowInfo();
  }
 else   if (operationType == JetTokens.EQ) {
    result=visitAssignment(expression,contextWithExpectedType);
  }
 else   if (OperatorConventions.ASSIGNMENT_OPERATIONS.containsKey(operationType)) {
    result=visitAssignmentOperation(expression,contextWithExpectedType);
  }
 else   if (OperatorConventions.COMPARISON_OPERATIONS.contains(operationType)) {
    JetTypeInfo typeInfo=getTypeInfoForBinaryCall(context.scope,OperatorConventions.COMPARE_TO,context,expression);
    dataFlowInfo=typeInfo.getDataFlowInfo();
    JetType compareToReturnType=typeInfo.getType();
    if (compareToReturnType != null && !ErrorUtils.isErrorType(compareToReturnType)) {
      TypeConstructor constructor=compareToReturnType.getConstructor();
      KotlinBuiltIns builtIns=KotlinBuiltIns.getInstance();
      TypeConstructor intTypeConstructor=builtIns.getInt().getTypeConstructor();
      if (constructor.equals(intTypeConstructor)) {
        result=builtIns.getBooleanType();
      }
 else {
        context.trace.report(COMPARE_TO_TYPE_MISMATCH.on(operationSign,compareToReturnType));
      }
    }
  }
 else {
    JetType booleanType=KotlinBuiltIns.getInstance().getBooleanType();
    if (OperatorConventions.EQUALS_OPERATIONS.contains(operationType)) {
      if (right != null && left != null) {
        ExpressionReceiver receiver=ExpressionTypingUtils.safeGetExpressionReceiver(facade,left,context);
        dataFlowInfo=leftTypeInfo.getDataFlowInfo();
        ExpressionTypingContext contextWithDataFlow=context.replaceDataFlowInfo(dataFlowInfo);
        OverloadResolutionResults<FunctionDescriptor> resolutionResults=resolveFakeCall(contextWithDataFlow,receiver,OperatorConventions.EQUALS,KotlinBuiltIns.getInstance().getNullableAnyType());
        dataFlowInfo=facade.getTypeInfo(right,contextWithDataFlow).getDataFlowInfo();
        if (resolutionResults.isSuccess()) {
          FunctionDescriptor equals=resolutionResults.getResultingCall().getResultingDescriptor();
          context.trace.record(REFERENCE_TARGET,operationSign,equals);
          context.trace.record(RESOLVED_CALL,operationSign,resolutionResults.getResultingCall());
          if (ensureBooleanResult(operationSign,OperatorConventions.EQUALS,equals.getReturnType(),context)) {
            ensureNonemptyIntersectionOfOperandTypes(expression,context);
          }
        }
 else {
          if (resolutionResults.isAmbiguity()) {
            context.trace.report(OVERLOAD_RESOLUTION_AMBIGUITY.on(operationSign,resolutionResults.getResultingCalls()));
          }
 else {
            context.trace.report(EQUALS_MISSING.on(operationSign));
          }
        }
      }
      result=booleanType;
    }
 else     if (operationType == JetTokens.EQEQEQ || operationType == JetTokens.EXCLEQEQEQ) {
      ensureNonemptyIntersectionOfOperandTypes(expression,context);
      result=booleanType;
    }
 else     if (OperatorConventions.IN_OPERATIONS.contains(operationType)) {
      if (right == null) {
        return JetTypeInfo.create(null,dataFlowInfo);
      }
      JetTypeInfo typeInfo=checkInExpression(expression,expression.getOperationReference(),left,right,context);
      dataFlowInfo=typeInfo.getDataFlowInfo();
      result=typeInfo.getType();
    }
 else     if (OperatorConventions.BOOLEAN_OPERATIONS.containsKey(operationType)) {
      JetType leftType=leftTypeInfo.getType();
      dataFlowInfo=leftTypeInfo.getDataFlowInfo();
      WritableScopeImpl leftScope=newWritableScopeImpl(context,"Left scope of && or ||");
      DataFlowInfo flowInfoLeft=DataFlowUtils.extractDataFlowInfoFromCondition(left,operationType == JetTokens.ANDAND,context).and(dataFlowInfo);
      WritableScopeImpl rightScope=operationType == JetTokens.ANDAND ? leftScope : newWritableScopeImpl(context,"Right scope of && or ||");
      JetType rightType=right == null ? null : facade.getTypeInfo(right,context.replaceDataFlowInfo(flowInfoLeft).replaceScope(rightScope)).getType();
      if (left != null && leftType != null && !isBoolean(leftType)) {
        context.trace.report(TYPE_MISMATCH.on(left,booleanType,leftType));
      }
      if (rightType != null && !isBoolean(rightType)) {
        context.trace.report(TYPE_MISMATCH.on(right,booleanType,rightType));
      }
      result=booleanType;
    }
 else     if (operationType == JetTokens.ELVIS) {
      JetType leftType=leftTypeInfo.getType();
      dataFlowInfo=leftTypeInfo.getDataFlowInfo();
      if (left != null && leftType != null) {
        if (isKnownToBeNotNull(left,leftType,context)) {
          context.trace.report(USELESS_ELVIS.on(left,leftType));
        }
        ExpressionTypingContext newContext=contextWithExpectedType.replaceDataFlowInfo(dataFlowInfo).replaceScope(context.scope);
        JetType rightType=right == null ? null : facade.getTypeInfo(right,newContext).getType();
        if (rightType != null) {
          DataFlowUtils.checkType(TypeUtils.makeNullableAsSpecified(leftType,rightType.isNullable()),left,contextWithExpectedType);
          return JetTypeInfo.create(TypeUtils.makeNullableAsSpecified(CommonSupertypes.commonSupertype(Arrays.asList(leftType,rightType)),rightType.isNullable()),dataFlowInfo);
        }
      }
    }
 else {
      context.trace.report(UNSUPPORTED.on(operationSign,"Unknown operation"));
    }
  }
  return DataFlowUtils.checkType(result,expression,contextWithExpectedType,dataFlowInfo);
}
