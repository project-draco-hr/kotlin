{
  JetSimpleNameExpression reference=expression.getCallableReference();
  boolean[] result=new boolean[1];
  CallableDescriptor descriptor=resolveCallableReferenceTarget(lhsType,context,expression,result);
  if (!result[0]) {
    context.trace.report(UNRESOLVED_REFERENCE.on(reference,reference));
  }
  if (descriptor == null)   return null;
  ReceiverParameterDescriptor receiverParameter=descriptor.getReceiverParameter();
  ReceiverParameterDescriptor expectedThisObject=descriptor.getExpectedThisObject();
  if (receiverParameter != null && expectedThisObject != null && descriptor instanceof CallableMemberDescriptor) {
    context.trace.report(EXTENSION_IN_CLASS_REFERENCE_NOT_ALLOWED.on(reference,(CallableMemberDescriptor)descriptor));
    return null;
  }
  JetType receiverType=null;
  if (receiverParameter != null) {
    receiverType=receiverParameter.getType();
  }
 else   if (expectedThisObject != null) {
    receiverType=expectedThisObject.getType();
  }
  boolean isExtension=receiverParameter != null;
  if (descriptor instanceof FunctionDescriptor) {
    return createFunctionReferenceType(expression,context,(FunctionDescriptor)descriptor,receiverType,isExtension);
  }
 else   if (descriptor instanceof PropertyDescriptor) {
    return createPropertyReferenceType(expression,context,(PropertyDescriptor)descriptor,receiverType,isExtension);
  }
 else   if (descriptor instanceof VariableDescriptor) {
    context.trace.report(UNSUPPORTED.on(reference,"References to variables aren't supported yet"));
    return null;
  }
  throw new UnsupportedOperationException("Callable reference resolved to an unsupported descriptor: " + descriptor);
}
