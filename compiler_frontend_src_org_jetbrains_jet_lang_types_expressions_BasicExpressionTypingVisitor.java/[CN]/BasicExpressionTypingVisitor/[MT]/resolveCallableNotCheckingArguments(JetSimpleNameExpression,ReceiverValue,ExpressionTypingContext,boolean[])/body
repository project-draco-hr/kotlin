{
  Call call=CallMaker.makeCall(reference,receiver,null,reference,ThrowingList.<ValueArgument>instance());
  TemporaryBindingTrace trace=TemporaryBindingTrace.create(context.trace,"trace to resolve as function",reference);
  ExpressionTypingContext contextForResolve=context.replaceBindingTrace(trace).replaceExpectedType(NO_EXPECTED_TYPE);
  ResolvedCallWithTrace<FunctionDescriptor> function=components.expressionTypingServices.getCallExpressionResolver().getResolvedCallForFunction(call,reference,contextForResolve,CheckValueArgumentsMode.DISABLED,result);
  if (!result[0])   return null;
  if (function instanceof VariableAsFunctionResolvedCall) {
    context.trace.report(UNSUPPORTED.on(reference,"References to variables aren't supported yet"));
    context.trace.report(UNRESOLVED_REFERENCE.on(reference,reference));
    return null;
  }
  trace.commit();
  return function != null ? function.getResultingDescriptor() : null;
}
