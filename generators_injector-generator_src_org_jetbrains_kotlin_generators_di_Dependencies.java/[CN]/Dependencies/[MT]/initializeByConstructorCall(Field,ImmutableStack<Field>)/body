{
  DiType type=((InstantiateType)field.getInitialization()).getType();
  Class<?> clazz=type.getClazz();
  if (clazz.isInterface()) {
    if (initializeAsSingleton(field,type))     return;
    throw new IllegalArgumentException("cannot instantiate interface: " + clazz.getName() + " needed for "+ neededFor);
  }
  if (Modifier.isAbstract(clazz.getModifiers())) {
    if (initializeAsSingleton(field,type))     return;
    throw new IllegalArgumentException("cannot instantiate abstract class: " + clazz.getName() + " needed for "+ neededFor);
  }
  List<Constructor<?>> publicConstructors=findPublicConstructors(clazz.getConstructors());
  if (publicConstructors.size() != 1) {
    if (initializeAsSingleton(field,type))     return;
    if (publicConstructors.size() == 0) {
      throw new IllegalArgumentException("No public constructor: " + clazz.getName() + " needed for "+ neededFor);
    }
 else {
      throw new IllegalArgumentException("Too many public constructors in " + clazz.getName() + " needed for "+ neededFor);
    }
  }
  Constructor<?> publicConstructor=publicConstructors.get(0);
  ConstructorCall dependency=new ConstructorCall(publicConstructor);
  Type[] parameterTypes=publicConstructor.getGenericParameterTypes();
  try {
    for (    Type parameterType : parameterTypes) {
      Field fieldForParameter=findDependencyOfType(DiType.fromReflectionType(parameterType),"constructor: " + publicConstructor + ", parameter: "+ parameterType,neededFor.prepend(field));
      used.add(fieldForParameter);
      dependency.getConstructorArguments().add(fieldForParameter);
    }
  }
 catch (  InstantiationFailedException e) {
    throw e;
  }
catch (  RuntimeException e) {
    throw new InstantiationFailedException("Could not instantiate '" + field + "' by calling "+ publicConstructor+ "\nneeded for "+ neededFor,e);
  }
  field.setInitialization(dependency);
}
