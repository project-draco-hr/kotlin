{
  List<IntentionAction> actions=new LinkedList<IntentionAction>();
  BindingContext context=ResolutionUtils.analyzeFully((KtFile)diagnostic.getPsiFile());
  PsiElement diagnosticElement=diagnostic.getPsiElement();
  if (!(diagnosticElement instanceof KtExpression)) {
    LOG.error("Unexpected element: " + diagnosticElement.getText());
    return Collections.emptyList();
  }
  KtExpression expression=(KtExpression)diagnosticElement;
  KotlinType expectedType;
  KotlinType expressionType;
  if (diagnostic.getFactory() == Errors.TYPE_MISMATCH) {
    DiagnosticWithParameters2<KtExpression,KotlinType,KotlinType> diagnosticWithParameters=Errors.TYPE_MISMATCH.cast(diagnostic);
    expectedType=diagnosticWithParameters.getA();
    expressionType=diagnosticWithParameters.getB();
  }
 else   if (diagnostic.getFactory() == Errors.NULL_FOR_NONNULL_TYPE) {
    DiagnosticWithParameters1<KtConstantExpression,KotlinType> diagnosticWithParameters=Errors.NULL_FOR_NONNULL_TYPE.cast(diagnostic);
    expectedType=diagnosticWithParameters.getA();
    expressionType=TypeUtilsKt.makeNullable(expectedType);
  }
 else   if (diagnostic.getFactory() == Errors.CONSTANT_EXPECTED_TYPE_MISMATCH) {
    DiagnosticWithParameters2<KtConstantExpression,String,KotlinType> diagnosticWithParameters=Errors.CONSTANT_EXPECTED_TYPE_MISMATCH.cast(diagnostic);
    expectedType=diagnosticWithParameters.getB();
    expressionType=context.getType(expression);
    if (expressionType == null) {
      LOG.error("No type inferred: " + expression.getText());
      return Collections.emptyList();
    }
  }
 else {
    LOG.error("Unexpected diagnostic: " + DefaultErrorMessages.render(diagnostic));
    return Collections.emptyList();
  }
  if (!(expression instanceof KtBinaryExpressionWithTypeRHS) && !(expression.getParent() instanceof KtBinaryExpressionWithTypeRHS)) {
    actions.add(new CastExpressionFix(expression,expectedType));
  }
  KtProperty property=PsiTreeUtil.getParentOfType(expression,KtProperty.class);
  if (property != null) {
    KtPropertyAccessor getter=property.getGetter();
    KtExpression initializer=property.getInitializer();
    if (QuickFixUtil.canEvaluateTo(initializer,expression) || (getter != null && QuickFixUtil.canFunctionOrGetterReturnExpression(property.getGetter(),expression))) {
      LexicalScope scope=ScopeUtils.getResolutionScope(property,context,ResolutionUtils.getResolutionFacade(property));
      KotlinType typeToInsert=TypeUtils.approximateWithResolvableType(expressionType,scope,false);
      actions.add(new ChangeVariableTypeFix(property,typeToInsert));
    }
  }
  PsiElement expressionParent=expression.getParent();
  KtCallableDeclaration function=expressionParent instanceof KtReturnExpression ? BindingContextUtilsKt.getTargetFunction((KtReturnExpression)expressionParent,context) : PsiTreeUtil.getParentOfType(expression,KtFunction.class,true);
  if (function instanceof KtFunction && QuickFixUtil.canFunctionOrGetterReturnExpression(function,expression)) {
    LexicalScope scope=ScopeUtils.getResolutionScope(function,context,ResolutionUtils.getResolutionFacade(function));
    KotlinType typeToInsert=TypeUtils.approximateWithResolvableType(expressionType,scope,false);
    actions.add(new ChangeFunctionReturnTypeFix((KtFunction)function,typeToInsert));
  }
  if (expression instanceof KtOperationExpression) {
    ResolvedCall<?> resolvedCall=CallUtilKt.getResolvedCall(expression,context);
    if (resolvedCall != null) {
      KtFunction declaration=getFunctionDeclaration(resolvedCall);
      if (declaration != null) {
        actions.add(new ChangeFunctionReturnTypeFix(declaration,expectedType));
      }
    }
  }
  if (expression instanceof KtCallExpression) {
    ResolvedCall<?> resolvedCall=CallUtilKt.getResolvedCall(expression,context);
    if (resolvedCall != null) {
      KtFunction declaration=getFunctionDeclaration(resolvedCall);
      if (declaration != null) {
        actions.add(new ChangeFunctionReturnTypeFix(declaration,expectedType));
      }
    }
  }
  ResolvedCall<? extends CallableDescriptor> resolvedCall=CallUtilKt.getParentResolvedCall(expression,context,true);
  if (resolvedCall != null) {
    KtExpression parentIf=QuickFixUtil.getParentIfForBranch(expression);
    KtExpression argumentExpression=(parentIf != null) ? parentIf : expression;
    ValueArgument valueArgument=CallUtilKt.getValueArgumentForExpression(resolvedCall.getCall(),argumentExpression);
    if (valueArgument != null) {
      KtParameter correspondingParameter=QuickFixUtil.getParameterDeclarationForValueArgument(resolvedCall,valueArgument);
      KotlinType valueArgumentType=diagnostic.getFactory() == Errors.NULL_FOR_NONNULL_TYPE ? expressionType : context.getType(valueArgument.getArgumentExpression());
      if (correspondingParameter != null && valueArgumentType != null) {
        KtCallableDeclaration callable=PsiTreeUtil.getParentOfType(correspondingParameter,KtCallableDeclaration.class,true);
        LexicalScope scope=callable != null ? ScopeUtils.getResolutionScope(callable,context,ResolutionUtils.getResolutionFacade(callable)) : null;
        KotlinType typeToInsert=TypeUtils.approximateWithResolvableType(valueArgumentType,scope,true);
        actions.add(new ChangeParameterTypeFix(correspondingParameter,typeToInsert));
      }
    }
  }
  return actions;
}
