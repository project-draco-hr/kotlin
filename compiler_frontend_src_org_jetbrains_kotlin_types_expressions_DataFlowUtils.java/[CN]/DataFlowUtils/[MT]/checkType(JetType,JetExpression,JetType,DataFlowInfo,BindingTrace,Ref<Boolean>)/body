{
  if (hasError != null)   hasError.set(false);
  final JetExpression expression=JetPsiUtil.safeDeparenthesize(expressionToCheck,false);
  recordExpectedType(trace,expression,expectedType);
  if (expressionType == null)   return null;
  if (noExpectedType(expectedType) || !expectedType.getConstructor().isDenotable() || JetTypeChecker.DEFAULT.isSubtypeOf(expressionType,expectedType)) {
    if (!noExpectedType(expectedType)) {
      Approximation.Info approximationInfo=TypesPackage.getApproximationTo(expressionType,expectedType,new Approximation.DataFlowExtras(){
        private DataFlowValue getDataFlowValue(){
          return DataFlowValueFactory.createDataFlowValue(expression,expressionType,trace.getBindingContext());
        }
        @Override public boolean getCanBeNull(){
          return dataFlowInfo.getNullability(getDataFlowValue()).canBeNull();
        }
        @NotNull @Override public Set<JetType> getPossibleTypes(){
          return dataFlowInfo.getPossibleTypes(getDataFlowValue());
        }
        @NotNull @Override public String getPresentableText(){
          return StringUtil.trimMiddle(expression.getText(),50);
        }
      }
);
      if (approximationInfo != null) {
        trace.record(BindingContext.EXPRESSION_RESULT_APPROXIMATION,expression,approximationInfo);
      }
    }
    return expressionType;
  }
  if (expression instanceof JetConstantExpression) {
    CompileTimeConstant<?> value=ConstantExpressionEvaluator.OBJECT$.evaluate(expression,trace,expectedType);
    if (value instanceof IntegerValueTypeConstant) {
      value=EvaluatePackage.createCompileTimeConstantWithType((IntegerValueTypeConstant)value,expectedType);
    }
    boolean error=new CompileTimeConstantChecker(trace,true).checkConstantExpressionType(value,(JetConstantExpression)expression,expectedType);
    if (hasError != null)     hasError.set(error);
    return expressionType;
  }
  DataFlowValue dataFlowValue=DataFlowValueFactory.createDataFlowValue(expression,expressionType,trace.getBindingContext());
  for (  JetType possibleType : dataFlowInfo.getPossibleTypes(dataFlowValue)) {
    if (JetTypeChecker.DEFAULT.isSubtypeOf(possibleType,expectedType)) {
      SmartCastUtils.recordCastOrError(expression,possibleType,trace,dataFlowValue.isStableIdentifier(),false);
      return possibleType;
    }
  }
  trace.report(TYPE_MISMATCH.on(expression,expectedType,expressionType));
  if (hasError != null)   hasError.set(true);
  return expressionType;
}
