{
  if (hasError != null)   hasError.set(false);
  JetExpression expression=JetPsiUtil.safeDeparenthesize(expressionToCheck,false);
  recordExpectedType(c.trace,expression,c.expectedType);
  if (expressionType == null)   return null;
  c.additionalTypeChecker.checkType(expression,expressionType,c);
  if (noExpectedType(c.expectedType) || !c.expectedType.getConstructor().isDenotable() || JetTypeChecker.DEFAULT.isSubtypeOf(expressionType,c.expectedType)) {
    return expressionType;
  }
  if (expression instanceof JetConstantExpression) {
    CompileTimeConstant<?> value=ConstantExpressionEvaluator.evaluate(expression,c.trace,c.expectedType);
    if (value instanceof IntegerValueTypeConstant) {
      value=EvaluatePackage.createCompileTimeConstantWithType((IntegerValueTypeConstant)value,c.expectedType);
    }
    boolean error=new CompileTimeConstantChecker(c.trace,true).checkConstantExpressionType(value,(JetConstantExpression)expression,c.expectedType);
    if (hasError != null)     hasError.set(error);
    return expressionType;
  }
  DataFlowValue dataFlowValue=DataFlowValueFactory.createDataFlowValue(expression,expressionType,c);
  for (  JetType possibleType : c.dataFlowInfo.getPossibleTypes(dataFlowValue)) {
    if (JetTypeChecker.DEFAULT.isSubtypeOf(possibleType,c.expectedType)) {
      SmartCastUtils.recordCastOrError(expression,possibleType,c.trace,dataFlowValue.isPredictable(),false);
      return possibleType;
    }
  }
  c.trace.report(TYPE_MISMATCH.on(expression,c.expectedType,expressionType));
  if (hasError != null)   hasError.set(true);
  return expressionType;
}
