{
  ProgressIndicatorAndCompilationCanceledStatus.checkCanceled();
  prepareForCompilation(state);
  ProgressIndicatorAndCompilationCanceledStatus.checkCanceled();
  MultiMap<FqName,JetFile> filesInPackageClasses=new MultiMap<FqName,JetFile>();
  MultiMap<FqName,JetFile> filesInMultifileClasses=new MultiMap<FqName,JetFile>();
  for (  JetFile file : state.getFiles()) {
    if (file == null)     throw new IllegalArgumentException("A null file given for compilation");
    JvmFileClassInfo fileClassInfo=state.getFileClassesProvider().getFileClassInfo(file);
    if (fileClassInfo.getIsMultifileClass()) {
      filesInMultifileClasses.putValue(fileClassInfo.getFacadeClassFqName(),file);
    }
    if (state.getPackageFacadesAsMultifileClasses()) {
      if (!fileClassInfo.getIsMultifileClass()) {
        filesInMultifileClasses.putValue(PackageClassUtils.getPackageClassFqName(file.getPackageFqName()),file);
      }
    }
 else {
      filesInPackageClasses.putValue(file.getPackageFqName(),file);
    }
  }
  Set<FqName> packagesWithObsoleteParts=new HashSet<FqName>(state.getPackagesWithObsoleteParts());
  for (  FqName packageFqName : Sets.union(packagesWithObsoleteParts,filesInPackageClasses.keySet())) {
    ProgressIndicatorAndCompilationCanceledStatus.checkCanceled();
    generatePackage(state,packageFqName,filesInPackageClasses.get(packageFqName),errorHandler);
  }
  for (  FqName multifileClassFqName : filesInMultifileClasses.keySet()) {
    ProgressIndicatorAndCompilationCanceledStatus.checkCanceled();
    generateMultifileClass(state,multifileClassFqName,filesInMultifileClasses.get(multifileClassFqName),errorHandler);
  }
  ProgressIndicatorAndCompilationCanceledStatus.checkCanceled();
  state.getFactory().done();
}
