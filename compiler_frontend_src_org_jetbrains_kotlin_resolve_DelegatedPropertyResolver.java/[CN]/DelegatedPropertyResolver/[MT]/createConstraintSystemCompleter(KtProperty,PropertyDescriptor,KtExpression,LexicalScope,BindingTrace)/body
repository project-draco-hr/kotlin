{
  final KotlinType expectedType=property.getTypeReference() != null ? propertyDescriptor.getType() : NO_EXPECTED_TYPE;
  return new ConstraintSystemCompleter(){
    @Override public void completeConstraintSystem(    @NotNull ConstraintSystem.Builder constraintSystem,    @NotNull ResolvedCall<?> resolvedCall){
      KotlinType returnType=resolvedCall.getCandidateDescriptor().getReturnType();
      if (returnType == null)       return;
      TemporaryBindingTrace traceToResolveConventionMethods=TemporaryBindingTrace.create(trace,"Trace to resolve delegated property convention methods");
      OverloadResolutionResults<FunctionDescriptor> getMethodResults=getDelegatedPropertyConventionMethod(propertyDescriptor,delegateExpression,returnType,traceToResolveConventionMethods,accessorScope,true,false);
      if (conventionMethodFound(getMethodResults)) {
        FunctionDescriptor descriptor=getMethodResults.getResultingDescriptor();
        KotlinType returnTypeOfGetMethod=descriptor.getReturnType();
        if (returnTypeOfGetMethod != null && !TypeUtils.noExpectedType(expectedType)) {
          constraintSystem.addSupertypeConstraint(expectedType,returnTypeOfGetMethod,FROM_COMPLETER.position());
        }
        addConstraintForThisValue(constraintSystem,descriptor);
      }
      if (!propertyDescriptor.isVar())       return;
      if (propertyDescriptor.getReturnType() instanceof DeferredType)       return;
      OverloadResolutionResults<FunctionDescriptor> setMethodResults=getDelegatedPropertyConventionMethod(propertyDescriptor,delegateExpression,returnType,traceToResolveConventionMethods,accessorScope,false,false);
      if (conventionMethodFound(setMethodResults)) {
        FunctionDescriptor descriptor=setMethodResults.getResultingDescriptor();
        List<ValueParameterDescriptor> valueParameters=descriptor.getValueParameters();
        if (valueParameters.size() == 3) {
          ValueParameterDescriptor valueParameterForThis=valueParameters.get(2);
          if (!noExpectedType(expectedType)) {
            constraintSystem.addSubtypeConstraint(expectedType,valueParameterForThis.getType(),FROM_COMPLETER.position());
          }
          addConstraintForThisValue(constraintSystem,descriptor);
        }
      }
    }
    private boolean conventionMethodFound(    @NotNull OverloadResolutionResults<FunctionDescriptor> results){
      return results.isSuccess() || (results.isSingleResult() && results.getResultCode() == OverloadResolutionResults.Code.SINGLE_CANDIDATE_ARGUMENT_MISMATCH);
    }
    private void addConstraintForThisValue(    ConstraintSystem.Builder constraintSystem,    FunctionDescriptor resultingDescriptor){
      ReceiverParameterDescriptor extensionReceiver=propertyDescriptor.getExtensionReceiverParameter();
      ReceiverParameterDescriptor dispatchReceiver=propertyDescriptor.getDispatchReceiverParameter();
      KotlinType typeOfThis=extensionReceiver != null ? extensionReceiver.getType() : dispatchReceiver != null ? dispatchReceiver.getType() : builtIns.getNullableNothingType();
      List<ValueParameterDescriptor> valueParameters=resultingDescriptor.getValueParameters();
      if (valueParameters.isEmpty())       return;
      ValueParameterDescriptor valueParameterForThis=valueParameters.get(0);
      constraintSystem.addSubtypeConstraint(typeOfThis,valueParameterForThis.getType(),FROM_COMPLETER.position());
    }
  }
;
}
