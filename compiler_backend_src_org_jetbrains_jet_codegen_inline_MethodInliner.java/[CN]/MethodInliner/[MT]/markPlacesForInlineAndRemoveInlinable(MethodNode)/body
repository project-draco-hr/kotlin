{
  node=prepareNode(node);
  Analyzer<SourceValue> analyzer=new Analyzer<SourceValue>(new SourceInterpreter()){
    @NotNull @Override protected Frame<SourceValue> newFrame(    int nLocals,    int nStack){
      return new Frame<SourceValue>(nLocals,nStack){
        @Override public void execute(        @NotNull AbstractInsnNode insn,        Interpreter<SourceValue> interpreter) throws AnalyzerException {
          if (insn.getOpcode() == Opcodes.RETURN) {
            return;
          }
          super.execute(insn,interpreter);
        }
      }
;
    }
  }
;
  Frame<SourceValue>[] sources;
  try {
    sources=analyzer.analyze("fake",node);
  }
 catch (  AnalyzerException e) {
    throw wrapException(e,node,"couldn't inline method call");
  }
  AbstractInsnNode cur=node.instructions.getFirst();
  int index=0;
  Set<LabelNode> possibleDeadLabels=new HashSet<LabelNode>();
  while (cur != null) {
    Frame<SourceValue> frame=sources[index];
    if (frame != null) {
      if (cur.getType() == AbstractInsnNode.METHOD_INSN) {
        MethodInsnNode methodInsnNode=(MethodInsnNode)cur;
        String owner=methodInsnNode.owner;
        String desc=methodInsnNode.desc;
        String name=methodInsnNode.name;
        int paramLength=Type.getArgumentTypes(desc).length + 1;
        if (isInvokeOnLambda(owner,name)) {
          SourceValue sourceValue=frame.getStack(frame.getStackSize() - paramLength);
          LambdaInfo lambdaInfo=null;
          int varIndex=-1;
          if (sourceValue.insns.size() == 1) {
            AbstractInsnNode insnNode=sourceValue.insns.iterator().next();
            lambdaInfo=getLambdaIfExists(insnNode);
            if (lambdaInfo != null) {
              node.instructions.remove(insnNode);
            }
          }
          invokeCalls.add(new InvokeCall(varIndex,lambdaInfo));
        }
 else         if (isAnonymousConstructorCall(owner,name)) {
          Map<Integer,LambdaInfo> lambdaMapping=new HashMap<Integer,LambdaInfo>();
          int paramStart=frame.getStackSize() - paramLength;
          for (int i=0; i < paramLength; i++) {
            SourceValue sourceValue=frame.getStack(paramStart + i);
            if (sourceValue.insns.size() == 1) {
              AbstractInsnNode insnNode=sourceValue.insns.iterator().next();
              LambdaInfo lambdaInfo=getLambdaIfExists(insnNode);
              if (lambdaInfo != null) {
                lambdaMapping.put(i,lambdaInfo);
                node.instructions.remove(insnNode);
              }
            }
          }
          constructorInvocations.add(new ConstructorInvocation(owner,desc,lambdaMapping,isSameModule,inliningContext.classRegeneration));
        }
      }
    }
    AbstractInsnNode prevNode=cur;
    cur=cur.getNext();
    index++;
    if (frame == null) {
      if (prevNode.getType() == AbstractInsnNode.LABEL) {
        possibleDeadLabels.add((LabelNode)prevNode);
      }
 else {
        node.instructions.remove(prevNode);
      }
    }
 else {
      possibleDeadLabels.remove(prevNode.getPrevious());
    }
  }
  List<TryCatchBlockNode> blocks=node.tryCatchBlocks;
  for (Iterator<TryCatchBlockNode> iterator=blocks.iterator(); iterator.hasNext(); ) {
    TryCatchBlockNode block=iterator.next();
    if (possibleDeadLabels.contains(block.start) && possibleDeadLabels.contains(block.end)) {
      iterator.remove();
    }
  }
  return node;
}
