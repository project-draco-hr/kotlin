{
  JetScope libraryScope=JetStandardLibrary.getInstance().getLibraryScope();
  ModuleDescriptor owner=new ModuleDescriptor("<module>");
  final WritableScope scope=new WritableScopeImpl(JetScope.EMPTY,owner,new TraceBasedRedeclarationHandler(bindingTraceContext)).setDebugName("Root scope in analyzeNamespace");
  scope.importScope(libraryScope);
  scope.changeLockLevel(WritableScope.LockLevel.BOTH);
  final Map<String,NamespaceDescriptorImpl> declaredNamespaces=Maps.newHashMap();
  TopDownAnalyzer.process(project,bindingTraceContext,new JetScopeAdapter(scope){
    @Override public NamespaceDescriptor getNamespace(    @NotNull String name){
      NamespaceDescriptor topLevelNamespace=declaredNamespaces.get(name);
      if (topLevelNamespace != null) {
        return topLevelNamespace;
      }
      NamespaceDescriptor topLevelNamespaceFromConfiguration=configuration.getTopLevelNamespace(name);
      if (topLevelNamespaceFromConfiguration != null) {
        return topLevelNamespaceFromConfiguration;
      }
      return super.getNamespace(name);
    }
    @NotNull @Override public Collection<DeclarationDescriptor> getAllDescriptors(){
      List<DeclarationDescriptor> allDescriptors=Lists.newArrayList(super.getAllDescriptors());
      allDescriptors.addAll(declaredNamespaces.values());
      configuration.addAllTopLevelNamespacesTo(allDescriptors);
      return allDescriptors;
    }
  }
,new NamespaceLike.Adapter(owner){
    @Override public NamespaceDescriptorImpl getNamespace(    String name){
      return declaredNamespaces.get(name);
    }
    @Override public void addNamespace(    @NotNull NamespaceDescriptor namespaceDescriptor){
      scope.addNamespace(namespaceDescriptor);
      declaredNamespaces.put(namespaceDescriptor.getName(),(NamespaceDescriptorImpl)namespaceDescriptor);
    }
    @Override public void addClassifierDescriptor(    @NotNull MutableClassDescriptorLite classDescriptor){
      throw new IllegalStateException("A class shouldn't sit right under a module: " + classDescriptor);
    }
    @Override public void addObjectDescriptor(    @NotNull MutableClassDescriptorLite objectDescriptor){
      throw new IllegalStateException("An object shouldn't sit right under a module: " + objectDescriptor);
    }
    @Override public void addFunctionDescriptor(    @NotNull SimpleFunctionDescriptor functionDescriptor){
      throw new IllegalStateException("A function shouldn't sit right under a module: " + functionDescriptor);
    }
    @Override public void addPropertyDescriptor(    @NotNull PropertyDescriptor propertyDescriptor){
      throw new IllegalStateException("A property shouldn't sit right under a module: " + propertyDescriptor);
    }
    @Override public ClassObjectStatus setClassObjectDescriptor(    @NotNull MutableClassDescriptorLite classObjectDescriptor){
      throw new IllegalStateException("Must be guaranteed not to happen by the parser");
    }
  }
,files,filesToAnalyzeCompletely,flowDataTraceFactory,configuration);
  return bindingTraceContext.getBindingContext();
}
