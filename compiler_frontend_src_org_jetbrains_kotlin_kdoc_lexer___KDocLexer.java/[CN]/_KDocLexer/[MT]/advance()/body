{
  int zzInput;
  int zzAction;
  int zzCurrentPosL;
  int zzMarkedPosL;
  int zzEndReadL=zzEndRead;
  CharSequence zzBufferL=zzBuffer;
  char[] zzBufferArrayL=zzBufferArray;
  char[] zzCMapL=ZZ_CMAP;
  int[] zzTransL=ZZ_TRANS;
  int[] zzRowMapL=ZZ_ROWMAP;
  int[] zzAttrL=ZZ_ATTRIBUTE;
  while (true) {
    zzMarkedPosL=zzMarkedPos;
    zzAction=-1;
    zzCurrentPosL=zzCurrentPos=zzStartRead=zzMarkedPosL;
    zzState=ZZ_LEXSTATE[zzLexicalState];
    zzForAction: {
      while (true) {
        if (zzCurrentPosL < zzEndReadL)         zzInput=(zzBufferArrayL != null ? zzBufferArrayL[zzCurrentPosL++] : zzBufferL.charAt(zzCurrentPosL++));
 else         if (zzAtEOF) {
          zzInput=YYEOF;
          break zzForAction;
        }
 else {
          zzCurrentPos=zzCurrentPosL;
          zzMarkedPos=zzMarkedPosL;
          boolean eof=zzRefill();
          zzCurrentPosL=zzCurrentPos;
          zzMarkedPosL=zzMarkedPos;
          zzBufferL=zzBuffer;
          zzEndReadL=zzEndRead;
          if (eof) {
            zzInput=YYEOF;
            break zzForAction;
          }
 else {
            zzInput=(zzBufferArrayL != null ? zzBufferArrayL[zzCurrentPosL++] : zzBufferL.charAt(zzCurrentPosL++));
          }
        }
        int zzNext=zzTransL[zzRowMapL[zzState] + zzCMapL[zzInput]];
        if (zzNext == -1)         break zzForAction;
        zzState=zzNext;
        int zzAttributes=zzAttrL[zzState];
        if ((zzAttributes & 1) == 1) {
          zzAction=zzState;
          zzMarkedPosL=zzCurrentPosL;
          if ((zzAttributes & 8) == 8)           break zzForAction;
        }
      }
    }
    zzMarkedPos=zzMarkedPosL;
switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
case 10:
{
        KDocKnownTag tag=KDocKnownTag.findByTagName(zzBuffer.subSequence(zzStartRead,zzMarkedPos));
        yybegin(tag != null && tag.isReferenceRequired() ? TAG_BEGINNING : TAG_TEXT_BEGINNING);
        return KDocTokens.TAG_NAME;
      }
case 14:
    break;
case 3:
{
    if (yytextContainLineBreaks()) {
      yybegin(LINE_BEGINNING);
      return TokenType.WHITE_SPACE;
    }
 else {
      yybegin(yystate() == CONTENTS_BEGINNING ? CONTENTS_BEGINNING : CONTENTS);
      return KDocTokens.TEXT;
    }
  }
case 15:
break;
case 11:
{
yybegin(CONTENTS_BEGINNING);
return KDocTokens.START;
}
case 16:
break;
case 8:
{
if (isLastToken()) return KDocTokens.END;
 else return KDocTokens.TEXT;
}
case 17:
break;
case 5:
{
yybegin(CONTENTS);
return KDocTokens.TEXT;
}
case 18:
break;
case 6:
{
if (yytextContainLineBreaks()) {
yybegin(LINE_BEGINNING);
}
return TokenType.WHITE_SPACE;
}
case 19:
break;
case 13:
yypushback(1);
{
yybegin(CONTENTS);
return KDocTokens.MARKDOWN_LINK;
}
case 20:
break;
case 12:
{
yybegin(CONTENTS);
return KDocTokens.MARKDOWN_LINK;
}
case 21:
break;
case 1:
{
return TokenType.BAD_CHARACTER;
}
case 22:
break;
case 9:
{
yybegin(CONTENTS);
return KDocTokens.MARKDOWN_ESCAPED_CHAR;
}
case 23:
break;
case 2:
{
yybegin(CONTENTS);
return KDocTokens.TEXT;
}
case 24:
break;
case 7:
{
yybegin(CONTENTS);
return KDocTokens.MARKDOWN_LINK;
}
case 25:
break;
case 4:
{
yybegin(CONTENTS_BEGINNING);
return KDocTokens.LEADING_ASTERISK;
}
case 26:
break;
default :
if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
zzAtEOF=true;
zzDoEOF();
return null;
}
 else {
zzScanError(ZZ_NO_MATCH);
}
}
}
}
