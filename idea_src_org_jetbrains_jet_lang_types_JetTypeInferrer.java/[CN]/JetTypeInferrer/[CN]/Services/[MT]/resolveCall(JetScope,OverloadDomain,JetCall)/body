{
  final List<JetTypeProjection> jetTypeArguments=call.getTypeArguments();
  for (  JetTypeProjection typeArgument : jetTypeArguments) {
    if (typeArgument.getProjectionKind() != JetProjectionKind.NONE) {
      trace.getErrorHandler().genericError(typeArgument.getNode(),"Projections are not allowed on type parameters for methods");
    }
  }
  List<JetType> typeArguments=new ArrayList<JetType>();
  for (  JetTypeProjection projection : jetTypeArguments) {
    JetTypeReference typeReference=projection.getTypeReference();
    if (typeReference != null) {
      typeArguments.add(new TypeResolver(semanticServices,trace,true).resolveType(scope,typeReference));
    }
  }
  return resolveCallWithTypeArguments(scope,overloadDomain,call,typeArguments);
}
