{
  OverloadResolutionResult iteratorResolutionResult=context.services.resolveNoParametersFunction(type,context.scope,"iterator");
  if (iteratorResolutionResult.isSuccess()) {
    JetType iteratorType=iteratorResolutionResult.getFunctionDescriptor().getReturnType();
    boolean hasNextFunctionSupported=checkHasNextFunctionSupport(reportErrorsOn,iteratorType,context);
    boolean hasNextPropertySupported=checkHasNextPropertySupport(reportErrorsOn,iteratorType,context);
    if (hasNextFunctionSupported && hasNextPropertySupported && !ErrorUtils.isErrorType(iteratorType)) {
      context.trace.getErrorHandler().genericError(reportErrorsOn,"An ambiguity between 'iterator().hasNext()' function and 'iterator().hasNext()' property");
    }
 else     if (!hasNextFunctionSupported && !hasNextPropertySupported) {
      context.trace.getErrorHandler().genericError(reportErrorsOn,"Loop range must have an 'iterator().hasNext()' function or an 'iterator().hasNext' property");
    }
    OverloadResolutionResult nextResolutionResult=context.services.resolveNoParametersFunction(iteratorType,context.scope,"next");
    if (nextResolutionResult.isAmbiguity()) {
      context.trace.getErrorHandler().genericError(reportErrorsOn,"Method 'iterator().next()' is ambiguous for this expression");
    }
 else     if (nextResolutionResult.isNothing()) {
      context.trace.getErrorHandler().genericError(reportErrorsOn,"Loop range must have an 'iterator().next()' method");
    }
 else {
      return nextResolutionResult.getFunctionDescriptor().getReturnType();
    }
  }
 else {
    String errorMessage="For-loop range must have an iterator() method";
    if (iteratorResolutionResult.isAmbiguity()) {
      errorMessage="Method 'iterator()' is ambiguous for this expression";
    }
    context.trace.getErrorHandler().genericError(reportErrorsOn,errorMessage);
  }
  return null;
}
