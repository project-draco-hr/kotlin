{
  JetSimpleNameExpression operationSign=expression.getOperationReference();
  JetExpression left=expression.getLeft();
  JetExpression right=expression.getRight();
  IElementType operationType=operationSign.getReferencedNameElementType();
  if (operationType == JetTokens.IDENTIFIER) {
    String referencedName=operationSign.getReferencedName();
    if (referencedName != null) {
      result=getTypeForBinaryCall(expression,referencedName,scope,true);
    }
  }
 else   if (binaryOperationNames.containsKey(operationType)) {
    result=getTypeForBinaryCall(expression,binaryOperationNames.get(operationType),scope,true);
  }
 else   if (operationType == JetTokens.EQ) {
    visitAssignment(expression);
  }
 else   if (assignmentOperationNames.containsKey(operationType)) {
    visitAssignmentOperation(expression);
  }
 else   if (comparisonOperations.contains(operationType)) {
    JetType compareToReturnType=getTypeForBinaryCall(expression,"compareTo",scope,true);
    if (compareToReturnType != null) {
      TypeConstructor constructor=compareToReturnType.getConstructor();
      JetStandardLibrary standardLibrary=semanticServices.getStandardLibrary();
      TypeConstructor intTypeConstructor=standardLibrary.getInt().getTypeConstructor();
      if (constructor.equals(intTypeConstructor)) {
        result=standardLibrary.getBooleanType();
      }
 else {
        semanticServices.getErrorHandler().genericError(operationSign.getNode(),"compareTo must return Int, but returns " + compareToReturnType);
      }
    }
  }
 else   if (equalsOperations.contains(operationType)) {
    String name="equals";
    JetType equalsType=getTypeForBinaryCall(expression,name,scope,true);
    assureBooleanResult(operationSign,name,equalsType);
  }
 else   if (inOperations.contains(operationType)) {
    if (right == null) {
      result=ErrorType.createErrorType("No right argument");
      return;
    }
    String name="contains";
    JetType containsType=getTypeForBinaryCall(scope,right,expression.getOperationReference(),expression.getLeft(),name,true);
    result=assureBooleanResult(operationSign,name,containsType);
  }
 else   if (operationType == JetTokens.EQEQEQ || operationType == JetTokens.EXCLEQEQEQ) {
    JetType leftType=getType(scope,left,false);
    JetType rightType=right == null ? null : getType(scope,right,false);
    result=semanticServices.getStandardLibrary().getBooleanType();
  }
 else   if (operationType == JetTokens.ANDAND || operationType == JetTokens.OROR) {
    JetType leftType=getType(scope,left,false);
    JetType rightType=right == null ? null : getType(scope,right,false);
    if (leftType != null && !isBoolean(leftType)) {
      semanticServices.getErrorHandler().typeMismatch(left,semanticServices.getStandardLibrary().getBooleanType(),leftType);
    }
    if (rightType != null && !isBoolean(rightType)) {
      semanticServices.getErrorHandler().typeMismatch(left,semanticServices.getStandardLibrary().getBooleanType(),rightType);
      semanticServices.getErrorHandler().typeMismatch(right,semanticServices.getStandardLibrary().getBooleanType(),rightType);
    }
    result=semanticServices.getStandardLibrary().getBooleanType();
  }
 else   if (operationType == JetTokens.ELVIS) {
    JetType leftType=getType(scope,left,false);
    JetType rightType=right == null ? null : getType(scope,right,false);
    if (leftType != null) {
      if (!leftType.isNullable()) {
        semanticServices.getErrorHandler().genericWarning(left.getNode(),"Elvis operator (?:) is always returns the left operand of non-nullable type " + leftType);
      }
      if (rightType != null) {
        result=TypeUtils.makeNullableAsSpecified(semanticServices.getTypeChecker().commonSupertype(leftType,rightType),rightType.isNullable());
      }
    }
  }
 else {
    semanticServices.getErrorHandler().genericError(operationSign.getNode(),"Unknown operation");
  }
}
