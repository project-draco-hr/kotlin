{
  final JetExpression subjectExpression=expression.getSubjectExpression();
  JetType subjectType=null;
  if (subjectExpression != null) {
    subjectType=getType(scope,subjectExpression,false);
  }
  for (  JetWhenEntry whenEntry : expression.getEntries()) {
    final JetType finalSubjectType=subjectType != null ? subjectType : ErrorUtils.createErrorType("Unknown type");
    JetWhenCondition condition=whenEntry.getCondition();
    if (condition != null) {
      condition.accept(new JetVisitor(){
        @Override public void visitWhenConditionWithExpression(        JetWhenConditionWithExpression condition){
          JetExpression conditionExpression=condition.getExpression();
          if (conditionExpression != null) {
            JetType type=getType(scope,conditionExpression,false);
            if (type != null && finalSubjectType != null) {
              if (TypeUtils.intersect(semanticServices.getTypeChecker(),Sets.newHashSet(finalSubjectType,type)) == null) {
                trace.getErrorHandler().genericError(conditionExpression.getNode(),"This condition can never hold");
              }
            }
          }
        }
        @Override public void visitWhenConditionCall(        JetWhenConditionCall condition){
          JetExpression callSuffixExpression=condition.getCallSuffixExpression();
          JetScope compositeScope=new ScopeWithReceiver(scope,finalSubjectType,semanticServices.getTypeChecker());
          if (callSuffixExpression != null) {
            JetType selectorReturnType=getType(compositeScope,callSuffixExpression,false);
            ensureBooleanResultWithCustomSubject(callSuffixExpression,selectorReturnType,"This expression");
            checkNullSafety(finalSubjectType,condition.getOperationTokenNode(),getCalleeFunctionDescriptor(callSuffixExpression));
          }
        }
        @Override public void visitWhenConditionInRange(        JetWhenConditionInRange condition){
          JetExpression rangeExpression=condition.getRangeExpression();
          if (rangeExpression != null) {
            checkInExpression(condition.getOperationReference(),subjectExpression,rangeExpression);
          }
        }
        @Override public void visitWhenConditionIsPattern(        JetWhenConditionIsPattern condition){
          JetPattern pattern=condition.getPattern();
          if (pattern != null) {
            checkPatternType(pattern,finalSubjectType);
          }
        }
        @Override public void visitJetElement(        JetElement element){
          trace.getErrorHandler().genericError(element.getNode(),"Unsupported [JetTypeInferrer] : " + element);
        }
      }
);
    }
  }
  List<JetType> expressionTypes=new ArrayList<JetType>();
  collectAllReturnTypes(expression,scope,expressionTypes);
  if (!expressionTypes.isEmpty()) {
    result=semanticServices.getTypeChecker().commonSupertype(expressionTypes);
  }
 else {
    trace.getErrorHandler().genericError(expression.getNode(),"Entries required for when-expression");
  }
}
