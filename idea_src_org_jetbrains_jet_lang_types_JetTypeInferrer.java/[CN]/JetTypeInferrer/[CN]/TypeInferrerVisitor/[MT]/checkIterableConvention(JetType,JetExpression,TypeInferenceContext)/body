{
  ASTNode reportErrorsOn=loopRange.getNode();
  OverloadResolutionResult<FunctionDescriptor> iteratorResolutionResult=callResolver.resolveExactSignature(context.scope,type,"iterator",Collections.<JetType>emptyList());
  if (iteratorResolutionResult.isSuccess()) {
    FunctionDescriptor iteratorFunction=iteratorResolutionResult.getDescriptor();
    context.trace.record(LOOP_RANGE_ITERATOR,loopRange,iteratorFunction);
    JetType iteratorType=iteratorFunction.getReturnType();
    FunctionDescriptor hasNextFunction=checkHasNextFunctionSupport(loopRange,iteratorType,context);
    boolean hasNextFunctionSupported=hasNextFunction != null;
    VariableDescriptor hasNextProperty=checkHasNextPropertySupport(loopRange,iteratorType,context);
    boolean hasNextPropertySupported=hasNextProperty != null;
    if (hasNextFunctionSupported && hasNextPropertySupported && !ErrorUtils.isErrorType(iteratorType)) {
      context.trace.getErrorHandler().genericError(reportErrorsOn,"An ambiguity between 'iterator().hasNext()' function and 'iterator().hasNext' property");
    }
 else     if (!hasNextFunctionSupported && !hasNextPropertySupported) {
      context.trace.getErrorHandler().genericError(reportErrorsOn,"Loop range must have an 'iterator().hasNext()' function or an 'iterator().hasNext' property");
    }
 else {
      context.trace.record(LOOP_RANGE_HAS_NEXT,loopRange,hasNextFunctionSupported ? hasNextFunction : hasNextProperty);
    }
    OverloadResolutionResult<FunctionDescriptor> nextResolutionResult=callResolver.resolveExactSignature(context.scope,iteratorType,"next",Collections.<JetType>emptyList());
    if (nextResolutionResult.isAmbiguity()) {
      context.trace.getErrorHandler().genericError(reportErrorsOn,"Method 'iterator().next()' is ambiguous for this expression");
    }
 else     if (nextResolutionResult.isNothing()) {
      context.trace.getErrorHandler().genericError(reportErrorsOn,"Loop range must have an 'iterator().next()' method");
    }
 else {
      FunctionDescriptor nextFunction=nextResolutionResult.getDescriptor();
      context.trace.record(LOOP_RANGE_NEXT,loopRange,nextFunction);
      return nextFunction.getReturnType();
    }
  }
 else {
    String errorMessage="For-loop range must have an iterator() method";
    if (iteratorResolutionResult.isAmbiguity()) {
      StringBuffer stringBuffer=new StringBuffer("Method 'iterator()' is ambiguous for this expression: ");
      for (      FunctionDescriptor functionDescriptor : iteratorResolutionResult.getDescriptors()) {
        stringBuffer.append(DescriptorRenderer.TEXT.render(functionDescriptor)).append(" ");
      }
      errorMessage="Method 'iterator()' is ambiguous for this expression: " + stringBuffer;
    }
    context.trace.getErrorHandler().genericError(reportErrorsOn,errorMessage);
  }
  return null;
}
