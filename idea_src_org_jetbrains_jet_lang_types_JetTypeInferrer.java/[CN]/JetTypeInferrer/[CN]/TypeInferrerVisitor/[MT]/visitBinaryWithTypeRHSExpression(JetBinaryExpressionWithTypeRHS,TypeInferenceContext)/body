{
  TypeInferenceContext context=contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE);
  IElementType operationType=expression.getOperationSign().getReferencedNameElementType();
  JetType actualType=getType(context.scope,expression.getLeft(),false,context);
  JetTypeReference right=expression.getRight();
  JetType result=null;
  if (right != null) {
    JetType targetType=context.typeResolver.resolveType(context.scope,right);
    if (operationType == JetTokens.COLON) {
      if (actualType != null && !semanticServices.getTypeChecker().isSubtypeOf(actualType,targetType)) {
        context.trace.getErrorHandler().typeMismatch(expression.getLeft(),targetType,actualType);
      }
      result=targetType;
    }
 else     if (operationType == JetTokens.AS_KEYWORD) {
      checkForCastImpossibility(expression,actualType,targetType,context);
      result=targetType;
    }
 else     if (operationType == JetTokens.AS_SAFE) {
      checkForCastImpossibility(expression,actualType,targetType,context);
      result=TypeUtils.makeNullable(targetType);
    }
 else {
      context.trace.getErrorHandler().genericError(expression.getOperationSign().getNode(),"Unsupported binary operation");
    }
  }
  return context.services.checkType(result,expression,contextWithExpectedType);
}
