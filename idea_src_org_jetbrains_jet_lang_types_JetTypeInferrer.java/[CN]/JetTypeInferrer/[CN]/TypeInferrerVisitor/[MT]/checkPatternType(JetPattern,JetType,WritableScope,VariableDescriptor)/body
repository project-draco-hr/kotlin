{
  final DataFlowInfo[] result=new DataFlowInfo[]{context.dataFlowInfo};
  pattern.accept(new JetVisitor(){
    @Override public void visitTypePattern(    JetTypePattern typePattern){
      JetTypeReference typeReference=typePattern.getTypeReference();
      if (typeReference != null) {
        JetType type=context.typeResolver.resolveType(context.scope,typeReference);
        checkTypeCompatibility(type,subjectType,typePattern);
        result[0]=context.dataFlowInfo.isInstanceOf(subjectVariables,type);
      }
    }
    @Override public void visitTuplePattern(    JetTuplePattern pattern){
      List<JetTuplePatternEntry> entries=pattern.getEntries();
      TypeConstructor typeConstructor=subjectType.getConstructor();
      if (!JetStandardClasses.getTuple(entries.size()).getTypeConstructor().equals(typeConstructor) || typeConstructor.getParameters().size() != entries.size()) {
        context.trace.getErrorHandler().genericError(pattern.getNode(),"Type mismatch: subject is of type " + subjectType + " but the pattern is of type Tuple"+ entries.size());
      }
 else {
        for (int i=0, entriesSize=entries.size(); i < entriesSize; i++) {
          JetTuplePatternEntry entry=entries.get(i);
          JetType type=subjectType.getArguments().get(i).getType();
          ASTNode nameLabelNode=entry.getNameLabelNode();
          if (nameLabelNode != null) {
            context.trace.getErrorHandler().genericError(nameLabelNode,"Unsupported [JetTypeInferrer]");
          }
          JetPattern entryPattern=entry.getPattern();
          if (entryPattern != null) {
            result[0]=checkPatternType(entryPattern,type,scopeToExtend);
          }
        }
      }
    }
    @Override public void visitDecomposerPattern(    JetDecomposerPattern pattern){
      JetType selectorReturnType=getSelectorReturnType(subjectType,pattern.getDecomposerExpression());
      result[0]=checkPatternType(pattern.getArgumentList(),selectorReturnType == null ? ErrorUtils.createErrorType("No type") : selectorReturnType,scopeToExtend);
    }
    @Override public void visitWildcardPattern(    JetWildcardPattern pattern){
    }
    @Override public void visitExpressionPattern(    JetExpressionPattern pattern){
      JetType type=getType(scopeToExtend,pattern.getExpression(),false);
      checkTypeCompatibility(type,subjectType,pattern);
    }
    @Override public void visitBindingPattern(    JetBindingPattern pattern){
      JetProperty variableDeclaration=pattern.getVariableDeclaration();
      JetTypeReference propertyTypeRef=variableDeclaration.getPropertyTypeRef();
      JetType type=propertyTypeRef == null ? subjectType : context.typeResolver.resolveType(context.scope,propertyTypeRef);
      VariableDescriptor variableDescriptor=context.classDescriptorResolver.resolveLocalVariableDescriptorWithType(context.scope.getContainingDeclaration(),variableDeclaration,type);
      scopeToExtend.addVariableDescriptor(variableDescriptor);
      if (propertyTypeRef != null) {
        if (!semanticServices.getTypeChecker().isSubtypeOf(subjectType,type)) {
          context.trace.getErrorHandler().genericError(propertyTypeRef.getNode(),type + " must be a supertype of " + subjectType+ ". Use 'is' to match against "+ type);
        }
      }
      JetWhenCondition condition=pattern.getCondition();
      if (condition != null) {
        int oldLength=subjectVariables.length;
        VariableDescriptor[] newSubjectVariables=new VariableDescriptor[oldLength + 1];
        System.arraycopy(subjectVariables,0,newSubjectVariables,0,oldLength);
        newSubjectVariables[oldLength]=variableDescriptor;
        result[0]=checkWhenCondition(null,subjectType,condition,scopeToExtend,newSubjectVariables);
      }
    }
    private void checkTypeCompatibility(    @Nullable JetType type,    @NotNull JetType subjectType,    @NotNull JetElement reportErrorOn){
      if (type == null) {
        return;
      }
      if (TypeUtils.intersect(semanticServices.getTypeChecker(),Sets.newHashSet(type,subjectType)) == null) {
        context.trace.getErrorHandler().genericError(reportErrorOn.getNode(),"Incompatible types: " + type + " and "+ subjectType);
      }
    }
    @Override public void visitJetElement(    JetElement element){
      context.trace.getErrorHandler().genericError(element.getNode(),"Unsupported [JetTypeInferrer]");
    }
  }
);
  return result[0];
}
