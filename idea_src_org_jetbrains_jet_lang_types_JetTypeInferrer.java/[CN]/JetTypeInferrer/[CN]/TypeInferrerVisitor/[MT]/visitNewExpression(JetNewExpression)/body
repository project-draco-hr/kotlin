{
  JetTypeReference typeReference=expression.getTypeReference();
  if (typeReference != null) {
    JetTypeElement typeElement=typeReference.getTypeElement();
    if (typeElement instanceof JetUserType) {
      JetUserType userType=(JetUserType)typeElement;
      JetType receiverType=typeResolver.resolveType(scope,typeReference);
      DeclarationDescriptor declarationDescriptor=receiverType.getConstructor().getDeclarationDescriptor();
      if (declarationDescriptor instanceof ClassDescriptor) {
        ClassDescriptor classDescriptor=(ClassDescriptor)declarationDescriptor;
        JetSimpleNameExpression referenceExpression=userType.getReferenceExpression();
        if (referenceExpression != null) {
          List<TypeProjection> typeArguments=receiverType.getArguments();
          System.out.println("typeArguments = " + typeArguments);
          List<TypeProjection> projectionsStripped=new ArrayList<TypeProjection>();
          for (          TypeProjection typeArgument : typeArguments) {
            if (typeArgument.getProjectionKind() != Variance.INVARIANT) {
              projectionsStripped.add(new TypeProjection(typeArgument.getType()));
            }
 else             projectionsStripped.add(typeArgument);
          }
          System.out.println("projectionsStripped = " + projectionsStripped);
          FunctionGroup constructors=classDescriptor.getConstructors(projectionsStripped);
          OverloadDomain constructorsOverloadDomain=semanticServices.getOverloadResolver().getOverloadDomain(constructors);
          JetType constructorReturnedType=resolveOverloads(scope,wrapForTracing(constructorsOverloadDomain,referenceExpression,expression.getArgumentList(),false),Collections.<JetTypeProjection>emptyList(),expression.getArguments(),expression.getFunctionLiteralArguments());
          if (constructorReturnedType == null && !ErrorType.isErrorType(receiverType)) {
            trace.recordReferenceResolution(referenceExpression,receiverType.getConstructor().getDeclarationDescriptor());
            JetArgumentList argumentList=expression.getArgumentList();
            if (argumentList != null) {
              semanticServices.getErrorHandler().genericError(argumentList.getNode(),"Cannot find an overload for these arguments");
            }
            constructorReturnedType=receiverType;
          }
          result=constructorReturnedType;
          result=receiverType;
        }
      }
 else {
        semanticServices.getErrorHandler().genericError(expression.getNode(),"Calling a constructor is only supported for ordinary classes");
      }
    }
 else {
      if (typeElement != null) {
        semanticServices.getErrorHandler().genericError(typeElement.getNode(),"Calling a constructor is only supported for ordinary classes");
      }
    }
  }
}
