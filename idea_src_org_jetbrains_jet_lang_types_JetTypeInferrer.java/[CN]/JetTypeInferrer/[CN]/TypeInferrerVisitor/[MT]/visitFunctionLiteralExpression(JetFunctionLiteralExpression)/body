{
  if (preferBlock && !expression.hasParameterSpecification()) {
    result=getBlockReturnedType(scope,expression.getBody(),LabeledJumpDomain.ERROR);
    return;
  }
  FunctionDescriptorImpl functionDescriptor=new FunctionDescriptorImpl(scope.getContainingDeclaration(),Collections.<Attribute>emptyList(),"<anonymous>");
  JetTypeReference returnTypeRef=expression.getReturnTypeRef();
  JetTypeReference receiverTypeRef=expression.getReceiverTypeRef();
  final JetType receiverType;
  if (receiverTypeRef != null) {
    receiverType=typeResolver.resolveType(scope,receiverTypeRef);
  }
 else {
    receiverType=scope.getThisType();
  }
  List<JetElement> body=expression.getBody();
  final Map<String,PropertyDescriptor> parameterDescriptors=new HashMap<String,PropertyDescriptor>();
  List<JetType> parameterTypes=new ArrayList<JetType>();
  for (  JetParameter parameter : expression.getParameters()) {
    JetTypeReference typeReference=parameter.getTypeReference();
    if (typeReference == null) {
      throw new UnsupportedOperationException("Type inference for parameters is not implemented yet");
    }
    PropertyDescriptor propertyDescriptor=classDescriptorResolver.resolveValueParameterDescriptor(functionDescriptor,scope,parameter);
    parameterDescriptors.put(parameter.getName(),propertyDescriptor);
    parameterTypes.add(propertyDescriptor.getOutType());
  }
  JetType returnType;
  if (returnTypeRef != null) {
    returnType=typeResolver.resolveType(scope,returnTypeRef);
  }
 else {
    WritableScope writableScope=semanticServices.createWritableScope(scope,functionDescriptor);
    for (    PropertyDescriptor propertyDescriptor : parameterDescriptors.values()) {
      writableScope.addPropertyDescriptor(propertyDescriptor);
    }
    writableScope.setThisType(receiverType);
    returnType=getBlockReturnedType(writableScope,body,LabeledJumpDomain.ERROR);
  }
  JetType effectiveReceiverType=receiverTypeRef == null ? null : receiverType;
  JetType safeReturnType=returnType == null ? ErrorUtils.createErrorType("<return type>") : returnType;
  result=JetStandardClasses.getFunctionType(null,effectiveReceiverType,parameterTypes,safeReturnType);
}
