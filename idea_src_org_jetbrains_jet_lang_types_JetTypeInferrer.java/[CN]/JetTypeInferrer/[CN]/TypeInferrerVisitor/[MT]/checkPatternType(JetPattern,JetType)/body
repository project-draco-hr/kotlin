{
  pattern.accept(new JetVisitor(){
    @Override public void visitTypePattern(    JetTypePattern typePattern){
      JetTypeReference typeReference=typePattern.getTypeReference();
      if (typeReference != null) {
        JetType type=typeResolver.resolveType(scope,typeReference);
        checkTypeCompatibility(type,subjectType,typePattern);
      }
    }
    @Override public void visitWildcardPattern(    JetWildcardPattern pattern){
    }
    @Override public void visitExpressionPattern(    JetExpressionPattern pattern){
      JetType type=getType(scope,pattern.getExpression(),false);
      checkTypeCompatibility(type,subjectType,pattern);
    }
    @Override public void visitTuplePattern(    JetTuplePattern pattern){
      List<JetTuplePatternEntry> entries=pattern.getEntries();
      TypeConstructor typeConstructor=subjectType.getConstructor();
      if (!JetStandardClasses.getTuple(entries.size()).getTypeConstructor().equals(typeConstructor) || typeConstructor.getParameters().size() != entries.size()) {
        trace.getErrorHandler().genericError(pattern.getNode(),"Type mismatch: subject is of type " + subjectType + " but the pattern if of type Tuple"+ entries.size());
      }
 else {
        for (int i=0, entriesSize=entries.size(); i < entriesSize; i++) {
          JetTuplePatternEntry entry=entries.get(i);
          JetType type=subjectType.getArguments().get(i).getType();
          ASTNode nameLabelNode=entry.getNameLabelNode();
          if (nameLabelNode != null) {
            trace.getErrorHandler().genericError(nameLabelNode,"Unsupported [JetTypeInferrer]");
          }
          JetPattern entryPattern=entry.getPattern();
          if (entryPattern != null) {
            checkPatternType(entryPattern,type);
          }
        }
      }
    }
    private void checkTypeCompatibility(    @Nullable JetType type,    @NotNull JetType subjectType,    @NotNull JetElement reportErrorOn){
      if (type == null) {
        return;
      }
      if (TypeUtils.intersect(semanticServices.getTypeChecker(),Sets.newHashSet(type,subjectType)) == null) {
        trace.getErrorHandler().genericError(reportErrorOn.getNode(),"Incompatible types: " + type + " and "+ subjectType);
      }
    }
    @Override public void visitJetElement(    JetElement elem){
      trace.getErrorHandler().genericError(elem.getNode(),"Unsupported [JetTypeInferrer]");
    }
  }
);
}
