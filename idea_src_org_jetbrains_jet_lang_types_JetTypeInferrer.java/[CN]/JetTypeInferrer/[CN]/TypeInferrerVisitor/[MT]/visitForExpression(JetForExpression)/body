{
  JetParameter loopParameter=expression.getLoopParameter();
  JetExpression loopRange=expression.getLoopRange();
  JetType loopRangeType=null;
  if (loopRange != null) {
    loopRangeType=getType(scope,loopRange,false);
  }
  JetType expectedParameterType=null;
  if (loopRangeType != null) {
    expectedParameterType=checkIterableConvention(loopRangeType,loopRange.getNode());
  }
  WritableScope loopScope=newWritableScopeImpl().setDebugName("Scope with for-loop index");
  if (loopParameter != null) {
    JetTypeReference typeReference=loopParameter.getTypeReference();
    VariableDescriptor variableDescriptor;
    if (typeReference != null) {
      variableDescriptor=classDescriptorResolver.resolveLocalVariableDescriptor(scope.getContainingDeclaration(),scope,loopParameter);
      JetType actualParameterType=variableDescriptor.getOutType();
      if (expectedParameterType != null && actualParameterType != null && !semanticServices.getTypeChecker().isSubtypeOf(expectedParameterType,actualParameterType)) {
        trace.getErrorHandler().genericError(typeReference.getNode(),"The loop iterates over values of type " + expectedParameterType + " but the parameter is declared to be "+ actualParameterType);
      }
    }
 else {
      if (expectedParameterType == null) {
        expectedParameterType=ErrorUtils.createErrorType("Error");
      }
      variableDescriptor=classDescriptorResolver.resolveLocalVariableDescriptor(scope.getContainingDeclaration(),loopParameter,expectedParameterType);
    }
    loopScope.addVariableDescriptor(variableDescriptor);
  }
  JetExpression body=expression.getBody();
  if (body != null) {
    getType(loopScope,body,true);
  }
  result=JetStandardClasses.getUnitType();
}
