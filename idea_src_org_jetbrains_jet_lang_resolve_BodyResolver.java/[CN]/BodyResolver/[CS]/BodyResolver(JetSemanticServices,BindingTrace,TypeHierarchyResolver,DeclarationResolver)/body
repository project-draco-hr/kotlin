{
  this.semanticServices=semanticServices;
  this.classDescriptorResolver=semanticServices.getClassDescriptorResolver(trace);
  this.trace=trace;
  this.declarationResolver=declarationResolver;
  this.typeHierarchyResolver=typeHierarchyResolver;
  this.traceForConstructors=new BindingTraceAdapter(trace).addHandler(BindingContext.REFERENCE_TARGET,new BindingTraceAdapter.RecordHandler<JetReferenceExpression,DeclarationDescriptor>(){
    @Override public void handleRecord(    WritableSlice<JetReferenceExpression,DeclarationDescriptor> slice,    JetReferenceExpression expression,    DeclarationDescriptor descriptor){
      if (expression instanceof JetSimpleNameExpression) {
        JetSimpleNameExpression simpleNameExpression=(JetSimpleNameExpression)expression;
        if (simpleNameExpression.getReferencedNameElementType() == JetTokens.FIELD_IDENTIFIER) {
          if (!BodyResolver.this.trace.getBindingContext().get(BindingContext.BACKING_FIELD_REQUIRED,(PropertyDescriptor)descriptor)) {
            BodyResolver.this.trace.getErrorHandler().genericError(expression.getNode(),"This property does not have a backing field");
          }
        }
      }
    }
  }
);
  this.traceForMembers=new BindingTraceAdapter(trace).addHandler(BindingContext.REFERENCE_TARGET,new BindingTraceAdapter.RecordHandler<JetReferenceExpression,DeclarationDescriptor>(){
    @Override public void handleRecord(    WritableSlice<JetReferenceExpression,DeclarationDescriptor> slice,    JetReferenceExpression expression,    DeclarationDescriptor descriptor){
      if (descriptor instanceof PropertyDescriptor) {
        PropertyDescriptor propertyDescriptor=(PropertyDescriptor)descriptor;
        if (BodyResolver.this.declarationResolver.getPrimaryConstructorParameterProperties().contains(propertyDescriptor)) {
          traceForMembers.record(BindingContext.BACKING_FIELD_REQUIRED,propertyDescriptor);
        }
      }
    }
  }
);
}
