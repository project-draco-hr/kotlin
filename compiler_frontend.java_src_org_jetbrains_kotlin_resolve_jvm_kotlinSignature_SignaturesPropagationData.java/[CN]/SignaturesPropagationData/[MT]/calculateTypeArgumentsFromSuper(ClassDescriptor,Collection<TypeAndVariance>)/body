{
  Multimap<TypeParameterDescriptor,TypeProjection> substitution=SubstitutionUtils.buildDeepSubstitutionMultimap(TypeUtils.makeUnsubstitutedType(klass,ErrorUtils.createErrorScope("Do not access this scope",true)));
  List<List<TypeProjectionAndVariance>> parameterToArgumentsFromSuper=Lists.newArrayList();
  for (  TypeParameterDescriptor ignored : klass.getTypeConstructor().getParameters()) {
    parameterToArgumentsFromSuper.add(new ArrayList<TypeProjectionAndVariance>());
  }
  for (  TypeAndVariance typeFromSuper : typesFromSuper) {
    for (    TypeParameterDescriptor parameter : typeFromSuper.type.getConstructor().getParameters()) {
      TypeProjection argument=typeFromSuper.type.getArguments().get(parameter.getIndex());
      for (      TypeProjection projection : substitution.get(parameter)) {
        ClassifierDescriptor classifier=projection.getType().getConstructor().getDeclarationDescriptor();
        if (classifier instanceof TypeParameterDescriptor && classifier.getContainingDeclaration() == klass) {
          int parameterIndex=((TypeParameterDescriptor)classifier).getIndex();
          Variance effectiveVariance=parameter.getVariance().superpose(typeFromSuper.varianceOfPosition);
          parameterToArgumentsFromSuper.get(parameterIndex).add(new TypeProjectionAndVariance(argument,effectiveVariance));
        }
      }
    }
  }
  return parameterToArgumentsFromSuper;
}
