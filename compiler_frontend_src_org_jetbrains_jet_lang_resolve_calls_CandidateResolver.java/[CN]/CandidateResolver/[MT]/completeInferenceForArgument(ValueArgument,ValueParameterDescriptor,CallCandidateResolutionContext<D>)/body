{
  ConstraintSystem constraintSystem=context.candidateCall.getConstraintSystem();
  JetExpression expression=argument.getArgumentExpression();
  if (expression == null)   return;
  JetType effectiveExpectedType=getEffectiveExpectedType(parameterDescriptor,argument);
  JetType expectedType=constraintSystem != null ? constraintSystem.getCurrentSubstitutor().substitute(effectiveExpectedType,Variance.INVARIANT) : effectiveExpectedType;
  context=context.replaceExpectedType(expectedType);
  JetExpression keyExpression=getDeferredComputationKeyExpression(expression);
  CallCandidateResolutionContext<FunctionDescriptor> storedContextForArgument=context.resolutionResultsCache.getDeferredComputation(keyExpression);
  if (storedContextForArgument == null) {
    PsiElement parent=expression.getParent();
    if (parent instanceof JetWhenExpression && expression == ((JetWhenExpression)parent).getSubjectExpression() || (expression instanceof JetFunctionLiteralExpression)) {
      return;
    }
    JetType type=argumentTypeResolver.updateResultArgumentTypeIfNotDenotable(context,expression);
    checkResultArgumentType(type,argument,context);
    return;
  }
  CallCandidateResolutionContext<FunctionDescriptor> contextForArgument=storedContextForArgument.replaceContextDependency(ContextDependency.INDEPENDENT).replaceBindingTrace(context.trace).replaceExpectedType(expectedType);
  JetType type;
  if (contextForArgument.candidateCall.hasIncompleteTypeParameters()) {
    type=completeTypeInferenceDependentOnExpectedTypeForCall(contextForArgument,true);
  }
 else {
    type=completeNestedCallsInference(contextForArgument);
    checkValueArgumentTypes(contextForArgument);
  }
  JetType result=BindingContextUtils.updateRecordedType(type,expression,context.trace,isFairSafeCallExpression(expression,context.trace));
  DataFlowUtils.checkType(result,expression,contextForArgument);
}
