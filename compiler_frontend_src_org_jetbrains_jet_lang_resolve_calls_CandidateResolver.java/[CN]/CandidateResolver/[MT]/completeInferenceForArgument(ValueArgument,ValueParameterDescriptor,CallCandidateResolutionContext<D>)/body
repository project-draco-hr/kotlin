{
  JetExpression expression=argument.getArgumentExpression();
  if (expression == null)   return;
  JetType expectedType=getEffectiveExpectedType(parameterDescriptor,argument);
  context=context.replaceExpectedType(expectedType);
  JetExpression keyExpression=getDeferredComputationKeyExpression(expression);
  CallCandidateResolutionContext<? extends CallableDescriptor> storedContextForArgument=context.resolutionResultsCache.getDeferredComputation(keyExpression);
  PsiElement parent=expression.getParent();
  if (parent instanceof JetWhenExpression && expression == ((JetWhenExpression)parent).getSubjectExpression() || (expression instanceof JetFunctionLiteralExpression)) {
    return;
  }
  if (storedContextForArgument == null) {
    JetType type=ArgumentTypeResolver.updateResultArgumentTypeIfNotDenotable(context,expression);
    checkResultArgumentType(type,argument,context);
    return;
  }
  CallCandidateResolutionContext<? extends CallableDescriptor> contextForArgument=storedContextForArgument.replaceContextDependency(INDEPENDENT).replaceBindingTrace(context.trace).replaceExpectedType(expectedType);
  JetType type;
  if (contextForArgument.candidateCall.hasIncompleteTypeParameters()) {
    type=completeTypeInferenceDependentOnExpectedTypeForCall(contextForArgument,true);
  }
 else {
    completeNestedCallsInference(contextForArgument);
    JetType recordedType=context.trace.get(BindingContext.EXPRESSION_TYPE,expression);
    if (recordedType != null && !recordedType.getConstructor().isDenotable()) {
      type=ArgumentTypeResolver.updateResultArgumentTypeIfNotDenotable(context,expression);
    }
 else {
      type=contextForArgument.candidateCall.getResultingDescriptor().getReturnType();
    }
    checkValueArgumentTypes(contextForArgument);
  }
  JetType result=BindingContextUtils.updateRecordedType(type,expression,context.trace,isFairSafeCallExpression(expression,context.trace));
  markResultingCallAsCompleted(context,keyExpression);
  DataFlowUtils.checkType(result,expression,contextForArgument);
}
