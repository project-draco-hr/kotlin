{
  JetExpression argumentExpression=valueArgument.getArgumentExpression();
  if (argumentExpression == null)   return;
  JetExpression deparenthesizedExpression=JetPsiUtil.deparenthesizeWithNoTypeResolution(argumentExpression,false);
  if (!(deparenthesizedExpression instanceof JetFunctionLiteralExpression))   return;
  JetFunctionLiteralExpression functionLiteralExpression=(JetFunctionLiteralExpression)deparenthesizedExpression;
  JetType effectiveExpectedType=getEffectiveExpectedType(valueParameterDescriptor,valueArgument);
  JetType expectedType=constraintSystem.getCurrentSubstitutor().substitute(effectiveExpectedType,Variance.INVARIANT);
  if (expectedType == null || !KotlinBuiltIns.getInstance().isFunctionOrExtensionFunctionType(expectedType) || CallResolverUtil.hasUnknownFunctionParameter(expectedType)) {
    return;
  }
  MutableDataFlowInfoForArguments dataFlowInfoForArguments=context.candidateCall.getDataFlowInfoForArguments();
  DataFlowInfo dataFlowInfoForArgument=dataFlowInfoForArguments.getInfo(valueArgument);
  boolean hasExpectedReturnType=!CallResolverUtil.hasUnknownReturnType(expectedType);
  if (hasExpectedReturnType) {
    TemporaryTraceAndCache temporaryToResolveFunctionLiteral=TemporaryTraceAndCache.create(context,"trace to resolve function literal with expected return type",argumentExpression);
    JetElement statementExpression=JetPsiUtil.getLastStatementInABlock(functionLiteralExpression.getBodyExpression());
    if (statementExpression == null)     return;
    boolean[] mismatch=new boolean[1];
    ObservableBindingTrace errorInterceptingTrace=ExpressionTypingUtils.makeTraceInterceptingTypeMismatch(temporaryToResolveFunctionLiteral.trace,statementExpression,mismatch);
    CallCandidateResolutionContext<D> newContext=context.replaceBindingTrace(errorInterceptingTrace).replaceExpectedType(expectedType).replaceDataFlowInfo(dataFlowInfoForArgument).replaceResolutionResultsCache(temporaryToResolveFunctionLiteral.cache);
    JetType type=argumentTypeResolver.getFunctionLiteralTypeInfo(argumentExpression,functionLiteralExpression,newContext,RESOLVE_FUNCTION_ARGUMENTS).getType();
    if (!mismatch[0]) {
      constraintSystem.addSubtypeConstraint(type,effectiveExpectedType,ConstraintPosition.getValueParameterPosition(valueParameterDescriptor.getIndex()));
      temporaryToResolveFunctionLiteral.commit();
      return;
    }
  }
  JetType expectedTypeWithoutReturnType=hasExpectedReturnType ? CallResolverUtil.replaceReturnTypeByUnknown(expectedType) : expectedType;
  CallCandidateResolutionContext<D> newContext=context.replaceExpectedType(expectedTypeWithoutReturnType).replaceDataFlowInfo(dataFlowInfoForArgument);
  JetType type=argumentTypeResolver.getFunctionLiteralTypeInfo(argumentExpression,functionLiteralExpression,newContext,RESOLVE_FUNCTION_ARGUMENTS).getType();
  constraintSystem.addSubtypeConstraint(type,effectiveExpectedType,ConstraintPosition.getValueParameterPosition(valueParameterDescriptor.getIndex()));
}
