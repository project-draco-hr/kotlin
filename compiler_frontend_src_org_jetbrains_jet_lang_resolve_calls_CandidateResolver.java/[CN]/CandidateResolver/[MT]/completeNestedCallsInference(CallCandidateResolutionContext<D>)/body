{
  ResolvedCallImpl<D> resolvedCall=context.candidateCall;
  ConstraintSystem constraintSystem=context.candidateCall.getConstraintSystem();
  for (  Map.Entry<ValueParameterDescriptor,ResolvedValueArgument> entry : resolvedCall.getValueArguments().entrySet()) {
    ValueParameterDescriptor parameterDescriptor=entry.getKey();
    ResolvedValueArgument resolvedArgument=entry.getValue();
    for (    ValueArgument argument : resolvedArgument.getArguments()) {
      JetExpression expression=argument.getArgumentExpression();
      if (expression == null)       continue;
      JetType effectiveExpectedType=getEffectiveExpectedType(parameterDescriptor,argument);
      JetType expectedType=constraintSystem != null ? constraintSystem.getCurrentSubstitutor().substitute(effectiveExpectedType,Variance.INVARIANT) : effectiveExpectedType;
      JetVisitor<JetExpression,Void> selectorExpressionFinder=new JetVisitor<JetExpression,Void>(){
        @Override public JetExpression visitQualifiedExpression(        JetQualifiedExpression expression,        Void data){
          JetExpression selector=expression.getSelectorExpression();
          return selector != null ? selector.accept(this,null) : null;
        }
        @Override public JetExpression visitExpression(        JetExpression expression,        Void data){
          return expression;
        }
      }
;
      JetExpression selectorExpression=expression.accept(selectorExpressionFinder,null);
      CallCandidateResolutionContext<FunctionDescriptor> storedContextForArgument=context.resolutionResultsCache.getDeferredComputation(CallKey.create(Call.CallType.DEFAULT,selectorExpression));
      if (storedContextForArgument == null) {
        PsiElement parent=expression.getParent();
        if (parent instanceof JetWhenExpression && expression == ((JetWhenExpression)parent).getSubjectExpression() || (expression instanceof JetFunctionLiteralExpression)) {
          continue;
        }
        JetType type=context.trace.get(BindingContext.EXPRESSION_TYPE,expression);
        ResolutionContext<?> newContext=context.replaceExpectedType(expectedType);
        DataFlowUtils.checkType(type,expression,newContext);
        continue;
      }
      CallCandidateResolutionContext<FunctionDescriptor> contextForArgument=storedContextForArgument.replaceResolveMode(ResolveMode.TOP_LEVEL_CALL).replaceBindingTrace(context.trace).replaceExpectedType(expectedType);
      JetType type;
      if (contextForArgument.candidateCall.hasIncompleteTypeParameters()) {
        type=completeTypeInferenceDependentOnExpectedTypeForCall(contextForArgument,true);
      }
 else {
        type=completeNestedCallsInference(contextForArgument);
        checkValueArgumentTypes(contextForArgument);
      }
      DataFlowUtils.checkType(type,expression,contextForArgument);
    }
  }
  recordReferenceForInvokeFunction(context);
  return resolvedCall.getResultingDescriptor().getReturnType();
}
