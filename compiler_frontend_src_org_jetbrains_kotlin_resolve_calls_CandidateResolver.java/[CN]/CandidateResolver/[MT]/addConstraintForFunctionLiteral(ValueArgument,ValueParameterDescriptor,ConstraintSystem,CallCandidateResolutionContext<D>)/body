{
  JetExpression argumentExpression=valueArgument.getArgumentExpression();
  if (argumentExpression == null)   return;
  if (!ArgumentTypeResolver.isFunctionLiteralArgument(argumentExpression,context))   return;
  JetFunction functionLiteral=ArgumentTypeResolver.getFunctionLiteralArgument(argumentExpression,context);
  JetType effectiveExpectedType=getEffectiveExpectedType(valueParameterDescriptor,valueArgument);
  JetType expectedType=constraintSystem.getCurrentSubstitutor().substitute(effectiveExpectedType,Variance.INVARIANT);
  if (expectedType == null || TypeUtils.isDontCarePlaceholder(expectedType)) {
    expectedType=argumentTypeResolver.getShapeTypeOfFunctionLiteral(functionLiteral,context.scope,context.trace,false);
  }
  if (expectedType == null || !KotlinBuiltIns.isFunctionOrExtensionFunctionType(expectedType) || CallResolverUtil.hasUnknownFunctionParameter(expectedType)) {
    return;
  }
  MutableDataFlowInfoForArguments dataFlowInfoForArguments=context.candidateCall.getDataFlowInfoForArguments();
  DataFlowInfo dataFlowInfoForArgument=dataFlowInfoForArguments.getInfo(valueArgument);
  boolean hasExpectedReturnType=!CallResolverUtil.hasUnknownReturnType(expectedType);
  if (hasExpectedReturnType) {
    TemporaryTraceAndCache temporaryToResolveFunctionLiteral=TemporaryTraceAndCache.create(context,"trace to resolve function literal with expected return type",argumentExpression);
    JetExpression statementExpression=JetPsiUtil.getExpressionOrLastStatementInBlock(functionLiteral.getBodyExpression());
    if (statementExpression == null)     return;
    boolean[] mismatch=new boolean[1];
    ObservableBindingTrace errorInterceptingTrace=ExpressionTypingUtils.makeTraceInterceptingTypeMismatch(temporaryToResolveFunctionLiteral.trace,statementExpression,mismatch);
    CallCandidateResolutionContext<D> newContext=context.replaceBindingTrace(errorInterceptingTrace).replaceExpectedType(expectedType).replaceDataFlowInfo(dataFlowInfoForArgument).replaceResolutionResultsCache(temporaryToResolveFunctionLiteral.cache).replaceContextDependency(INDEPENDENT);
    JetType type=argumentTypeResolver.getFunctionLiteralTypeInfo(argumentExpression,functionLiteral,newContext,RESOLVE_FUNCTION_ARGUMENTS).getType();
    if (!mismatch[0]) {
      constraintSystem.addSubtypeConstraint(type,effectiveExpectedType,VALUE_PARAMETER_POSITION.position(valueParameterDescriptor.getIndex()));
      temporaryToResolveFunctionLiteral.commit();
      return;
    }
  }
  JetType expectedTypeWithoutReturnType=hasExpectedReturnType ? CallResolverUtil.replaceReturnTypeByUnknown(expectedType) : expectedType;
  CallCandidateResolutionContext<D> newContext=context.replaceExpectedType(expectedTypeWithoutReturnType).replaceDataFlowInfo(dataFlowInfoForArgument).replaceContextDependency(INDEPENDENT);
  JetType type=argumentTypeResolver.getFunctionLiteralTypeInfo(argumentExpression,functionLiteral,newContext,RESOLVE_FUNCTION_ARGUMENTS).getType();
  constraintSystem.addSubtypeConstraint(type,effectiveExpectedType,VALUE_PARAMETER_POSITION.position(valueParameterDescriptor.getIndex()));
}
