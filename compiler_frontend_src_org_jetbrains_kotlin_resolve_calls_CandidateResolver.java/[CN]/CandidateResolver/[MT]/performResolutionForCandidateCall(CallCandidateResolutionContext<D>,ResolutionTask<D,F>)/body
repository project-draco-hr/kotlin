{
  ProgressIndicatorAndCompilationCanceledStatus.checkCanceled();
  MutableResolvedCall<D> candidateCall=context.candidateCall;
  D candidate=candidateCall.getCandidateDescriptor();
  candidateCall.addStatus(checkReceiverTypeError(context));
  if (ErrorUtils.isError(candidate)) {
    candidateCall.addStatus(SUCCESS);
    return;
  }
  if (!checkOuterClassMemberIsAccessible(context)) {
    candidateCall.addStatus(OTHER_ERROR);
    return;
  }
  ReceiverValue receiverValue=ExpressionTypingUtils.normalizeReceiverValueForVisibility(candidateCall.getDispatchReceiver(),context.trace.getBindingContext());
  DeclarationDescriptorWithVisibility invisibleMember=Visibilities.findInvisibleMember(receiverValue,candidate,context.scope.getContainingDeclaration());
  if (invisibleMember != null) {
    candidateCall.addStatus(OTHER_ERROR);
    context.tracing.invisibleMember(context.trace,invisibleMember);
  }
  if (task.checkArguments == CheckValueArgumentsMode.ENABLED) {
    ValueArgumentsToParametersMapper.Status argumentMappingStatus=ValueArgumentsToParametersMapper.mapValueArgumentsToParameters(context.call,context.tracing,candidateCall,Sets.<ValueArgument>newLinkedHashSet());
    if (!argumentMappingStatus.isSuccess()) {
      candidateCall.addStatus(OTHER_ERROR);
    }
  }
  checkExtensionReceiver(context);
  if (!checkDispatchReceiver(context)) {
    candidateCall.addStatus(OTHER_ERROR);
  }
  List<JetTypeProjection> jetTypeArguments=context.call.getTypeArguments();
  if (!jetTypeArguments.isEmpty()) {
    List<JetType> typeArguments=new ArrayList<JetType>();
    for (    JetTypeProjection projection : jetTypeArguments) {
      if (projection.getProjectionKind() != JetProjectionKind.NONE) {
        context.trace.report(PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT.on(projection));
        ModifiersChecker.checkIncompatibleVarianceModifiers(projection.getModifierList(),context.trace);
      }
      JetType type=argumentTypeResolver.resolveTypeRefWithDefault(projection.getTypeReference(),context.scope,context.trace,ErrorUtils.createErrorType("Star projection in a call"));
      ForceResolveUtil.forceResolveAllContents(type);
      typeArguments.add(type);
    }
    int expectedTypeArgumentCount=candidate.getTypeParameters().size();
    for (int index=jetTypeArguments.size(); index < expectedTypeArgumentCount; index++) {
      typeArguments.add(ErrorUtils.createErrorType("Explicit type argument expected for " + candidate.getTypeParameters().get(index).getName()));
    }
    Map<TypeConstructor,TypeProjection> substitutionContext=FunctionDescriptorUtil.createSubstitutionContext((FunctionDescriptor)candidate,typeArguments);
    TypeSubstitutor substitutor=TypeSubstitutor.create(substitutionContext);
    if (expectedTypeArgumentCount != jetTypeArguments.size()) {
      candidateCall.addStatus(OTHER_ERROR);
      context.tracing.wrongNumberOfTypeArguments(context.trace,expectedTypeArgumentCount);
    }
 else {
      checkGenericBoundsInAFunctionCall(jetTypeArguments,typeArguments,candidate,substitutor,context.trace);
    }
    candidateCall.setResultingSubstitutor(substitutor);
  }
 else   if (candidateCall.getKnownTypeParametersSubstitutor() != null) {
    candidateCall.setResultingSubstitutor(candidateCall.getKnownTypeParametersSubstitutor());
  }
  if (jetTypeArguments.isEmpty() && !candidate.getTypeParameters().isEmpty() && candidateCall.getKnownTypeParametersSubstitutor() == null) {
    candidateCall.addStatus(genericCandidateResolver.inferTypeArguments(context));
  }
 else {
    candidateCall.addStatus(checkAllValueArguments(context,SHAPE_FUNCTION_ARGUMENTS).status);
  }
  checkAbstractAndSuper(context);
  checkNonExtensionCalledWithReceiver(context);
}
