{
  if (ApplicationManager.getApplication().isInternal())   return;
  String runtimeVersion=getRuntimeVersion(getKotlinRuntimeJar());
  if (runtimeVersion == null)   return;
  final String sdkVersion=getRuntimeVersion(getRuntimeFromSdk());
  if (sdkVersion == null || "snapshot".equals(sdkVersion))   return;
  if (sdkVersion.equals(PropertiesComponent.getInstance(myModule.getProject()).getValue(mySuppressedPropertyName)))   return;
  boolean isRuntimeOutdated="snapshot".equals(runtimeVersion) || UNKNOWN_VERSION.equals(runtimeVersion) || runtimeVersion.startsWith("internal-") != sdkVersion.startsWith("internal-") || VersionComparatorUtil.compare(sdkVersion,runtimeVersion) > 0;
  if (!isRuntimeOutdated)   return;
  String message=String.format("<p>Your version of Kotlin runtime library in module \"%s\" is %s, while Kotlin SDK version in this module is %s." + " Runtime library should be updated to avoid compatibility problems.</p>" + "<p><a href=\"update\">Update Runtime</a> <a href=\"ignore\">Ignore</a></p>",myModule.getName(),UNKNOWN_VERSION.equals(runtimeVersion) ? "older than 0.1.2296" : runtimeVersion,sdkVersion);
  Notifications.Bus.notify(new Notification("Outdated Kotlin Runtime","Outdated Kotlin Runtime",message,NotificationType.WARNING,new NotificationListener(){
    @Override public void hyperlinkUpdate(    @NotNull Notification notification,    @NotNull HyperlinkEvent event){
      if (event.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
        if ("update".equals(event.getDescription())) {
          updateRuntime();
        }
 else         if ("ignore".equals(event.getDescription())) {
          PropertiesComponent.getInstance(myModule.getProject()).setValue(mySuppressedPropertyName,sdkVersion);
        }
 else {
          throw new AssertionError();
        }
        notification.expire();
      }
    }
  }
),myModule.getProject());
}
