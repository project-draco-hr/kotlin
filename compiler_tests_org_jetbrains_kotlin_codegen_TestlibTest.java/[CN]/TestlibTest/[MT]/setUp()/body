{
  super.setUp();
  CompilerConfiguration configuration=JetTestUtils.compilerConfigurationForTests(ConfigurationKind.ALL,TestJdkKind.FULL_JDK);
  JvmContentRootsKt.addJvmClasspathRoot(configuration,JetTestUtils.getAnnotationsJar());
  junitJar=new File("libraries/lib/junit-4.11.jar");
  assertTrue(junitJar.exists());
  JvmContentRootsKt.addJvmClasspathRoot(configuration,junitJar);
  ContentRootsKt.addKotlinSourceRoot(configuration,JetTestUtils.getHomeDirectory() + "/libraries/stdlib/test");
  ContentRootsKt.addKotlinSourceRoot(configuration,JetTestUtils.getHomeDirectory() + "/libraries/kunit/src");
  configuration.put(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY,PrintingMessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);
  myEnvironment=KotlinCoreEnvironment.createForTests(getTestRootDisposable(),configuration,EnvironmentConfigFiles.JVM_CONFIG_FILES);
  generationState=KotlinToJVMBytecodeCompiler.analyzeAndGenerate(myEnvironment);
  if (generationState == null) {
    throw new RuntimeException("There were compilation errors");
  }
  classLoader=new GeneratedClassLoader(generationState.getFactory(),ForTestCompileRuntime.runtimeAndReflectJarClassLoader()){
    @Override public Class<?> loadClass(    @NotNull String name) throws ClassNotFoundException {
      if (name.startsWith("junit.") || name.startsWith("org.junit.")) {
        return TestlibTest.class.getClassLoader().loadClass(name);
      }
      return super.loadClass(name);
    }
  }
;
  typeMapper=generationState.getTypeMapper();
  for (  JetFile jetFile : myEnvironment.getSourceFiles()) {
    for (    JetDeclaration declaration : jetFile.getDeclarations()) {
      if (!(declaration instanceof JetClass))       continue;
      ClassDescriptor descriptor=(ClassDescriptor)BindingContextUtils.getNotNull(generationState.getBindingContext(),BindingContext.DECLARATION_TO_DESCRIPTOR,declaration);
      for (      JetType superType : getAllSupertypes(descriptor.getDefaultType())) {
        if (!"junit/framework/Test".equals(typeMapper.mapType(superType).getInternalName()))         continue;
        String name=typeMapper.mapClass(descriptor).getInternalName();
        System.out.println(name);
        @SuppressWarnings("unchecked") Class<TestCase> aClass=(Class<TestCase>)classLoader.loadClass(name.replace('/','.'));
        if (!Modifier.isAbstract(aClass.getModifiers()) && Modifier.isPublic(aClass.getModifiers())) {
          try {
            if (Modifier.isPublic(aClass.getConstructor().getModifiers())) {
              suite.addTestSuite(aClass);
            }
          }
 catch (          NoSuchMethodException e) {
          }
        }
        break;
      }
    }
  }
}
