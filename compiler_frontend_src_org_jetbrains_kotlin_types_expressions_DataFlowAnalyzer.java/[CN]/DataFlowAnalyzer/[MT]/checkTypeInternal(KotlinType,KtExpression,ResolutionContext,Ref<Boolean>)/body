{
  if (noExpectedType(c.expectedType) || !c.expectedType.getConstructor().isDenotable() || KotlinTypeChecker.DEFAULT.isSubtypeOf(expressionType,c.expectedType)) {
    return expressionType;
  }
  if (expression instanceof KtConstantExpression) {
    ConstantValue<?> constantValue=constantExpressionEvaluator.evaluateToConstantValue(expression,c.trace,c.expectedType);
    boolean error=new CompileTimeConstantChecker(c.trace,builtIns,true).checkConstantExpressionType(constantValue,(KtConstantExpression)expression,c.expectedType);
    if (hasError != null)     hasError.set(error);
    return expressionType;
  }
  if (expression instanceof KtWhenExpression) {
    return expressionType;
  }
  SmartCastResult castResult=checkPossibleCast(expressionType,expression,c);
  if (castResult != null)   return castResult.getResultType();
  c.trace.report(TYPE_MISMATCH.on(expression,c.expectedType,expressionType));
  if (hasError != null)   hasError.set(true);
  return expressionType;
}
