{
  final List<TypeParameterDescriptor> typeParameters=functionDescriptor.getTypeParameters();
  if (typeParameters.isEmpty())   return functionDescriptor;
  final Map<TypeConstructor,TypeParameterDescriptor> typeConstructors=Maps.newHashMap();
  for (  TypeParameterDescriptor typeParameter : typeParameters) {
    typeConstructors.put(typeParameter.getTypeConstructor(),typeParameter);
  }
  return functionDescriptor.substitute(new TypeSubstitutor(TypeSubstitution.EMPTY){
    @Override public boolean inRange(    @NotNull TypeConstructor typeConstructor){
      return typeConstructors.containsKey(typeConstructor);
    }
    @Override public boolean isEmpty(){
      return typeParameters.isEmpty();
    }
    @NotNull @Override public TypeSubstitution getSubstitution(){
      throw new UnsupportedOperationException();
    }
    @NotNull @Override public JetType safeSubstitute(    @NotNull JetType type,    @NotNull Variance howThisTypeIsUsed){
      JetType substituted=substitute(type,howThisTypeIsUsed);
      if (substituted == null) {
        return ErrorUtils.createErrorType("Substitution failed");
      }
      return substituted;
    }
    @Override public JetType substitute(    @NotNull JetType type,    @NotNull Variance howThisTypeIsUsed){
      TypeParameterDescriptor typeParameterDescriptor=typeConstructors.get(type.getConstructor());
      if (typeParameterDescriptor != null) {
switch (howThisTypeIsUsed) {
case INVARIANT:
          return type;
case IN_VARIANCE:
        throw new UnsupportedOperationException();
case OUT_VARIANCE:
      return typeParameterDescriptor.getDefaultType();
  }
}
return super.substitute(type,howThisTypeIsUsed);
}
}
);
}
