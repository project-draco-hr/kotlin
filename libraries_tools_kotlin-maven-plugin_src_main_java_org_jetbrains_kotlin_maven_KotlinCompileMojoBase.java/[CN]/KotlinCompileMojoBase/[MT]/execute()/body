{
  getLog().info("Kotlin Compiler version " + KotlinVersion.VERSION);
  if (!hasKotlinFilesInSources()) {
    getLog().warn("No sources found skipping Kotlin compile");
    return;
  }
  A arguments=createCompilerArguments();
  CLICompiler<A> compiler=createCompiler();
  configureCompilerArguments(arguments,compiler);
  printCompilerArgumentsIfDebugEnabled(arguments,compiler);
  MessageCollector messageCollector=new MessageCollector(){
    @Override public void report(    @NotNull CompilerMessageSeverity severity,    @NotNull String message,    @NotNull CompilerMessageLocation location){
      String path=location.getPath();
      String position=path == null ? "" : path + ": (" + (location.getLine() + ", " + location.getColumn())+ ") ";
      String text=position + message;
      if (CompilerMessageSeverity.VERBOSE.contains(severity)) {
        getLog().debug(text);
      }
 else       if (CompilerMessageSeverity.ERRORS.contains(severity)) {
        getLog().error(text);
      }
 else       if (severity == CompilerMessageSeverity.INFO) {
        getLog().info(text);
      }
 else {
        getLog().warn(text);
      }
    }
  }
;
  ExitCode exitCode=executeCompiler(compiler,arguments,messageCollector);
switch (exitCode) {
case COMPILATION_ERROR:
    throw new MojoExecutionException("Compilation error. See log for more details");
case INTERNAL_ERROR:
  throw new MojoExecutionException("Internal compiler error. See log for more details");
default :
}
}
