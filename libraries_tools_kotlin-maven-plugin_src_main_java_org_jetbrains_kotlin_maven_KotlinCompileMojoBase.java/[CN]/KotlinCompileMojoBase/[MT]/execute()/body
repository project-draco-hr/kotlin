{
  LOG.info("Kotlin Compiler version " + KotlinVersion.VERSION);
  if (!hasKotlinFilesInSources()) {
    LOG.warn("No sources found skipping Kotlin compile");
    return;
  }
  A arguments=createCompilerArguments();
  configureCompilerArguments(arguments);
  CLICompiler<A> compiler=createCompiler();
  printCompilerArgumentsIfDebugEnabled(arguments,compiler);
  MessageCollector messageCollector=new MessageCollector(){
    @Override public void report(    @NotNull CompilerMessageSeverity severity,    @NotNull String message,    @NotNull CompilerMessageLocation location){
      String path=location.getPath();
      String position=path == null ? "" : path + ": (" + (location.getLine() + ", " + location.getColumn())+ ") ";
      String text=position + message;
      if (CompilerMessageSeverity.VERBOSE.contains(severity)) {
        LOG.debug(text);
      }
 else       if (CompilerMessageSeverity.ERRORS.contains(severity)) {
        LOG.error(text);
      }
 else       if (severity == CompilerMessageSeverity.INFO) {
        LOG.info(text);
      }
 else {
        LOG.warn(text);
      }
    }
  }
;
  ExitCode exitCode=executeCompiler(compiler,arguments,messageCollector);
switch (exitCode) {
case COMPILATION_ERROR:
    throw new MojoExecutionException("Compilation error. See log for more details");
case INTERNAL_ERROR:
  throw new MojoExecutionException("Internal compiler error. See log for more details");
default :
}
}
