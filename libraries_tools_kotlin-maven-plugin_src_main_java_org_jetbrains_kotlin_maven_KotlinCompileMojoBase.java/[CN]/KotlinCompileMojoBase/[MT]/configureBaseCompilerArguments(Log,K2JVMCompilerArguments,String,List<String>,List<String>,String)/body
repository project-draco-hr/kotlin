{
  arguments.noStdlib=true;
  final ArrayList<String> classpathList=new ArrayList<String>();
  if (module != null) {
    log.info("Compiling Kotlin module " + module);
    arguments.module=module;
  }
 else {
    if (sources.isEmpty())     throw new MojoExecutionException("No source roots to compile");
    arguments.freeArgs.addAll(sources);
    log.info("Compiling Kotlin sources from " + sources);
    classpathList.addAll(sources);
  }
  classpathList.addAll(classpath);
  if (classpathList.remove(output)) {
    log.debug("Removed target directory from compiler classpath (" + output + ")");
  }
  if (classpathList.size() > 0) {
    String classPathString=join(classpathList,File.pathSeparator);
    log.info("Classpath: " + classPathString);
    arguments.classpath=classPathString;
  }
  log.info("Classes directory is " + output);
  arguments.destination=output;
  arguments.noJdkAnnotations=true;
  arguments.annotations=getFullAnnotationsPath(log,annotationPaths);
  log.info("Using kotlin annotations from " + arguments.annotations);
  arguments.inline=inline;
  arguments.optimize=optimize;
  if (!CompilerArgumentsUtil.checkOption(arguments.inline)) {
    throw new MojoExecutionException(CompilerArgumentsUtil.getWrongCheckOptionErrorMessage("inline",arguments.inline));
  }
  if (!CompilerArgumentsUtil.checkOption(arguments.optimize)) {
    throw new MojoExecutionException(CompilerArgumentsUtil.getWrongCheckOptionErrorMessage("optimize",arguments.optimize));
  }
  log.info("Method inlining is " + CompilerArgumentsUtil.optionToBooleanFlag(arguments.inline,InlineCodegenUtil.DEFAULT_INLINE_FLAG));
  log.info("Optimization mode is " + CompilerArgumentsUtil.optionToBooleanFlag(arguments.optimize,OptimizationUtils.DEFAULT_OPTIMIZATION_FLAG));
}
