{
  arguments.noStdlib=true;
  final ArrayList<String> classpathList=new ArrayList<String>();
  if (module != null) {
    log.info("Compiling Kotlin module " + module);
    arguments.module=module;
  }
 else {
    if (sources.isEmpty())     throw new MojoExecutionException("No source roots to compile");
    arguments.freeArgs.addAll(sources);
    log.info("Compiling Kotlin sources from " + sources);
    classpathList.addAll(sources);
  }
  classpathList.addAll(classpath);
  if (classpathList.remove(output)) {
    log.debug("Removed target directory from compiler classpath (" + output + ")");
  }
  if (classpathList.size() > 0) {
    String classPathString=join(classpathList,File.pathSeparator);
    log.info("Classpath: " + classPathString);
    arguments.classpath=classPathString;
  }
  log.info("Classes directory is " + output);
  arguments.destination=output;
  arguments.noJdkAnnotations=true;
  arguments.annotations=getFullAnnotationsPath(log,annotationPaths);
  log.info("Using kotlin annotations from " + arguments.annotations);
  arguments.noInline=!CompilerArgumentsUtil.optionToBooleanFlag(inline,true);
  arguments.noOptimize=!CompilerArgumentsUtil.optionToBooleanFlag(optimize,true);
  if (!CompilerArgumentsUtil.checkOption(inline)) {
    throw new MojoExecutionException(CompilerArgumentsUtil.getWrongCheckOptionErrorMessage("inline",inline));
  }
  if (!CompilerArgumentsUtil.checkOption(optimize)) {
    throw new MojoExecutionException(CompilerArgumentsUtil.getWrongCheckOptionErrorMessage("optimize",optimize));
  }
  if (arguments.noInline) {
    log.info("Method inlining is turned off");
  }
  if (arguments.noOptimize) {
    log.info("Optimization is turned off");
  }
}
