{
  arguments.mode="stdlib";
  if (module != null) {
    log.info("Compiling Kotlin module " + module);
    arguments.setModule(module);
  }
 else {
    if (sources.size() <= 0)     throw new MojoExecutionException("No source roots to compile");
    arguments.setSourceDirs(sources);
    log.info("Compiling Kotlin sources from " + arguments.getSourceDirs());
  }
  final ArrayList<String> classpathList=new ArrayList<String>(classpath);
  if (classpathList.remove(output)) {
    log.debug("Removed target directory from compiler classpath (" + output + ")");
  }
  final String runtime=getRuntimeFromClassPath(classpath);
  if (runtime != null) {
    log.debug("Removed Kotlin runtime from compiler classpath (" + runtime + ")");
    classpathList.remove(runtime);
  }
  if (classpathList.size() > 0) {
    final String classPathString=Joiner.on(File.pathSeparator).join(classpathList);
    log.info("Classpath: " + classPathString);
    arguments.setClasspath(classPathString);
  }
  log.info("Classes directory is " + output);
  arguments.setOutputDir(output);
  arguments.jdkHeaders=getJdkHeaders().getPath();
  log.debug("Using jdk headers from " + arguments.jdkHeaders);
}
