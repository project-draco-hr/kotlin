{
  List<FqName> affectedClasses=getClassesToValidate();
  Map<String,List<String>> errors=Maps.newLinkedHashMap();
  for (int chunkIndex=0; chunkIndex < affectedClasses.size() / CLASSES_IN_CHUNK + 1; chunkIndex++) {
    Disposable parentDisposable=Disposer.newDisposable();
    try {
      KotlinCoreEnvironment commonEnvironment=createEnvironment(parentDisposable);
      BindingTrace trace=new CliLightClassGenerationSupport.NoScopeRecordCliBindingTrace();
      ModuleDescriptor module=LazyResolveTestUtil.resolve(commonEnvironment.getProject(),trace,Collections.<JetFile>emptyList(),commonEnvironment);
      AlternativeSignatureErrorFindingVisitor visitor=new AlternativeSignatureErrorFindingVisitor(trace.getBindingContext(),errors);
      int chunkStart=chunkIndex * CLASSES_IN_CHUNK;
      for (      FqName javaClass : affectedClasses.subList(chunkStart,Math.min(chunkStart + CLASSES_IN_CHUNK,affectedClasses.size()))) {
        ClassDescriptor topLevelClass=resolveTopLevelClass(module,javaClass,NoLookupLocation.FROM_TEST);
        PackageViewDescriptor topLevelPackage=module.getPackage(javaClass);
        if (topLevelClass == null) {
          continue;
        }
        topLevelClass.acceptVoid(visitor);
        if (!topLevelPackage.isEmpty()) {
          topLevelPackage.acceptVoid(visitor);
        }
      }
    }
  finally {
      Disposer.dispose(parentDisposable);
    }
  }
  if (!errors.isEmpty()) {
    StringBuilder sb=new StringBuilder("Error(s) in SDK alternative signatures: \n");
    for (    Map.Entry<String,List<String>> entry : errors.entrySet()) {
      sb.append(entry.getKey()).append(" : ").append(entry.getValue()).append("\n");
    }
    fail(sb.toString());
  }
}
