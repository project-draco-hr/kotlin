{
  List<FqName> affectedClasses=getClassesToValidate();
  Map<String,List<String>> errors=Maps.newLinkedHashMap();
  for (int chunkIndex=0; chunkIndex < affectedClasses.size() / CLASSES_IN_CHUNK + 1; chunkIndex++) {
    Disposable parentDisposable=Disposer.newDisposable();
    try {
      JetCoreEnvironment commonEnvironment=createEnvironment(parentDisposable);
      BindingTrace trace=new CliLightClassGenerationSupport.NoScopeRecordCliBindingTrace();
      InjectorForJavaDescriptorResolver injector=InjectorForJavaDescriptorResolverUtil.create(commonEnvironment.getProject(),trace,false);
      BindingContext bindingContext=trace.getBindingContext();
      AlternativeSignatureErrorFindingVisitor visitor=new AlternativeSignatureErrorFindingVisitor(bindingContext,errors);
      int chunkStart=chunkIndex * CLASSES_IN_CHUNK;
      for (      FqName javaClass : affectedClasses.subList(chunkStart,Math.min(chunkStart + CLASSES_IN_CHUNK,affectedClasses.size()))) {
        ClassDescriptor topLevelClass=ResolvePackage.resolveTopLevelClass(injector.getModule(),javaClass);
        PackageViewDescriptor topLevelPackage=injector.getModule().getPackage(javaClass);
        if (topLevelClass == null) {
          continue;
        }
        topLevelClass.acceptVoid(visitor);
        if (topLevelPackage != null) {
          topLevelPackage.acceptVoid(visitor);
        }
      }
    }
  finally {
      Disposer.dispose(parentDisposable);
    }
  }
  if (!errors.isEmpty()) {
    StringBuilder sb=new StringBuilder("Error(s) in SDK alternative signatures: \n");
    for (    Map.Entry<String,List<String>> entry : errors.entrySet()) {
      sb.append(entry.getKey()).append(" : ").append(entry.getValue()).append("\n");
    }
    fail(sb.toString());
  }
}
