{
  PsiBuilder.Marker pattern=mark();
  myJetParsing.parseAttributeList();
  if (at(NAMESPACE_KEYWORD) || at(IDENTIFIER) || at(LBRACE)|| at(THIS_KEYWORD)) {
    PsiBuilder.Marker rollbackMarker=mark();
    parseBinaryExpression(Precedence.ELVIS);
    if (at(AT)) {
      rollbackMarker.drop();
      advance();
      PsiBuilder.Marker list=mark();
      parseTuplePattern(DECOMPOSER_ARGUMENT);
      list.done(DECOMPOSER_ARGUMENT_LIST);
      pattern.done(DECOMPOSER_PATTERN);
    }
 else {
      int expressionEndOffset=myBuilder.getCurrentOffset();
      rollbackMarker.rollbackTo();
      rollbackMarker=mark();
      myJetParsing.parseTypeRef();
      if (at(AT)) {
        errorAndAdvance("'@' is allowed only after a decomposer element, not after a type");
      }
      if (myBuilder.getCurrentOffset() < expressionEndOffset) {
        rollbackMarker.rollbackTo();
        parseBinaryExpression(Precedence.ELVIS);
        pattern.done(DECOMPOSER_PATTERN);
      }
 else {
        rollbackMarker.drop();
        pattern.done(TYPE_PATTERN);
      }
    }
  }
 else   if (at(LPAR)) {
    parseTuplePattern(TUPLE_PATTERN_ENTRY);
    pattern.done(TUPLE_PATTERN);
  }
 else   if (at(MUL)) {
    advance();
    pattern.done(WILDCARD_PATTERN);
  }
 else   if (at(VAL_KEYWORD)) {
    parseBindingPattern();
    pattern.done(BINDING_PATTERN);
  }
 else   if (parseLiteralConstant()) {
    pattern.done(EXPRESSION_PATTERN);
  }
 else {
    errorUntil("Pattern expected",TokenSet.create(RBRACE,DOUBLE_ARROW));
    pattern.drop();
  }
}
