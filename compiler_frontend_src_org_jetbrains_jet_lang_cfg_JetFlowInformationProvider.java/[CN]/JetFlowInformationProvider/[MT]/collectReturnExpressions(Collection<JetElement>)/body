{
  final Set<Instruction> instructions=Sets.newHashSet(pseudocode.getInstructions());
  SubroutineExitInstruction exitInstruction=pseudocode.getExitInstruction();
  for (  Instruction previousInstruction : exitInstruction.getPreviousInstructions()) {
    previousInstruction.accept(new InstructionVisitor(){
      @Override public void visitReturnValue(      ReturnValueInstruction instruction){
        if (instructions.contains(instruction)) {
          returnedExpressions.add(instruction.getElement());
        }
      }
      @Override public void visitReturnNoValue(      ReturnNoValueInstruction instruction){
        if (instructions.contains(instruction)) {
          returnedExpressions.add(instruction.getElement());
        }
      }
      @Override public void visitJump(      AbstractJumpInstruction instruction){
      }
      @Override public void visitUnconditionalJump(      UnconditionalJumpInstruction instruction){
        redirectToPrevInstructions(instruction);
      }
      private void redirectToPrevInstructions(      Instruction instruction){
        for (        Instruction previousInstruction : instruction.getPreviousInstructions()) {
          previousInstruction.accept(this);
        }
      }
      @Override public void visitNondeterministicJump(      NondeterministicJumpInstruction instruction){
        redirectToPrevInstructions(instruction);
      }
      @Override public void visitInstruction(      Instruction instruction){
        if (instruction instanceof JetElementInstruction) {
          JetElementInstruction elementInstruction=(JetElementInstruction)instruction;
          returnedExpressions.add(elementInstruction.getElement());
        }
 else {
          throw new IllegalStateException(instruction + " precedes the exit point");
        }
      }
    }
);
  }
}
