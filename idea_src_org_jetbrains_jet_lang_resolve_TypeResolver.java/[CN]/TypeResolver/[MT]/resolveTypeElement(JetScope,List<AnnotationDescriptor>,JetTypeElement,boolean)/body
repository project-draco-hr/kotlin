{
  final JetType[] result=new JetType[1];
  if (typeElement != null) {
    typeElement.accept(new JetVisitor(){
      @Override public void visitUserType(      JetUserType type){
        JetSimpleNameExpression referenceExpression=type.getReferenceExpression();
        String referencedName=type.getReferencedName();
        if (referenceExpression == null || referencedName == null) {
          return;
        }
        ClassifierDescriptor classifierDescriptor=resolveClass(scope,type);
        if (classifierDescriptor != null) {
          if (classifierDescriptor instanceof TypeParameterDescriptor) {
            TypeParameterDescriptor typeParameterDescriptor=(TypeParameterDescriptor)classifierDescriptor;
            trace.recordReferenceResolution(referenceExpression,typeParameterDescriptor);
            result[0]=new JetTypeImpl(annotations,typeParameterDescriptor.getTypeConstructor(),nullable || TypeUtils.hasNullableBound(typeParameterDescriptor),Collections.<TypeProjection>emptyList(),getScopeForTypeParameter(typeParameterDescriptor));
          }
 else           if (classifierDescriptor instanceof ClassDescriptor) {
            ClassDescriptor classDescriptor=(ClassDescriptor)classifierDescriptor;
            trace.recordReferenceResolution(referenceExpression,classifierDescriptor);
            TypeConstructor typeConstructor=classifierDescriptor.getTypeConstructor();
            List<TypeProjection> arguments=resolveTypeProjections(scope,typeConstructor,type.getTypeArguments());
            List<TypeParameterDescriptor> parameters=typeConstructor.getParameters();
            int expectedArgumentCount=parameters.size();
            int actualArgumentCount=arguments.size();
            if (ErrorUtils.isError(typeConstructor)) {
              result[0]=new JetTypeImpl(annotations,typeConstructor,nullable,arguments,classDescriptor.getMemberScope(Collections.<TypeProjection>emptyList()));
            }
 else {
              if (actualArgumentCount != expectedArgumentCount) {
                String errorMessage=(expectedArgumentCount == 0 ? "No" : expectedArgumentCount) + " type arguments expected";
                if (actualArgumentCount == 0) {
                  trace.getErrorHandler().genericError(type.getNode(),errorMessage);
                }
 else                 if (expectedArgumentCount == 0) {
                  trace.getErrorHandler().genericError(type.getTypeArgumentList().getNode(),errorMessage);
                }
              }
 else {
                result[0]=new JetTypeImpl(annotations,typeConstructor,nullable,arguments,classDescriptor.getMemberScope(arguments));
                if (checkBounds) {
                  TypeSubstitutor substitutor=TypeSubstitutor.create(result[0]);
                  for (int i=0, parametersSize=parameters.size(); i < parametersSize; i++) {
                    TypeParameterDescriptor parameter=parameters.get(i);
                    JetType argument=arguments.get(i).getType();
                    JetTypeReference typeReference=type.getTypeArguments().get(i).getTypeReference();
                    if (typeReference != null) {
                      semanticServices.getClassDescriptorResolver(trace).checkBounds(typeReference,argument,parameter,substitutor);
                    }
                  }
                }
              }
            }
          }
        }
      }
      @Override public void visitNullableType(      JetNullableType nullableType){
        result[0]=resolveTypeElement(scope,annotations,nullableType.getInnerType(),true);
      }
      @Override public void visitTupleType(      JetTupleType type){
        result[0]=JetStandardClasses.getTupleType(resolveTypes(scope,type.getComponentTypeRefs()));
      }
      @Override public void visitFunctionType(      JetFunctionType type){
        JetTypeReference receiverTypeRef=type.getReceiverTypeRef();
        JetType receiverType=receiverTypeRef == null ? null : resolveType(scope,receiverTypeRef);
        List<JetType> parameterTypes=new ArrayList<JetType>();
        for (        JetParameter parameter : type.getParameters()) {
          parameterTypes.add(resolveType(scope,parameter.getTypeReference()));
        }
        JetTypeReference returnTypeRef=type.getReturnTypeRef();
        if (returnTypeRef != null) {
          JetType returnType=resolveType(scope,returnTypeRef);
          result[0]=JetStandardClasses.getFunctionType(annotations,receiverType,parameterTypes,returnType);
        }
      }
      @Override public void visitJetElement(      JetElement element){
        throw new IllegalArgumentException("Unsupported type: " + element);
      }
    }
);
  }
  if (result[0] == null) {
    return ErrorUtils.createErrorType(typeElement == null ? "No type element" : typeElement.getText());
  }
  return result[0];
}
