{
  if (tryCatchBlock.getOnlyCopyNotProcess()) {
    AbstractInsnNode start=new LabelNode();
    AbstractInsnNode end=new LabelNode();
    InsnList insnList=new InsnList();
    insnList.add(start);
    insnList.add(end);
    return new FinallyBlockInfo(start,end);
  }
  List<TryCatchBlockNodeInfo> sameDefaultHandler=new ArrayList<TryCatchBlockNodeInfo>();
  LabelNode defaultHandler=null;
  boolean afterStartBlock=false;
  for (  TryCatchBlockNodeInfo block : tryCatchBlocks) {
    if (tryCatchBlock == block) {
      afterStartBlock=true;
    }
    if (afterStartBlock) {
      if (block.getNode().type == null && (firstLabelInChain(tryCatchBlock.getNode().start) == firstLabelInChain(block.getNode().start) && firstLabelInChain(tryCatchBlock.getNode().end) == firstLabelInChain(block.getNode().end) || defaultHandler == firstLabelInChain(block.getNode().handler))) {
        sameDefaultHandler.add(block);
        if (defaultHandler == null) {
          defaultHandler=firstLabelInChain(block.getNode().handler);
        }
      }
    }
  }
  if (sameDefaultHandler.isEmpty()) {
    return null;
  }
  TryCatchBlockNodeInfo nextIntervalWithSameDefaultHandler=sameDefaultHandler.get(1);
  AbstractInsnNode startFinallyChain=tryCatchBlock.getNode().end;
  AbstractInsnNode endFinallyChainExclusive=skipLastGotoIfNeeded(nextIntervalWithSameDefaultHandler.getNode().start);
  FinallyBlockInfo finallyInfo=new FinallyBlockInfo(startFinallyChain.getNext(),endFinallyChainExclusive);
  if (inlineFun.instructions.indexOf(finallyInfo.startIns) > inlineFun.instructions.indexOf(finallyInfo.endInsExclusive)) {
    throw new AssertionError("Inconsistent finally: block end occurs before start " + traceInterval(finallyInfo.endInsExclusive,finallyInfo.startIns));
  }
  return finallyInfo;
}
