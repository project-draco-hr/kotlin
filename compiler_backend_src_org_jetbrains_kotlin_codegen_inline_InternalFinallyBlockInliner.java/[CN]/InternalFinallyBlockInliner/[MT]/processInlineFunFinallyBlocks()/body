{
  int nextTempNonLocalVarIndex=initAndGetVarIndexForNonLocalReturnValue();
  InsnList instructions=inlineFun.instructions;
  AbstractInsnNode curIns=instructions.getLast();
  while (curIns != null) {
    processInstruction(curIns,false);
    if (!InlineCodegenUtil.isReturnOpcode(curIns.getOpcode()) || !InlineCodegenUtil.isMarkedReturn(curIns)) {
      curIns=curIns.getPrevious();
      continue;
    }
    List<TryCatchBlockNodeInfo> currentCoveringNodesFromInnermost=sortTryCatchBlocks(new ArrayList<TryCatchBlockNodeInfo>(getTryBlocksMetaInfo().getCurrentIntervals()));
    checkCoveringBlocksInvariant(Lists.reverse(currentCoveringNodesFromInnermost));
    if (currentCoveringNodesFromInnermost.isEmpty() || currentCoveringNodesFromInnermost.get(currentCoveringNodesFromInnermost.size() - 1).getOnlyCopyNotProcess()) {
      curIns=curIns.getPrevious();
      continue;
    }
    AbstractInsnNode markedReturn=curIns;
    final AbstractInsnNode instrInsertFinallyBefore=markedReturn.getPrevious();
    AbstractInsnNode nextPrev=instrInsertFinallyBefore.getPrevious();
    Type nonLocalReturnType=InlineCodegenUtil.getReturnType(markedReturn.getOpcode());
    List<TryBlockCluster<TryCatchBlockNodeInfo>> clustersFromInnermost=InlinePackage.doClustering(currentCoveringNodesFromInnermost);
    Iterator<TryBlockCluster<TryCatchBlockNodeInfo>> tryCatchBlockIterator=clustersFromInnermost.iterator();
    checkClusterInvariant(clustersFromInnermost);
    List<TryCatchBlockNodeInfo> additionalNodesToSplit=new ArrayList<TryCatchBlockNodeInfo>();
    while (tryCatchBlockIterator.hasNext()) {
      TryBlockCluster<TryCatchBlockNodeInfo> clusterToFindFinally=tryCatchBlockIterator.next();
      List<TryCatchBlockNodeInfo> clusterBlocks=clusterToFindFinally.getBlocks();
      TryCatchBlockNodeInfo nodeWithDefaultHandlerIfExists=clusterBlocks.get(clusterBlocks.size() - 1);
      FinallyBlockInfo finallyInfo=findFinallyBlockBody(nodeWithDefaultHandlerIfExists,getTryBlocksMetaInfo().getAllIntervals());
      if (finallyInfo == null)       continue;
      if (nodeWithDefaultHandlerIfExists.getOnlyCopyNotProcess()) {
        additionalNodesToSplit.addAll(clusterBlocks);
        continue;
      }
      instructions.resetLabels();
      List<TryCatchBlockNodePosition> tryCatchBlockInlinedInFinally=findTryCatchBlocksInlinedInFinally(finallyInfo);
      MethodNode finallyBlockCopy=createEmptyMethodNode();
      Label newFinallyStart=new Label();
      Label newFinallyEnd=new Label();
      Label insertedBlockEnd=new Label();
      boolean generateAloadAstore=nonLocalReturnType != Type.VOID_TYPE && !finallyInfo.isEmpty();
      if (generateAloadAstore) {
        finallyBlockCopy.visitVarInsn(nonLocalReturnType.getOpcode(Opcodes.ISTORE),nextTempNonLocalVarIndex);
      }
      finallyBlockCopy.visitLabel(newFinallyStart);
      Set<LabelNode> labelsInsideFinally=rememberOriginalLabelNodes(finallyInfo);
      AbstractInsnNode currentIns=finallyInfo.startIns;
      while (currentIns != finallyInfo.endInsExclusive) {
        boolean isInsOrJumpInsideFinally=!(currentIns instanceof JumpInsnNode) || labelsInsideFinally.contains(((JumpInsnNode)currentIns).label);
        copyInstruction(nextTempNonLocalVarIndex,markedReturn,instrInsertFinallyBefore,nonLocalReturnType,finallyBlockCopy,currentIns,isInsOrJumpInsideFinally);
        currentIns=currentIns.getNext();
      }
      finallyBlockCopy.visitLabel(newFinallyEnd);
      if (generateAloadAstore) {
        finallyBlockCopy.visitVarInsn(nonLocalReturnType.getOpcode(Opcodes.ILOAD),nextTempNonLocalVarIndex);
        nextTempNonLocalVarIndex+=nonLocalReturnType.getSize();
      }
      finallyBlockCopy.visitLabel(insertedBlockEnd);
      InlineCodegenUtil.insertNodeBefore(finallyBlockCopy,inlineFun,instrInsertFinallyBefore);
      updateExceptionTable(clusterBlocks,newFinallyStart,newFinallyEnd,tryCatchBlockInlinedInFinally,labelsInsideFinally,(LabelNode)insertedBlockEnd.info,additionalNodesToSplit);
    }
    curIns=markedReturn.getPrevious();
    while (curIns != null && curIns != nextPrev) {
      processInstruction(curIns,false);
      curIns=curIns.getPrevious();
    }
    if (instrInsertFinallyBefore.getPrevious() != nextPrev && curIns != null) {
      LabelNode startNode=new LabelNode();
      LabelNode endNode=new LabelNode();
      instructions.insert(curIns,startNode);
      instructions.insert(markedReturn,endNode);
      getLocalVarsMetaInfo().splitCurrentIntervals(new SimpleInterval(startNode,endNode),true);
    }
  }
  substituteTryBlockNodes(inlineFun);
  substituteLocalVarTable(inlineFun);
}
