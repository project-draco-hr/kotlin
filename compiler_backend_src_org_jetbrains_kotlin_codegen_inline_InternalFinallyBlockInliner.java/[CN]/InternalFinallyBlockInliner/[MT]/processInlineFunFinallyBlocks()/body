{
  int nextTempNonLocalVarIndex=initAndGetVarIndexForNonLocalReturnValue();
  InsnList instructions=inlineFun.instructions;
  AbstractInsnNode curIns=instructions.getLast();
  while (curIns != null) {
    updateCoveringTryBlocks(curIns);
    if (!InlineCodegenUtil.isReturnOpcode(curIns.getOpcode()) || !InlineCodegenUtil.isMarkedReturn(curIns)) {
      curIns=curIns.getPrevious();
      continue;
    }
    List<TryCatchBlockNodeInfo> currentCoveringNodes=getCoveringFromInnermost();
    checkCoveringBlocksInvariant(currentCoveringNodes);
    if (currentCoveringNodes.isEmpty() || currentCoveringNodes.get(currentCoveringNodes.size() - 1).getOnlyCopyNotProcess()) {
      curIns=curIns.getPrevious();
      continue;
    }
    AbstractInsnNode instrInsertFinallyBefore=curIns.getPrevious();
    AbstractInsnNode nextPrev=instrInsertFinallyBefore.getPrevious();
    Type nonLocalReturnType=InlineCodegenUtil.getReturnType(curIns.getOpcode());
    List<TryBlockCluster<TryCatchBlockNodeInfo>> clustersFromInnermost=InlinePackage.doClustering(currentCoveringNodes);
    Iterator<TryBlockCluster<TryCatchBlockNodeInfo>> tryCatchBlockIterator=clustersFromInnermost.iterator();
    checkClusterInvariant(clustersFromInnermost);
    List<TryCatchBlockNodeInfo> additionalNodesToSplit=new ArrayList<TryCatchBlockNodeInfo>();
    while (tryCatchBlockIterator.hasNext()) {
      TryBlockCluster clusterToFindFinally=tryCatchBlockIterator.next();
      List<TryCatchBlockNodeInfo> clusterBlocks=clusterToFindFinally.getBlocks();
      TryCatchBlockNodeInfo nodeWithDefaultHandlerIfExists=clusterBlocks.get(clusterBlocks.size() - 1);
      FinallyBlockInfo finallyInfo=findFinallyBlockBody(nodeWithDefaultHandlerIfExists,getTryBlocksMetaInfo().getAllIntervals());
      if (finallyInfo == null)       continue;
      if (nodeWithDefaultHandlerIfExists.getOnlyCopyNotProcess()) {
        additionalNodesToSplit.addAll(clusterBlocks);
        continue;
      }
      instructions.resetLabels();
      List<TryCatchBlockNodePosition> tryCatchBlockInlinedInFinally=findTryCatchBlocksInlinedInFinally(finallyInfo);
      MethodNode finallyBlockCopy=createEmptyMethodNode();
      Label newFinallyStart=new Label();
      Label newFinallyEnd=new Label();
      Label insertedBlockEnd=new Label();
      boolean generateAloadAstore=nonLocalReturnType != Type.VOID_TYPE && !finallyInfo.isEmpty();
      if (generateAloadAstore) {
        finallyBlockCopy.visitVarInsn(nonLocalReturnType.getOpcode(Opcodes.ISTORE),nextTempNonLocalVarIndex);
      }
      finallyBlockCopy.visitLabel(newFinallyStart);
      Set<LabelNode> labelsInsideFinally=rememberOriginalLabelNodes(finallyInfo);
      AbstractInsnNode currentIns=finallyInfo.startIns;
      while (currentIns != finallyInfo.endInsExclusive) {
        boolean isInsOrJumpInsideFinally=!(currentIns instanceof JumpInsnNode) || labelsInsideFinally.contains(((JumpInsnNode)currentIns).label);
        copyInstruction(nextTempNonLocalVarIndex,curIns,instrInsertFinallyBefore,nonLocalReturnType,finallyBlockCopy,currentIns,isInsOrJumpInsideFinally);
        currentIns=currentIns.getNext();
      }
      finallyBlockCopy.visitLabel(newFinallyEnd);
      if (generateAloadAstore) {
        finallyBlockCopy.visitVarInsn(nonLocalReturnType.getOpcode(Opcodes.ILOAD),nextTempNonLocalVarIndex);
        nextTempNonLocalVarIndex+=nonLocalReturnType.getSize();
      }
      finallyBlockCopy.visitLabel(insertedBlockEnd);
      InlineCodegenUtil.insertNodeBefore(finallyBlockCopy,inlineFun,instrInsertFinallyBefore);
      updateExceptionTable(clusterBlocks,newFinallyStart,newFinallyEnd,tryCatchBlockInlinedInFinally,labelsInsideFinally,(LabelNode)insertedBlockEnd.info,additionalNodesToSplit);
    }
    curIns=curIns.getPrevious();
    while (curIns != null && curIns != nextPrev) {
      updateCoveringTryBlocks(curIns);
      curIns=curIns.getPrevious();
    }
  }
  substituteTryBlockNodes();
}
