{
  if (elements.isEmpty()) {
    return;
  }
  Project project=elements.get(0).getProject();
  if (!isMarkersEnabled(project)) {
    return;
  }
  KotlinDeclarationsCache declarationsCache=KotlinCacheManager.getInstance(project).getDeclarationsFromProject();
  BindingContext bindingContext=declarationsCache.getBindingContext();
  DelegatingBindingTrace bindingTrace=new DelegatingBindingTrace(bindingContext,"wrapped context of declarations cache");
  InjectorForJavaDescriptorResolver injector=new InjectorForJavaDescriptorResolver(project,bindingTrace,new ModuleDescriptor(Name.special("<fake>")));
  JavaDescriptorResolver javaDescriptorResolver=injector.getJavaDescriptorResolver();
  for (  PsiElement element : elements) {
    if (!(element instanceof PsiMember)) {
      continue;
    }
    PsiMember member=(PsiMember)element;
    if (member.hasModifierProperty(PsiModifier.PRIVATE)) {
      continue;
    }
    DeclarationDescriptor memberDescriptor=getDescriptorForMember(javaDescriptorResolver,member,bindingContext);
    if (memberDescriptor == null)     continue;
    List<String> errors=bindingContext.get(BindingContext.LOAD_FROM_JAVA_SIGNATURE_ERRORS,memberDescriptor);
    boolean hasSignatureAnnotation=findKotlinSignatureAnnotation(element) != null;
    if (errors != null || hasSignatureAnnotation) {
      result.add(new MyLineMarkerInfo((PsiModifierListOwner)element,errors,hasSignatureAnnotation));
    }
  }
}
