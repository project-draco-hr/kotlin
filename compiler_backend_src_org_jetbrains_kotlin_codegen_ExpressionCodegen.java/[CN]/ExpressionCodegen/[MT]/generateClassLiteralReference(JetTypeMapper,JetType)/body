{
  return StackValue.operation(K_CLASS_TYPE,new Function1<InstructionAdapter,Unit>(){
    @Override public Unit invoke(    InstructionAdapter v){
      Type classAsmType=typeMapper.mapType(type);
      ClassifierDescriptor descriptor=type.getConstructor().getDeclarationDescriptor();
      if (descriptor instanceof TypeParameterDescriptor) {
        TypeParameterDescriptor typeParameterDescriptor=(TypeParameterDescriptor)descriptor;
        if (typeParameterDescriptor.isReified()) {
          v.visitLdcInsn(typeParameterDescriptor.getName().asString());
          v.invokestatic(IntrinsicMethods.INTRINSICS_CLASS_NAME,ReifiedTypeInliner.CLASS_LITERAL_MARKER_METHOD_NAME,Type.getMethodDescriptor(Type.VOID_TYPE,Type.getType(String.class)),false);
          v.getstatic(classAsmType.getInternalName(),JvmAbi.KOTLIN_CLASS_FIELD_NAME,K_CLASS_TYPE.getDescriptor());
        }
 else {
          throw new AssertionError("Non-reified type parameter under ::class should be rejected by type checker: " + typeParameterDescriptor.getName().asString());
        }
      }
 else       if (shouldUseJavaClassForClassLiteral(descriptor)) {
        putJavaLangClassInstance(v,classAsmType);
        wrapJavaClassIntoKClass(v);
      }
 else {
        v.getstatic(classAsmType.getInternalName(),JvmAbi.KOTLIN_CLASS_FIELD_NAME,K_CLASS_TYPE.getDescriptor());
      }
      return Unit.INSTANCE$;
    }
  }
);
}
