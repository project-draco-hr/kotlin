{
  Expression initialization=field.getInitialization();
  DiType type=((InstantiateType)initialization).getType();
  if (type.getClazz().isInterface()) {
    throw new IllegalArgumentException("cannot instantiate interface: " + type.getClazz().getName() + " needed for "+ neededFor);
  }
  if (Modifier.isAbstract(type.getClazz().getModifiers())) {
    throw new IllegalArgumentException("cannot instantiate abstract class: " + type.getClazz().getName() + " needed for "+ neededFor);
  }
  Constructor<?>[] constructors=type.getClazz().getConstructors();
  if (constructors.length == 0 || !Modifier.isPublic(constructors[0].getModifiers())) {
    throw new IllegalArgumentException("No constructor: " + type.getClazz().getName() + " needed for "+ neededFor);
  }
  if (constructors.length > 1) {
    throw new IllegalArgumentException("Too many constructors in " + type.getClazz().getName() + " needed for "+ neededFor);
  }
  Constructor<?> constructor=constructors[0];
  ConstructorCall dependency=new ConstructorCall(constructor);
  Type[] parameterTypes=constructor.getGenericParameterTypes();
  for (  Type parameterType : parameterTypes) {
    Field fieldForParameter=findDependencyOfType(DiType.fromReflectionType(parameterType),"constructor: " + constructor + ", parameter: "+ parameterType,neededFor.prepend(field));
    dependency.getConstructorArguments().add(fieldForParameter);
  }
  field.setInitialization(dependency);
}
