{
  ExpressionTypingContext currentContext=context.replaceExpectedType(NO_EXPECTED_TYPE).replaceContextDependency(INDEPENDENT);
  List<CallExpressionElement> elementChain=qualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll(expression,context);
  CallExpressionElement firstElement=elementChain.iterator().next();
  KotlinTypeInfo receiverTypeInfo=expressionTypingServices.getTypeInfo(firstElement.getReceiver(),currentContext);
  KotlinType receiverType=receiverTypeInfo.getType();
  DataFlowInfo receiverDataFlowInfo=receiverTypeInfo.getDataFlowInfo();
  KotlinTypeInfo resultTypeInfo=receiverTypeInfo;
  boolean unconditional=true;
  DataFlowInfo unconditionalDataFlowInfo=receiverDataFlowInfo;
  for (  CallExpressionElement element : elementChain) {
    if (receiverType == null) {
      receiverType=ErrorUtils.createErrorType("Type for " + expression.getText());
    }
    QualifierReceiver qualifierReceiver=(QualifierReceiver)context.trace.get(BindingContext.QUALIFIER,element.getReceiver());
    Receiver receiver=qualifierReceiver == null ? ExpressionReceiver.Companion.create(element.getReceiver(),receiverType,context.trace.getBindingContext()) : qualifierReceiver;
    boolean lastStage=element.getQualified() == expression;
    ExpressionTypingContext baseContext=lastStage ? context : currentContext;
    currentContext=baseContext.replaceDataFlowInfo(receiverDataFlowInfo);
    KtExpression selectorExpression=element.getSelector();
    KotlinTypeInfo selectorReturnTypeInfo=getSelectorReturnTypeInfo(receiver,element.getNode(),selectorExpression,currentContext);
    KotlinType selectorReturnType=selectorReturnTypeInfo.getType();
    resolveDeferredReceiverInQualifiedExpression(qualifierReceiver,element.getQualified(),currentContext);
    checkNestedClassAccess(element.getQualified(),currentContext);
    boolean safeCall=element.getSafe();
    if (safeCall && selectorReturnType != null && TypeUtils.isNullableType(receiverType)) {
      selectorReturnType=TypeUtils.makeNullable(selectorReturnType);
      selectorReturnTypeInfo=selectorReturnTypeInfo.replaceType(selectorReturnType);
    }
    if (selectorExpression != null && selectorReturnType != null) {
      currentContext.trace.recordType(selectorExpression,selectorReturnType);
    }
    resultTypeInfo=selectorReturnTypeInfo;
    CompileTimeConstant<?> value=constantExpressionEvaluator.evaluateExpression(element.getQualified(),currentContext.trace,currentContext.expectedType);
    if (value != null && value.isPure()) {
      resultTypeInfo=dataFlowAnalyzer.createCompileTimeConstantTypeInfo(value,element.getQualified(),currentContext);
      if (lastStage)       return resultTypeInfo;
    }
    if (currentContext.contextDependency == INDEPENDENT) {
      dataFlowAnalyzer.checkType(resultTypeInfo.getType(),element.getQualified(),currentContext);
    }
    receiverTypeInfo=selectorReturnTypeInfo;
    receiverType=selectorReturnType;
    receiverDataFlowInfo=receiverTypeInfo.getDataFlowInfo();
    if (safeCall) {
      unconditional=false;
    }
 else     if (unconditional) {
      unconditionalDataFlowInfo=receiverDataFlowInfo;
    }
    if (!lastStage && !currentContext.trace.get(BindingContext.PROCESSED,element.getQualified())) {
      currentContext.trace.record(BindingContext.PROCESSED,element.getQualified());
      currentContext.trace.record(BindingContext.EXPRESSION_TYPE_INFO,element.getQualified(),resultTypeInfo.replaceDataFlowInfo(unconditionalDataFlowInfo));
      BindingContextUtilsKt.recordScope(currentContext.trace,currentContext.scope,element.getQualified());
      BindingContextUtilsKt.recordDataFlowInfo(currentContext.replaceDataFlowInfo(unconditionalDataFlowInfo),element.getQualified());
    }
  }
  return resultTypeInfo.replaceDataFlowInfo(unconditionalDataFlowInfo);
}
