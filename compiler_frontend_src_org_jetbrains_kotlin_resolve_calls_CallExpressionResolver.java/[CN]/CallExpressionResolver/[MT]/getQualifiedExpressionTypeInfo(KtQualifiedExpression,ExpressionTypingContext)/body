{
  ExpressionTypingContext currentContext=context.replaceExpectedType(NO_EXPECTED_TYPE).replaceContextDependency(INDEPENDENT);
  Function1<KtSimpleNameExpression,Boolean> isValueFunction=new Function1<KtSimpleNameExpression,Boolean>(){
    @Override public Boolean invoke(    KtSimpleNameExpression nameExpression){
      TemporaryTraceAndCache temporaryForVariable=TemporaryTraceAndCache.create(context,"trace to resolve as local variable or property",nameExpression);
      Call call=CallMaker.makePropertyCall(ReceiverValue.NO_RECEIVER,null,nameExpression);
      BasicCallResolutionContext contextForVariable=BasicCallResolutionContext.create(context.replaceTraceAndCache(temporaryForVariable),call,CheckArgumentTypesMode.CHECK_VALUE_ARGUMENTS);
      OverloadResolutionResults<VariableDescriptor> resolutionResult=callResolver.resolveSimpleProperty(contextForVariable);
      if (resolutionResult.isSingleResult() && resolutionResult.getResultingDescriptor() instanceof FakeCallableDescriptorForObject) {
        return false;
      }
      OverloadResolutionResults.Code resultCode=resolutionResult.getResultCode();
      return resultCode != OverloadResolutionResults.Code.NAME_NOT_FOUND && resultCode != OverloadResolutionResults.Code.CANDIDATES_WITH_WRONG_RECEIVER;
    }
  }
;
  List<CallExpressionElement> elementChain=qualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll(expression,context,isValueFunction);
  KotlinTypeInfo receiverTypeInfo;
  KotlinType receiverType;
  DataFlowInfo receiverDataFlowInfo;
  CallExpressionElement firstElement=elementChain.iterator().next();
  KtExpression firstReceiver=firstElement.getReceiver();
  Qualifier firstQualifier=context.trace.get(BindingContext.QUALIFIER,firstReceiver);
  if (firstQualifier == null) {
    receiverTypeInfo=expressionTypingServices.getTypeInfo(firstReceiver,currentContext);
    receiverType=receiverTypeInfo.getType();
    receiverDataFlowInfo=receiverTypeInfo.getDataFlowInfo();
  }
 else {
    receiverType=null;
    receiverDataFlowInfo=currentContext.dataFlowInfo;
    receiverTypeInfo=new KotlinTypeInfo(receiverType,receiverDataFlowInfo);
  }
  KotlinTypeInfo resultTypeInfo=receiverTypeInfo;
  boolean unconditional=true;
  DataFlowInfo unconditionalDataFlowInfo=receiverDataFlowInfo;
  for (  CallExpressionElement element : elementChain) {
    if (receiverType == null) {
      receiverType=ErrorUtils.createErrorType("Type for " + expression.getText());
    }
    QualifierReceiver qualifierReceiver=(QualifierReceiver)context.trace.get(BindingContext.QUALIFIER,element.getReceiver());
    Receiver receiver=qualifierReceiver == null ? ExpressionReceiver.Companion.create(element.getReceiver(),receiverType,context.trace.getBindingContext()) : qualifierReceiver;
    boolean lastStage=element.getQualified() == expression;
    ExpressionTypingContext baseContext=lastStage ? context : currentContext;
    currentContext=baseContext.replaceDataFlowInfo(receiverDataFlowInfo);
    KtExpression selectorExpression=element.getSelector();
    KotlinTypeInfo selectorReturnTypeInfo=getSelectorReturnTypeInfo(receiver,element.getNode(),selectorExpression,currentContext);
    KotlinType selectorReturnType=selectorReturnTypeInfo.getType();
    if (qualifierReceiver != null) {
      resolveDeferredReceiverInQualifiedExpression(qualifierReceiver,element.getQualified(),currentContext);
    }
    checkNestedClassAccess(element.getQualified(),currentContext);
    boolean safeCall=element.getSafe();
    if (safeCall && selectorReturnType != null && TypeUtils.isNullableType(receiverType)) {
      selectorReturnType=TypeUtils.makeNullable(selectorReturnType);
      selectorReturnTypeInfo=selectorReturnTypeInfo.replaceType(selectorReturnType);
    }
    if (selectorExpression != null && selectorReturnType != null) {
      currentContext.trace.recordType(selectorExpression,selectorReturnType);
    }
    resultTypeInfo=selectorReturnTypeInfo;
    CompileTimeConstant<?> value=constantExpressionEvaluator.evaluateExpression(element.getQualified(),currentContext.trace,currentContext.expectedType);
    if (value != null && value.isPure()) {
      resultTypeInfo=dataFlowAnalyzer.createCompileTimeConstantTypeInfo(value,element.getQualified(),currentContext);
      if (lastStage)       return resultTypeInfo;
    }
    if (currentContext.contextDependency == INDEPENDENT) {
      dataFlowAnalyzer.checkType(resultTypeInfo.getType(),element.getQualified(),currentContext);
    }
    receiverTypeInfo=selectorReturnTypeInfo;
    receiverType=selectorReturnType;
    receiverDataFlowInfo=receiverTypeInfo.getDataFlowInfo();
    if (safeCall) {
      unconditional=false;
    }
 else     if (unconditional) {
      unconditionalDataFlowInfo=receiverDataFlowInfo;
    }
    if (!lastStage && !currentContext.trace.get(BindingContext.PROCESSED,element.getQualified())) {
      currentContext.trace.record(BindingContext.PROCESSED,element.getQualified());
      currentContext.trace.record(BindingContext.EXPRESSION_TYPE_INFO,element.getQualified(),resultTypeInfo.replaceDataFlowInfo(unconditionalDataFlowInfo));
      BindingContextUtilsKt.recordScope(currentContext.trace,currentContext.scope,element.getQualified());
      BindingContextUtilsKt.recordDataFlowInfo(currentContext.replaceDataFlowInfo(unconditionalDataFlowInfo),element.getQualified());
    }
  }
  return resultTypeInfo.replaceDataFlowInfo(unconditionalDataFlowInfo);
}
