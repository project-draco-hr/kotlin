{
  ExpressionTypingContext currentContext=context.replaceExpectedType(NO_EXPECTED_TYPE).replaceContextDependency(INDEPENDENT);
  BindingTrace trace=currentContext.trace;
  Function1<KtSimpleNameExpression,Boolean> isValueFunction=new Function1<KtSimpleNameExpression,Boolean>(){
    @Override public Boolean invoke(    KtSimpleNameExpression nameExpression){
      TemporaryTraceAndCache temporaryForVariable=TemporaryTraceAndCache.create(context,"trace to resolve as local variable or property",nameExpression);
      Call call=CallMaker.makePropertyCall(null,null,nameExpression);
      BasicCallResolutionContext contextForVariable=BasicCallResolutionContext.create(context.replaceTraceAndCache(temporaryForVariable),call,CheckArgumentTypesMode.CHECK_VALUE_ARGUMENTS);
      OverloadResolutionResults<VariableDescriptor> resolutionResult=callResolver.resolveSimpleProperty(contextForVariable);
      if (resolutionResult.isSingleResult() && resolutionResult.getResultingDescriptor() instanceof FakeCallableDescriptorForObject) {
        return false;
      }
      OverloadResolutionResults.Code resultCode=resolutionResult.getResultCode();
      return resultCode != OverloadResolutionResults.Code.NAME_NOT_FOUND && resultCode != OverloadResolutionResults.Code.CANDIDATES_WITH_WRONG_RECEIVER;
    }
  }
;
  List<CallExpressionElement> elementChain=qualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll(expression,context,isValueFunction);
  KotlinTypeInfo receiverTypeInfo;
  KotlinType receiverType;
  DataFlowInfo receiverDataFlowInfo;
  CallExpressionElement firstElement=elementChain.iterator().next();
  KtExpression firstReceiver=firstElement.getReceiver();
  Qualifier firstQualifier=trace.get(BindingContext.QUALIFIER,firstReceiver);
  if (firstQualifier == null) {
    receiverTypeInfo=expressionTypingServices.getTypeInfo(firstReceiver,currentContext);
    receiverType=receiverTypeInfo.getType();
    receiverDataFlowInfo=receiverTypeInfo.getDataFlowInfo();
  }
 else {
    receiverType=null;
    receiverDataFlowInfo=currentContext.dataFlowInfo;
    receiverTypeInfo=new KotlinTypeInfo(receiverType,receiverDataFlowInfo);
  }
  KotlinTypeInfo resultTypeInfo=receiverTypeInfo;
  boolean unconditional=true;
  DataFlowInfo unconditionalDataFlowInfo=receiverDataFlowInfo;
  for (  CallExpressionElement element : elementChain) {
    if (receiverType == null) {
      receiverType=ErrorUtils.createErrorType("Type for " + expression.getText());
    }
    QualifierReceiver qualifierReceiver=(QualifierReceiver)trace.get(BindingContext.QUALIFIER,element.getReceiver());
    Receiver receiver=qualifierReceiver == null ? ExpressionReceiver.Companion.create(element.getReceiver(),receiverType,trace.getBindingContext()) : qualifierReceiver;
    boolean lastStage=element.getQualified() == expression;
    ExpressionTypingContext contextForSelector=lastStage ? context : currentContext;
    if (TypeUtils.isNullableType(receiverType) && !element.getSafe()) {
      contextForSelector=contextForSelector.replaceDataFlowInfo(unconditionalDataFlowInfo);
    }
 else {
      contextForSelector=contextForSelector.replaceDataFlowInfo(receiverDataFlowInfo);
    }
    DataFlowInfo initialDataFlowInfoForArguments=contextForSelector.dataFlowInfo;
    DataFlowValue receiverDataFlowValue=null;
    if (receiver instanceof ReceiverValue) {
      receiverDataFlowValue=DataFlowValueFactory.createDataFlowValue((ReceiverValue)receiver,context);
      if (element.getSafe()) {
        if (initialDataFlowInfoForArguments.getPredictableNullability(receiverDataFlowValue).canBeNull()) {
          initialDataFlowInfoForArguments=initialDataFlowInfoForArguments.disequate(receiverDataFlowValue,DataFlowValue.nullValue(builtIns));
        }
 else {
          reportUnnecessarySafeCall(trace,receiverType,element.getNode(),receiver);
        }
      }
    }
    KtExpression selectorExpression=element.getSelector();
    KotlinTypeInfo selectorReturnTypeInfo=getSelectorReturnTypeInfo(receiver,element.getNode(),selectorExpression,contextForSelector,initialDataFlowInfoForArguments);
    KotlinType selectorReturnType=selectorReturnTypeInfo.getType();
    if (qualifierReceiver != null) {
      resolveDeferredReceiverInQualifiedExpression(qualifierReceiver,element.getQualified(),contextForSelector);
    }
    checkNestedClassAccess(element.getQualified(),contextForSelector);
    boolean safeCall=element.getSafe();
    if (safeCall && selectorReturnType != null && receiverDataFlowValue != null && contextForSelector.dataFlowInfo.getPredictableNullability(receiverDataFlowValue).canBeNull()) {
      selectorReturnType=TypeUtils.makeNullable(selectorReturnType);
      selectorReturnTypeInfo=selectorReturnTypeInfo.replaceType(selectorReturnType);
    }
    if (selectorExpression != null && selectorReturnType != null) {
      trace.recordType(selectorExpression,selectorReturnType);
    }
    resultTypeInfo=selectorReturnTypeInfo;
    CompileTimeConstant<?> value=constantExpressionEvaluator.evaluateExpression(element.getQualified(),trace,contextForSelector.expectedType);
    if (value != null && value.isPure()) {
      resultTypeInfo=dataFlowAnalyzer.createCompileTimeConstantTypeInfo(value,element.getQualified(),contextForSelector);
      if (lastStage)       return resultTypeInfo;
    }
    if (contextForSelector.contextDependency == INDEPENDENT) {
      dataFlowAnalyzer.checkType(resultTypeInfo.getType(),element.getQualified(),contextForSelector);
    }
    receiverTypeInfo=selectorReturnTypeInfo;
    receiverType=selectorReturnType;
    receiverDataFlowInfo=receiverTypeInfo.getDataFlowInfo();
    if (safeCall) {
      unconditional=false;
    }
 else     if (unconditional) {
      unconditionalDataFlowInfo=receiverDataFlowInfo;
    }
    if (!lastStage && !trace.get(BindingContext.PROCESSED,element.getQualified())) {
      trace.record(BindingContext.PROCESSED,element.getQualified());
      trace.record(BindingContext.EXPRESSION_TYPE_INFO,element.getQualified(),resultTypeInfo.replaceDataFlowInfo(unconditionalDataFlowInfo));
      BindingContextUtilsKt.recordScope(trace,contextForSelector.scope,element.getQualified());
      BindingContextUtilsKt.recordDataFlowInfo(contextForSelector.replaceDataFlowInfo(unconditionalDataFlowInfo),element.getQualified());
    }
  }
  return resultTypeInfo.replaceDataFlowInfo(unconditionalDataFlowInfo);
}
