{
  boolean[] result=new boolean[1];
  Call call=CallMaker.makeCall(receiver,callOperationNode,callExpression);
  TemporaryTraceAndCache temporaryForFunction=TemporaryTraceAndCache.create(context,"trace to resolve as function call",callExpression);
  ResolvedCall<FunctionDescriptor> resolvedCall=getResolvedCallForFunction(call,callExpression,context.replaceTraceAndCache(temporaryForFunction).replaceInsideCallChain(false),CheckArgumentTypesMode.CHECK_VALUE_ARGUMENTS,result);
  if (result[0]) {
    FunctionDescriptor functionDescriptor=resolvedCall != null ? resolvedCall.getResultingDescriptor() : null;
    temporaryForFunction.commit();
    if (callExpression.getValueArgumentList() == null && callExpression.getFunctionLiteralArguments().isEmpty()) {
      boolean hasValueParameters=functionDescriptor == null || functionDescriptor.getValueParameters().size() > 0;
      context.trace.report(FUNCTION_CALL_EXPECTED.on(callExpression,callExpression,hasValueParameters));
    }
    if (functionDescriptor == null) {
      return TypeInfoFactoryKt.noTypeInfo(context);
    }
    if (functionDescriptor instanceof ConstructorDescriptor) {
      DeclarationDescriptor containingDescriptor=functionDescriptor.getContainingDeclaration();
      if (DescriptorUtils.isAnnotationClass(containingDescriptor) && !canInstantiateAnnotationClass(callExpression,context.trace)) {
        context.trace.report(ANNOTATION_CLASS_CONSTRUCTOR_CALL.on(callExpression));
      }
      if (DescriptorUtils.isEnumClass(containingDescriptor)) {
        context.trace.report(ENUM_CLASS_CONSTRUCTOR_CALL.on(callExpression));
      }
      if (containingDescriptor instanceof ClassDescriptor && ((ClassDescriptor)containingDescriptor).getModality() == Modality.SEALED) {
        context.trace.report(SEALED_CLASS_CONSTRUCTOR_CALL.on(callExpression));
      }
    }
    KotlinType type=functionDescriptor.getReturnType();
    List<? extends ValueArgument> arguments=callExpression.getValueArguments();
    DataFlowInfo resultFlowInfo=resolvedCall.getDataFlowInfoForArguments().getResultInfo();
    DataFlowInfo jumpFlowInfo=resultFlowInfo;
    boolean jumpOutPossible=false;
    for (    ValueArgument argument : arguments) {
      JetTypeInfo argTypeInfo=context.trace.get(BindingContext.EXPRESSION_TYPE_INFO,argument.getArgumentExpression());
      if (argTypeInfo != null && argTypeInfo.getJumpOutPossible()) {
        jumpOutPossible=true;
        jumpFlowInfo=argTypeInfo.getJumpFlowInfo();
        break;
      }
    }
    return TypeInfoFactoryKt.createTypeInfo(type,resultFlowInfo,jumpOutPossible,jumpFlowInfo);
  }
  KtExpression calleeExpression=callExpression.getCalleeExpression();
  if (calleeExpression instanceof KtSimpleNameExpression && callExpression.getTypeArgumentList() == null) {
    TemporaryTraceAndCache temporaryForVariable=TemporaryTraceAndCache.create(context,"trace to resolve as variable with 'invoke' call",callExpression);
    KotlinType type=getVariableType((KtSimpleNameExpression)calleeExpression,receiver,callOperationNode,context.replaceTraceAndCache(temporaryForVariable),result);
    Qualifier qualifier=temporaryForVariable.trace.get(BindingContext.QUALIFIER,calleeExpression);
    if (result[0] && (qualifier == null || qualifier.getPackageView() == null)) {
      temporaryForVariable.commit();
      context.trace.report(FUNCTION_EXPECTED.on(calleeExpression,calleeExpression,type != null ? type : ErrorUtils.createErrorType("")));
      return TypeInfoFactoryKt.noTypeInfo(context);
    }
  }
  temporaryForFunction.commit();
  return TypeInfoFactoryKt.noTypeInfo(context);
}
