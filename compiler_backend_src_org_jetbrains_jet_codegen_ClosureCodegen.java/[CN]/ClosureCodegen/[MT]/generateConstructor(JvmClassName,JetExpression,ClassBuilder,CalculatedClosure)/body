{
  List<FieldInfo> args=calculateConstructorParameters(typeMapper,bindingContext,state,closure,Type.getObjectType(name.getInternalName()));
  Type[] argTypes=fieldListToTypeArray(args);
  Method constructor=new Method("<init>",Type.VOID_TYPE,argTypes);
  MethodVisitor mv=cv.newMethod(fun,ACC_PUBLIC,"<init>",constructor.getDescriptor(),null,new String[0]);
  if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {
    genStubCode(mv);
  }
 else   if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {
    mv.visitCode();
    InstructionAdapter iv=new InstructionAdapter(mv);
    Type superAsmType=samInterface == null ? funClass.getAsmType() : OBJECT_TYPE;
    iv.load(0,superAsmType);
    iv.invokespecial(superAsmType.getInternalName(),"<init>","()V");
    int k=1;
    for (    FieldInfo fieldInfo : args) {
      k=AsmUtil.genAssignInstanceFieldFromParam(fieldInfo,k,iv);
    }
    iv.visitInsn(RETURN);
    FunctionCodegen.endVisit(iv,"constructor",fun);
  }
  return constructor;
}
