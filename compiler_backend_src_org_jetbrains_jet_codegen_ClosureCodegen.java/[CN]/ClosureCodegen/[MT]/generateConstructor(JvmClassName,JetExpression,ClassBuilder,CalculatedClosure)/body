{
  final ArrayList<Pair<String,Type>> args=new ArrayList<Pair<String,Type>>();
  calculateConstructorParameters(args,state,closure);
  final Type[] argTypes=nameAnTypeListToTypeArray(args);
  final Method constructor=new Method("<init>",Type.VOID_TYPE,argTypes);
  final MethodVisitor mv=cv.newMethod(fun,ACC_PUBLIC,"<init>",constructor.getDescriptor(),null,new String[0]);
  if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {
    StubCodegen.generateStubCode(mv);
  }
 else   if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {
    mv.visitCode();
    InstructionAdapter iv=new InstructionAdapter(mv);
    iv.load(0,funClass.getAsmType());
    iv.invokespecial(funClass.getInternalName(),"<init>","()V");
    int k=1;
    for (int i=0; i != argTypes.length; ++i) {
      StackValue.local(0,OBJECT_TYPE).put(OBJECT_TYPE,iv);
      final Pair<String,Type> nameAndType=args.get(i);
      final Type type=nameAndType.second;
      StackValue.local(k,type).put(type,iv);
      k+=type.getSize();
      StackValue.field(type,name,nameAndType.first,false).store(type,iv);
    }
    iv.visitInsn(RETURN);
    FunctionCodegen.endVisit(iv,"constructor",fun);
  }
  return constructor;
}
