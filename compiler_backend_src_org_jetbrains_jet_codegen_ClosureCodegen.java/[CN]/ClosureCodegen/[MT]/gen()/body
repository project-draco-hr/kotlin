{
  ClassBuilder cv=state.getFactory().newVisitor(OtherOrigin(fun,funDescriptor),asmType,fun.getContainingFile());
  FunctionDescriptor erasedInterfaceFunction;
  if (samType == null) {
    erasedInterfaceFunction=getErasedInvokeFunction(funDescriptor);
  }
 else {
    erasedInterfaceFunction=samType.getAbstractMethod().getOriginal();
  }
  BothSignatureWriter sw=new BothSignatureWriter(BothSignatureWriter.Mode.CLASS);
  if (samType != null) {
    typeMapper.writeFormalTypeParameters(samType.getType().getConstructor().getParameters(),sw);
  }
  sw.writeSuperclass();
  Type superClassAsmType=typeMapper.mapSupertype(superClassType,sw);
  sw.writeSuperclassEnd();
  String[] superInterfaceAsmTypes=new String[superInterfaceTypes.size()];
  for (int i=0; i < superInterfaceTypes.size(); i++) {
    JetType superInterfaceType=superInterfaceTypes.get(i);
    sw.writeInterface();
    superInterfaceAsmTypes[i]=typeMapper.mapSupertype(superInterfaceType,sw).getInternalName();
    sw.writeInterfaceEnd();
  }
  cv.defineClass(fun,V1_6,ACC_FINAL | ACC_SUPER | visibilityFlag,asmType.getInternalName(),sw.makeJavaGenericSignature(),superClassAsmType.getInternalName(),superInterfaceAsmTypes);
  cv.visitSource(fun.getContainingFile().getName(),null);
  writeKotlinSyntheticClassAnnotation(cv,syntheticClassKind);
  JvmMethodSignature jvmMethodSignature=typeMapper.mapSignature(funDescriptor).replaceName(erasedInterfaceFunction.getName().toString());
  generateBridge(cv,typeMapper.mapSignature(erasedInterfaceFunction).getAsmMethod(),jvmMethodSignature.getAsmMethod());
  FunctionCodegen fc=new FunctionCodegen(context,cv,state,getParentCodegen());
  fc.generateMethod(OtherOrigin(fun,funDescriptor),jvmMethodSignature,funDescriptor,strategy);
  if (samType != null) {
    SimpleFunctionDescriptorImpl descriptorForBridges=SimpleFunctionDescriptorImpl.create(funDescriptor.getContainingDeclaration(),funDescriptor.getAnnotations(),erasedInterfaceFunction.getName(),CallableMemberDescriptor.Kind.DECLARATION,funDescriptor.getSource());
    descriptorForBridges.initialize(null,erasedInterfaceFunction.getDispatchReceiverParameter(),erasedInterfaceFunction.getTypeParameters(),erasedInterfaceFunction.getValueParameters(),erasedInterfaceFunction.getReturnType(),Modality.OPEN,erasedInterfaceFunction.getVisibility());
    descriptorForBridges.addOverriddenDescriptor(erasedInterfaceFunction);
    fc.generateBridges(descriptorForBridges);
  }
  this.constructor=generateConstructor(cv,superClassAsmType);
  if (isConst(closure)) {
    generateConstInstance(cv);
  }
  genClosureFields(closure,cv,typeMapper);
  fc.generateDefaultIfNeeded(context.intoFunction(funDescriptor),typeMapper.mapSignature(funDescriptor),funDescriptor,context.getContextKind(),DefaultParameterValueLoader.DEFAULT,null);
  AsmUtil.writeOuterClassAndEnclosingMethod(classDescriptor,funDescriptor,typeMapper,cv);
  cv.done();
}
