{
  ClassBuilder cv=state.getFactory().newVisitor(asmType,fun.getContainingFile());
  FunctionDescriptor interfaceFunction;
  if (samInterface == null) {
    interfaceFunction=getInvokeFunction(funDescriptor);
  }
 else {
    interfaceFunction=SingleAbstractMethodUtils.getAbstractMethodOfSamInterface(samInterface);
  }
  BothSignatureWriter sw=new BothSignatureWriter(BothSignatureWriter.Mode.CLASS);
  sw.writeSuperclass();
  Type superClassAsmType=typeMapper.mapSupertype(superClassType,sw);
  sw.writeSuperclassEnd();
  String[] superInterfaceAsmTypes=new String[superInterfaceTypes.size()];
  for (int i=0; i < superInterfaceTypes.size(); i++) {
    JetType superInterfaceType=superInterfaceTypes.get(i);
    sw.writeInterface();
    superInterfaceAsmTypes[i]=typeMapper.mapSupertype(superInterfaceType,sw).getInternalName();
    sw.writeInterfaceEnd();
  }
  cv.defineClass(fun,V1_6,ACC_FINAL | ACC_SUPER | visibilityFlag,asmType.getInternalName(),sw.makeJavaGenericSignature(),superClassAsmType.getInternalName(),superInterfaceAsmTypes);
  cv.visitSource(fun.getContainingFile().getName(),null);
  writeKotlinSyntheticClassAnnotation(cv,syntheticClassKind);
  JvmMethodSignature jvmMethodSignature=typeMapper.mapSignature(funDescriptor).replaceName(interfaceFunction.getName().toString());
  generateBridge(cv,typeMapper.mapSignature(interfaceFunction).getAsmMethod(),jvmMethodSignature.getAsmMethod());
  FunctionCodegen fc=new FunctionCodegen(context,cv,state,getParentCodegen());
  fc.generateMethod(fun,jvmMethodSignature,funDescriptor,strategy);
  this.constructor=generateConstructor(cv,superClassAsmType);
  if (isConst(closure)) {
    generateConstInstance(cv);
  }
  genClosureFields(closure,cv,typeMapper);
  fc.generateDefaultIfNeeded(context.intoFunction(funDescriptor),typeMapper.mapSignature(funDescriptor),funDescriptor,context.getContextKind(),DefaultParameterValueLoader.DEFAULT);
  cv.done();
}
