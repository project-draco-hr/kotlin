{
  ClassBuilder cv=state.getFactory().newVisitor(asmType,fun.getContainingFile());
  FunctionDescriptor interfaceFunction;
  String[] superInterfaces;
  if (samInterface == null) {
    interfaceFunction=getInvokeFunction(funDescriptor);
    superInterfaces=ArrayUtil.EMPTY_STRING_ARRAY;
  }
 else {
    interfaceFunction=SingleAbstractMethodUtils.getAbstractMethodOfSamInterface(samInterface);
    superInterfaces=new String[]{typeMapper.mapType(samInterface).getInternalName()};
  }
  cv.defineClass(fun,V1_6,ACC_FINAL | ACC_SUPER | visibilityFlag,asmType.getInternalName(),getGenericSignature(),superClass.getInternalName(),superInterfaces);
  cv.visitSource(fun.getContainingFile().getName(),null);
  writeKotlinSyntheticClassAnnotation(cv,syntheticClassKind);
  JvmMethodSignature jvmMethodSignature=typeMapper.mapSignature(funDescriptor).replaceName(interfaceFunction.getName().toString());
  generateBridge(cv,typeMapper.mapSignature(interfaceFunction).getAsmMethod(),jvmMethodSignature.getAsmMethod());
  FunctionCodegen fc=new FunctionCodegen(context,cv,state,getParentCodegen());
  fc.generateMethod(fun,jvmMethodSignature,funDescriptor,strategy);
  this.constructor=generateConstructor(cv);
  if (isConst(closure)) {
    generateConstInstance(cv);
  }
  genClosureFields(closure,cv,typeMapper);
  fc.generateDefaultIfNeeded(context.intoFunction(funDescriptor),typeMapper.mapSignature(funDescriptor),funDescriptor,context.getContextKind(),DefaultParameterValueLoader.DEFAULT);
  cv.done();
}
