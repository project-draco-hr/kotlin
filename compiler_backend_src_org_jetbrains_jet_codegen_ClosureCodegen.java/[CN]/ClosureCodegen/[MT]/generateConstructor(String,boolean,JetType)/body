{
  int argCount=closure.size();
  if (captureThis) {
    argCount++;
  }
  Type[] argTypes=new Type[argCount];
  int i=0;
  if (captureThis) {
    i=1;
    argTypes[0]=context.enclosingClassType(state.getTypeMapper());
  }
  for (  DeclarationDescriptor descriptor : closure.keySet()) {
    argTypes[i++]=state.getTypeMapper().mapType(((VariableDescriptor)descriptor).getOutType());
  }
  final Method constructor=new Method("<init>",Type.VOID_TYPE,argTypes);
  final MethodVisitor mv=cv.visitMethod(Opcodes.ACC_PUBLIC,"<init>",constructor.getDescriptor(),null,new String[0]);
  mv.visitCode();
  InstructionAdapter iv=new InstructionAdapter(mv);
  ExpressionCodegen expressionCodegen=new ExpressionCodegen(mv,null,Type.VOID_TYPE,context,state);
  iv.load(0,Type.getObjectType(funClass));
  expressionCodegen.generateTypeInfo(new ProjectionErasingJetType(returnType));
  iv.invokespecial(funClass,"<init>","(Ljet/typeinfo/TypeInfo;)V");
  i=1;
  for (  Type type : argTypes) {
    StackValue.local(0,JetTypeMapper.TYPE_OBJECT).put(JetTypeMapper.TYPE_OBJECT,iv);
    StackValue.local(i,type).put(type,iv);
    final String fieldName;
    if (captureThis && i == 1) {
      fieldName="this$0";
      captureThis=false;
    }
 else {
      fieldName="$" + (i);
      i++;
    }
    StackValue.field(type,name,fieldName,false).store(iv);
  }
  iv.visitInsn(Opcodes.RETURN);
  mv.visitMaxs(0,0);
  mv.visitEnd();
  return constructor;
}
