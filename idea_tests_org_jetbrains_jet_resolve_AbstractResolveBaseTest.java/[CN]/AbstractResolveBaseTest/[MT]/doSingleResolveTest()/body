{
  boolean shouldBeUnresolved=InTextDirectivesUtils.isDirectiveDefined(myFixture.getFile().getText(),REF_EMPTY);
  List<String> refs=InTextDirectivesUtils.findLinesWithPrefixesRemoved(myFixture.getFile().getText(),"REF:");
  String referenceToString;
  if (shouldBeUnresolved) {
    Assert.assertTrue("REF: directives will be ignored for " + REF_EMPTY + " test: "+ refs,refs.isEmpty());
    referenceToString="<empty>";
  }
 else {
    assertTrue("Must be a single ref: " + refs + ".\n"+ "Use "+ MULTIRESOLVE+ " if you need multiple refs\n"+ "Use "+ REF_EMPTY+ " for an unresolved reference",refs.size() == 1);
    referenceToString=refs.get(0);
    Assert.assertNotNull("Test data wasn't found, use \"// REF: \" directive",referenceToString);
  }
  int offset=myFixture.getEditor().getCaretModel().getOffset();
  PsiReference psiReference=myFixture.getFile().findReferenceAt(offset);
  if (psiReference != null) {
    PsiElement resolvedTo=psiReference.resolve();
    if (resolvedTo != null) {
      String resolvedToElementStr=ReferenceUtils.renderAsGotoImplementation(resolvedTo);
      String notEqualMessage=String.format("Found reference to '%s', but '%s' was expected",resolvedToElementStr,referenceToString);
      assertEquals(notEqualMessage,referenceToString,resolvedToElementStr);
    }
 else {
      if (!shouldBeUnresolved) {
        Assert.assertNull(String.format("Element %s wasn't resolved to anything, but %s was expected",psiReference,referenceToString),referenceToString);
      }
    }
  }
 else {
    Assert.assertNull(String.format("No reference found at offset: %s, but one resolved to %s was expected",offset,referenceToString),referenceToString);
  }
}
