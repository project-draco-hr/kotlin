{
  final Ref<DataFlowInfo> result=new Ref<DataFlowInfo>(context.dataFlowInfo);
  pattern.accept(new JetVisitorVoid(){
    @Override public void visitTypePattern(    JetTypePattern typePattern){
      JetTypeReference typeReference=typePattern.getTypeReference();
      if (typeReference == null)       return;
      JetType type=context.expressionTypingServices.getTypeResolver().resolveType(context.scope,typeReference,context.trace,true);
      checkTypeCompatibility(type,subjectType,typePattern);
      result.set(context.dataFlowInfo.establishSubtyping(subjectVariables,type));
    }
    @Override public void visitTuplePattern(    JetTuplePattern pattern){
      List<JetTuplePatternEntry> entries=pattern.getEntries();
      TypeConstructor typeConstructor=subjectType.getConstructor();
      if (!JetStandardClasses.getTuple(entries.size()).getTypeConstructor().equals(typeConstructor) || typeConstructor.getParameters().size() != entries.size()) {
        context.trace.report(TYPE_MISMATCH_IN_TUPLE_PATTERN.on(pattern,subjectType,entries.size()));
        return;
      }
      for (int i=0, entriesSize=entries.size(); i < entriesSize; i++) {
        JetTuplePatternEntry entry=entries.get(i);
        JetType type=subjectType.getArguments().get(i).getType();
        ASTNode nameLabelNode=entry.getNameLabelNode();
        if (nameLabelNode != null) {
          context.trace.report(UNSUPPORTED.on(nameLabelNode.getPsi(),getClass().getCanonicalName()));
        }
        JetPattern entryPattern=entry.getPattern();
        if (entryPattern != null) {
          result.set(result.get().and(checkPatternType(entryPattern,type,false,scopeToExtend,context)));
        }
      }
    }
    @Override public void visitDecomposerPattern(    JetDecomposerPattern pattern){
      JetExpression decomposerExpression=pattern.getDecomposerExpression();
      if (decomposerExpression != null) {
        ReceiverDescriptor receiver=new TransientReceiver(subjectType);
        JetType selectorReturnType=facade.getSelectorReturnTypeInfo(receiver,null,decomposerExpression,context).getType();
        if (pattern.getArgumentList() != null) {
          result.set(checkPatternType(pattern.getArgumentList(),selectorReturnType == null ? ErrorUtils.createErrorType("No type") : selectorReturnType,false,scopeToExtend,context));
        }
      }
    }
    @Override public void visitWildcardPattern(    JetWildcardPattern pattern){
    }
    @Override public void visitExpressionPattern(    JetExpressionPattern pattern){
      JetExpression expression=pattern.getExpression();
      if (expression == null)       return;
      JetType type=facade.getTypeInfo(expression,context.replaceScope(scopeToExtend)).getType();
      if (type == null)       return;
      if (conditionExpected) {
        JetType booleanType=JetStandardLibrary.getInstance().getBooleanType();
        if (!JetTypeChecker.INSTANCE.equalTypes(booleanType,type)) {
          context.trace.report(TYPE_MISMATCH_IN_CONDITION.on(pattern,type));
        }
        return;
      }
      checkTypeCompatibility(type,subjectType,pattern);
      DataFlowInfo dataFlowInfo=context.dataFlowInfo;
      DataFlowValue expressionDataFlowValue=DataFlowValueFactory.INSTANCE.createDataFlowValue(expression,type,context.trace.getBindingContext());
      for (      DataFlowValue subjectVariable : subjectVariables) {
        dataFlowInfo=dataFlowInfo.equate(subjectVariable,expressionDataFlowValue);
      }
      result.set(dataFlowInfo);
    }
    @Override public void visitBindingPattern(    JetBindingPattern pattern){
      JetProperty variableDeclaration=pattern.getVariableDeclaration();
      JetTypeReference propertyTypeRef=variableDeclaration.getPropertyTypeRef();
      JetType type=propertyTypeRef == null ? subjectType : context.expressionTypingServices.getTypeResolver().resolveType(context.scope,propertyTypeRef,context.trace,true);
      VariableDescriptor variableDescriptor=context.expressionTypingServices.getDescriptorResolver().resolveLocalVariableDescriptorWithType(context.scope.getContainingDeclaration(),variableDeclaration,type,context.trace);
      scopeToExtend.addVariableDescriptor(variableDescriptor);
      if (propertyTypeRef != null) {
        if (!JetTypeChecker.INSTANCE.isSubtypeOf(subjectType,type)) {
          context.trace.report(TYPE_MISMATCH_IN_BINDING_PATTERN.on(propertyTypeRef,type,subjectType));
        }
      }
      JetWhenCondition condition=pattern.getCondition();
      if (condition != null) {
        int oldLength=subjectVariables.length;
        DataFlowValue[] newSubjectVariables=new DataFlowValue[oldLength + 1];
        System.arraycopy(subjectVariables,0,newSubjectVariables,0,oldLength);
        newSubjectVariables[oldLength]=DataFlowValueFactory.INSTANCE.createDataFlowValue(variableDescriptor);
        result.set(checkWhenCondition(null,false,subjectType,condition,scopeToExtend,context,newSubjectVariables));
      }
    }
    private void checkTypeCompatibility(    @Nullable JetType type,    @NotNull JetType subjectType,    @NotNull JetElement reportErrorOn){
      if (type == null) {
        return;
      }
      if (TypeUtils.isIntersectionEmpty(type,subjectType)) {
        context.trace.report(INCOMPATIBLE_TYPES.on(reportErrorOn,type,subjectType));
        return;
      }
      if (BasicExpressionTypingVisitor.isCastErased(subjectType,type,JetTypeChecker.INSTANCE)) {
        context.trace.report(Errors.CANNOT_CHECK_FOR_ERASED.on(reportErrorOn,type));
      }
    }
    @Override public void visitJetElement(    JetElement element){
      context.trace.report(UNSUPPORTED.on(element,getClass().getCanonicalName()));
    }
  }
);
  return result.get();
}
