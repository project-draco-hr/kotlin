{
  final MutableClassDescriptor classObject=new MutableClassDescriptor(this,getScopeForMemberLookup(),ClassKind.CLASS_OBJECT,false,getClassObjectName(getName()));
  JetType supertype=KotlinBuiltIns.getInstance().getAnyType();
  classObject.setSupertypes(Collections.singleton(supertype));
  classObject.setModality(Modality.FINAL);
  classObject.setVisibility(DescriptorUtils.getSyntheticClassObjectVisibility());
  classObject.setTypeParameterDescriptors(Collections.<TypeParameterDescriptor>emptyList());
  classObject.setPrimaryConstructor(DescriptorFactory.createPrimaryConstructorForObject(classObject));
  classObject.createTypeConstructor();
  JetType enumType=getDefaultType();
  JetType enumArrayType=KotlinBuiltIns.getInstance().getArrayType(enumType);
  classObject.getBuilder().addFunctionDescriptor(DescriptorFactory.createEnumClassObjectValuesMethod(classObject,enumArrayType));
  classObject.getBuilder().addFunctionDescriptor(DescriptorFactory.createEnumClassObjectValueOfMethod(classObject,enumType));
  OverridingUtil.DescriptorSink sink=new OverridingUtil.DescriptorSink(){
    @Override public void addToScope(    @NotNull CallableMemberDescriptor fakeOverride){
      OverridingUtil.resolveUnknownVisibilityForMember(fakeOverride,null);
      classObject.getBuilder().addFunctionDescriptor((SimpleFunctionDescriptor)fakeOverride);
    }
    @Override public void conflict(    @NotNull CallableMemberDescriptor fromSuper,    @NotNull CallableMemberDescriptor fromCurrent){
      throw new IllegalStateException("Conflict on enum class object override: " + fromSuper + " vs "+ fromCurrent);
    }
  }
;
  JetScope superScope=supertype.getMemberScope();
  for (  DeclarationDescriptor descriptor : superScope.getAllDescriptors()) {
    if (descriptor instanceof FunctionDescriptor) {
      Name name=descriptor.getName();
      OverridingUtil.generateOverridesInFunctionGroup(name,superScope.getFunctions(name),Collections.<FunctionDescriptor>emptySet(),classObject,sink);
    }
  }
  return classObject;
}
