{
  if (superDescriptor instanceof FunctionDescriptor) {
    if (!(subDescriptor instanceof FunctionDescriptor))     return OverrideCompatibilityInfo.memberKindMismatch();
  }
 else   if (superDescriptor instanceof PropertyDescriptor) {
    if (!(subDescriptor instanceof PropertyDescriptor))     return OverrideCompatibilityInfo.memberKindMismatch();
  }
 else {
    throw new IllegalArgumentException("This type of CallableDescriptor cannot be checked for overridability: " + superDescriptor);
  }
  if (!superDescriptor.getName().equals(subDescriptor.getName())) {
    return OverrideCompatibilityInfo.nameMismatch();
  }
  OverrideCompatibilityInfo receiverAndParameterResult=checkReceiverAndParameterCount(superDescriptor,subDescriptor);
  if (receiverAndParameterResult != null) {
    return receiverAndParameterResult;
  }
  List<KotlinType> superValueParameters=compiledValueParameters(superDescriptor);
  List<KotlinType> subValueParameters=compiledValueParameters(subDescriptor);
  List<TypeParameterDescriptor> superTypeParameters=superDescriptor.getTypeParameters();
  List<TypeParameterDescriptor> subTypeParameters=subDescriptor.getTypeParameters();
  if (superTypeParameters.size() != subTypeParameters.size()) {
    for (int i=0; i < superValueParameters.size(); ++i) {
      KotlinType superValueParameterType=getUpperBound(superValueParameters.get(i));
      KotlinType subValueParameterType=getUpperBound(subValueParameters.get(i));
      if (!KotlinTypeChecker.DEFAULT.equalTypes(superValueParameterType,subValueParameterType)) {
        return OverrideCompatibilityInfo.typeParameterNumberMismatch();
      }
    }
    return OverrideCompatibilityInfo.valueParameterTypeMismatch(null,null,OverrideCompatibilityInfo.Result.CONFLICT);
  }
  final Map<TypeConstructor,TypeConstructor> matchingTypeConstructors=new HashMap<TypeConstructor,TypeConstructor>();
  for (int i=0, typeParametersSize=superTypeParameters.size(); i < typeParametersSize; i++) {
    TypeParameterDescriptor superTypeParameter=superTypeParameters.get(i);
    TypeParameterDescriptor subTypeParameter=subTypeParameters.get(i);
    matchingTypeConstructors.put(superTypeParameter.getTypeConstructor(),subTypeParameter.getTypeConstructor());
  }
  KotlinTypeChecker.TypeConstructorEquality localEqualityAxioms=new KotlinTypeChecker.TypeConstructorEquality(){
    @Override public boolean equals(    @NotNull TypeConstructor a,    @NotNull TypeConstructor b){
      if (equalityAxioms.equals(a,b))       return true;
      TypeConstructor img1=matchingTypeConstructors.get(a);
      TypeConstructor img2=matchingTypeConstructors.get(b);
      if (!(img1 != null && img1.equals(b)) && !(img2 != null && img2.equals(a))) {
        return false;
      }
      return true;
    }
  }
;
  for (int i=0, typeParametersSize=superTypeParameters.size(); i < typeParametersSize; i++) {
    TypeParameterDescriptor superTypeParameter=superTypeParameters.get(i);
    TypeParameterDescriptor subTypeParameter=subTypeParameters.get(i);
    if (!areTypesEquivalent(superTypeParameter.getUpperBoundsAsType(),subTypeParameter.getUpperBoundsAsType(),localEqualityAxioms)) {
      return OverrideCompatibilityInfo.boundsMismatch(superTypeParameter,subTypeParameter);
    }
  }
  for (int i=0, unsubstitutedValueParametersSize=superValueParameters.size(); i < unsubstitutedValueParametersSize; i++) {
    KotlinType superValueParameter=superValueParameters.get(i);
    KotlinType subValueParameter=subValueParameters.get(i);
    if (!areTypesEquivalent(superValueParameter,subValueParameter,localEqualityAxioms)) {
      return OverrideCompatibilityInfo.valueParameterTypeMismatch(superValueParameter,subValueParameter,INCOMPATIBLE);
    }
  }
  if (checkReturnType) {
    KotlinType superReturnType=superDescriptor.getReturnType();
    KotlinType subReturnType=subDescriptor.getReturnType();
    if (superReturnType != null && subReturnType != null) {
      boolean bothErrors=subReturnType.isError() && superReturnType.isError();
      if (!bothErrors && !KotlinTypeChecker.withAxioms(localEqualityAxioms).isSubtypeOf(subReturnType,superReturnType)) {
        return OverrideCompatibilityInfo.returnTypeMismatch(superReturnType,subReturnType);
      }
    }
  }
  for (  ExternalOverridabilityCondition externalCondition : EXTERNAL_CONDITIONS) {
    if (!externalCondition.isOverridable(superDescriptor,subDescriptor)) {
      return OverrideCompatibilityInfo.externalConditionFailed(externalCondition.getClass());
    }
  }
  return OverrideCompatibilityInfo.success();
}
