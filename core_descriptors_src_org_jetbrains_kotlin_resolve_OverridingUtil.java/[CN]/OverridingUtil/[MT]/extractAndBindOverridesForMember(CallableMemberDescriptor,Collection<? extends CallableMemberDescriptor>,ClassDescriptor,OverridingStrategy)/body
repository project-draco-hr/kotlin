{
  Collection<CallableMemberDescriptor> bound=new ArrayList<CallableMemberDescriptor>(descriptorsFromSuper.size());
  Collection<CallableMemberDescriptor> overridden=SmartSet.create();
  for (  CallableMemberDescriptor fromSupertype : descriptorsFromSuper) {
    OverrideCompatibilityInfo.Result result=DEFAULT.isOverridableBy(fromSupertype,fromCurrent,current).getResult();
    boolean isVisible=Visibilities.isVisibleIgnoringReceiver(fromSupertype,current);
switch (result) {
case OVERRIDABLE:
      if (isVisible) {
        overridden.add(fromSupertype);
      }
    bound.add(fromSupertype);
  break;
case CONFLICT:
if (isVisible) {
  strategy.overrideConflict(fromSupertype,fromCurrent);
}
bound.add(fromSupertype);
break;
case INCOMPATIBLE:
break;
}
}
strategy.setOverriddenDescriptors(fromCurrent,overridden);
return bound;
}
