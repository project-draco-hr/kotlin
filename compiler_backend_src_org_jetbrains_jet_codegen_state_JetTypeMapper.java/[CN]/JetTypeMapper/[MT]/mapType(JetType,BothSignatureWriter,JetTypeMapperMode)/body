{
  Type known=null;
  DeclarationDescriptor descriptor=jetType.getConstructor().getDeclarationDescriptor();
  if (mapBuiltinsToJava) {
    if (descriptor instanceof ClassDescriptor) {
      known=KotlinToJavaTypesMap.getInstance().getJavaAnalog(jetType);
    }
  }
  if (known != null) {
    if (kind == JetTypeMapperMode.VALUE) {
      return mapKnownAsmType(jetType,known,signatureVisitor);
    }
 else     if (kind == JetTypeMapperMode.TYPE_PARAMETER) {
      return mapKnownAsmType(jetType,boxType(known),signatureVisitor);
    }
 else     if (kind == JetTypeMapperMode.TRAIT_IMPL) {
      throw new IllegalStateException("TRAIT_IMPL is not possible for " + jetType);
    }
 else     if (kind == JetTypeMapperMode.IMPL) {
      if (mapBuiltinsToJava) {
      }
      return mapKnownAsmType(jetType,known,signatureVisitor);
    }
 else {
      throw new IllegalStateException("unknown kind: " + kind);
    }
  }
  final TypeConstructor constructor=jetType.getConstructor();
  if (constructor instanceof IntersectionTypeConstructor) {
    jetType=CommonSupertypes.commonSupertype(new ArrayList<JetType>(constructor.getSupertypes()));
  }
  if (descriptor == null) {
    throw new UnsupportedOperationException("no descriptor for type constructor of " + jetType);
  }
  if (ErrorUtils.isError(descriptor)) {
    if (classBuilderMode != ClassBuilderMode.SIGNATURES) {
      throw new IllegalStateException(generateErrorMessageForErrorType(descriptor));
    }
    Type asmType=Type.getObjectType("error/NonExistentClass");
    if (signatureVisitor != null) {
      signatureVisitor.writeAsmType(asmType,true);
    }
    checkValidType(asmType);
    return asmType;
  }
  if (mapBuiltinsToJava && descriptor instanceof ClassDescriptor && KotlinBuiltIns.getInstance().isArray(jetType)) {
    if (jetType.getArguments().size() != 1) {
      throw new UnsupportedOperationException("arrays must have one type argument");
    }
    TypeProjection memberProjection=jetType.getArguments().get(0);
    JetType memberType=memberProjection.getType();
    if (signatureVisitor != null) {
      signatureVisitor.writeArrayType(jetType.isNullable(),memberProjection.getProjectionKind());
      mapType(memberType,signatureVisitor,JetTypeMapperMode.TYPE_PARAMETER);
      signatureVisitor.writeArrayEnd();
    }
    Type r;
    if (!isGenericsArray(jetType)) {
      r=Type.getType("[" + boxType(mapType(memberType,kind)).getDescriptor());
    }
 else {
      r=AsmTypeConstants.JAVA_ARRAY_GENERIC_TYPE;
    }
    checkValidType(r);
    return r;
  }
  if (descriptor instanceof ClassDescriptor) {
    JvmClassName name=getJvmInternalName(bindingTrace,descriptor);
    Type asmType;
    if (kind == JetTypeMapperMode.TRAIT_IMPL) {
      asmType=Type.getObjectType(name.getInternalName() + JvmAbi.TRAIT_IMPL_SUFFIX);
    }
 else {
      asmType=name.getAsmType();
    }
    boolean forceReal=KotlinToJavaTypesMap.getInstance().isForceReal(name);
    writeGenericType(signatureVisitor,asmType,jetType,forceReal);
    checkValidType(asmType);
    return asmType;
  }
  if (descriptor instanceof TypeParameterDescriptor) {
    TypeParameterDescriptor typeParameterDescriptor=(TypeParameterDescriptor)descriptor;
    Type type=mapType(typeParameterDescriptor.getUpperBoundsAsType(),kind);
    if (signatureVisitor != null) {
      signatureVisitor.writeTypeVariable(typeParameterDescriptor.getName(),jetType.isNullable(),type);
    }
    checkValidType(type);
    return type;
  }
  throw new UnsupportedOperationException("Unknown type " + jetType);
}
