{
  NodeList childNodes=element.getChildNodes();
  int count=childNodes.getLength();
  Map<String,LayoutNode> nodes=Maps.newHashMap();
  for (int i=0; i < count; i++) {
    Node node=childNodes.item(i);
    if (node.getNodeType() == Node.ELEMENT_NODE) {
      LayoutNode ln=new LayoutNode((Element)node,i);
      nodes.put(ln.getNodeId(),ln);
    }
  }
  for (  LayoutNode ln : nodes.values()) {
    ln.processNode(nodes);
  }
  for (  LayoutNode right : nodes.values()) {
    if (!right.mLastLeft || right.skip()) {
      continue;
    }
    Set<LayoutNode> canGrowLeft=right.canGrowLeft();
    for (    LayoutNode left : nodes.values()) {
      if (left == right || !left.mLastRight || left.skip() || !left.sameBucket(right)) {
        continue;
      }
      Set<LayoutNode> canGrowRight=left.canGrowRight();
      if (!canGrowLeft.isEmpty() || !canGrowRight.isEmpty()) {
        canGrowRight.addAll(canGrowLeft);
        LayoutNode nodeToBlame=right;
        LayoutNode otherNode=left;
        if (!canGrowRight.contains(right) && canGrowRight.contains(left)) {
          nodeToBlame=left;
          otherNode=right;
        }
        context.report(ISSUE,nodeToBlame.getNode(),context.getLocation(nodeToBlame.getNode()),String.format("`%1$s` can overlap `%2$s` if %3$s %4$s due to localized text expansion",nodeToBlame.getNodeId(),otherNode.getNodeId(),Joiner.on(", ").join(canGrowRight),canGrowRight.size() > 1 ? "grow" : "grows"));
      }
    }
  }
}
