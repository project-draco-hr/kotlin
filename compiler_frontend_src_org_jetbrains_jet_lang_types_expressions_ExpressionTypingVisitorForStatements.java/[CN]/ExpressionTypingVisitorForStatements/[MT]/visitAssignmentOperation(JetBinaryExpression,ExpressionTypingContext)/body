{
  TemporaryBindingTrace temporaryBindingTrace=TemporaryBindingTrace.create(contextWithExpectedType.trace);
  ExpressionTypingContext context=contextWithExpectedType.replaceExpectedType(TypeUtils.NO_EXPECTED_TYPE).replaceExpectedReturnType(TypeUtils.NO_EXPECTED_TYPE).replaceBindingTrace(temporaryBindingTrace);
  JetSimpleNameExpression operationSign=expression.getOperationReference();
  IElementType operationType=operationSign.getReferencedNameElementType();
  JetExpression left=JetPsiUtil.deparenthesize(expression.getLeft());
  if (left == null)   return null;
  JetType leftType=facade.getType(left,context);
  if (leftType == null) {
    facade.getType(expression.getRight(),context);
    context.trace.report(UNRESOLVED_REFERENCE.on(operationSign));
    temporaryBindingTrace.commit();
    return null;
  }
  ExpressionReceiver receiver=new ExpressionReceiver(left,leftType);
  String name=OperatorConventions.ASSIGNMENT_OPERATIONS.get(operationType);
  TemporaryBindingTrace assignmentOperationTrace=TemporaryBindingTrace.create(context.trace);
  OverloadResolutionResults<FunctionDescriptor> assignmentOperationDescriptors=basic.getResolutionResultsForBinaryCall(scope,name,context.replaceBindingTrace(assignmentOperationTrace),expression,receiver);
  JetType assignmentOperationType=OverloadResolutionResultsUtil.getResultType(assignmentOperationDescriptors);
  String counterpartName=OperatorConventions.BINARY_OPERATION_NAMES.get(OperatorConventions.ASSIGNMENT_OPERATION_COUNTERPARTS.get(operationType));
  TemporaryBindingTrace binaryOperationTrace=TemporaryBindingTrace.create(context.trace);
  OverloadResolutionResults<FunctionDescriptor> binaryOperationDescriptors=basic.getResolutionResultsForBinaryCall(scope,counterpartName,context.replaceBindingTrace(binaryOperationTrace),expression,receiver);
  JetType binaryOperationType=OverloadResolutionResultsUtil.getResultType(binaryOperationDescriptors);
  JetType type=assignmentOperationType != null ? assignmentOperationType : binaryOperationType;
  if (assignmentOperationType != null && binaryOperationType != null) {
    OverloadResolutionResults<FunctionDescriptor> ambiguityResolutionResults=OverloadResolutionResultsUtil.ambiguity(assignmentOperationDescriptors,binaryOperationDescriptors);
    context.trace.report(ASSIGN_OPERATOR_AMBIGUITY.on(operationSign,ambiguityResolutionResults.getResultingCalls()));
    Collection<DeclarationDescriptor> descriptors=Sets.newHashSet();
    for (    ResolvedCall<? extends FunctionDescriptor> call : ambiguityResolutionResults.getResultingCalls()) {
      descriptors.add(call.getResultingDescriptor());
    }
    facade.getType(expression.getRight(),context);
    context.trace.record(AMBIGUOUS_REFERENCE_TARGET,operationSign,descriptors);
  }
 else   if (assignmentOperationType != null) {
    assignmentOperationTrace.commit();
    if (!JetStandardClasses.isUnit(assignmentOperationType)) {
      context.trace.report(ASSIGNMENT_OPERATOR_SHOULD_RETURN_UNIT.on(operationSign,assignmentOperationDescriptors.getResultingDescriptor(),operationSign));
    }
  }
 else {
    binaryOperationTrace.commit();
    context.trace.record(VARIABLE_REASSIGNMENT,expression);
    ExpressionTypingUtils.checkWrappingInRef(expression.getLeft(),context);
    if (left instanceof JetArrayAccessExpression) {
      ExpressionTypingContext contextForResolve=context.replaceScope(scope).replaceBindingTrace(TemporaryBindingTrace.create(contextWithExpectedType.trace));
      basic.resolveArrayAccessSetMethod((JetArrayAccessExpression)left,expression.getRight(),contextForResolve,context.trace);
    }
  }
  basic.checkLValue(context.trace,expression.getLeft());
  temporaryBindingTrace.commit();
  return checkAssignmentType(type,expression,contextWithExpectedType);
}
