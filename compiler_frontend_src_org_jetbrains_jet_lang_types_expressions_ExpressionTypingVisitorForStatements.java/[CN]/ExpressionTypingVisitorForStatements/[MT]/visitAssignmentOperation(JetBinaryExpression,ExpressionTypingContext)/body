{
  TemporaryTraceAndCache temporary=TemporaryTraceAndCache.create(contextWithExpectedType,"trace to resolve array set method for binary expression",expression);
  ExpressionTypingContext context=contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE).replaceTraceAndCache(temporary).replaceContextDependency(INDEPENDENT);
  JetSimpleNameExpression operationSign=expression.getOperationReference();
  IElementType operationType=operationSign.getReferencedNameElementType();
  JetExpression leftOperand=expression.getLeft();
  JetTypeInfo leftInfo=ExpressionTypingUtils.getTypeInfoOrNullType(leftOperand,context,facade);
  JetType leftType=leftInfo.getType();
  DataFlowInfo dataFlowInfo=leftInfo.getDataFlowInfo();
  JetExpression right=expression.getRight();
  JetExpression left=leftOperand == null ? null : JetPsiUtil.deparenthesize(leftOperand);
  if (right == null || left == null) {
    temporary.commit();
    return JetTypeInfo.create(null,dataFlowInfo);
  }
  if (leftType == null) {
    dataFlowInfo=facade.getTypeInfo(right,context.replaceDataFlowInfo(dataFlowInfo)).getDataFlowInfo();
    context.trace.report(UNRESOLVED_REFERENCE.on(operationSign,operationSign));
    temporary.commit();
    return JetTypeInfo.create(null,dataFlowInfo);
  }
  ExpressionReceiver receiver=new ExpressionReceiver(left,leftType);
  Name name=OperatorConventions.ASSIGNMENT_OPERATIONS.get(operationType);
  TemporaryTraceAndCache temporaryForAssignmentOperation=TemporaryTraceAndCache.create(context,"trace to check assignment operation like '+=' for",expression);
  OverloadResolutionResults<FunctionDescriptor> assignmentOperationDescriptors=components.callResolver.resolveBinaryCall(context.replaceTraceAndCache(temporaryForAssignmentOperation).replaceScope(scope),receiver,expression,name);
  JetType assignmentOperationType=OverloadResolutionResultsUtil.getResultingType(assignmentOperationDescriptors,context.contextDependency);
  Name counterpartName=OperatorConventions.BINARY_OPERATION_NAMES.get(OperatorConventions.ASSIGNMENT_OPERATION_COUNTERPARTS.get(operationType));
  TemporaryTraceAndCache temporaryForBinaryOperation=TemporaryTraceAndCache.create(context,"trace to check binary operation like '+' for",expression);
  OverloadResolutionResults<FunctionDescriptor> binaryOperationDescriptors=components.callResolver.resolveBinaryCall(context.replaceTraceAndCache(temporaryForBinaryOperation).replaceScope(scope),receiver,expression,counterpartName);
  JetType binaryOperationType=OverloadResolutionResultsUtil.getResultingType(binaryOperationDescriptors,context.contextDependency);
  JetType type=assignmentOperationType != null ? assignmentOperationType : binaryOperationType;
  if (assignmentOperationDescriptors.isSuccess() && binaryOperationDescriptors.isSuccess()) {
    OverloadResolutionResults<FunctionDescriptor> ambiguityResolutionResults=OverloadResolutionResultsUtil.ambiguity(assignmentOperationDescriptors,binaryOperationDescriptors);
    context.trace.report(ASSIGN_OPERATOR_AMBIGUITY.on(operationSign,ambiguityResolutionResults.getResultingCalls()));
    Collection<DeclarationDescriptor> descriptors=Sets.newHashSet();
    for (    ResolvedCall<?> resolvedCall : ambiguityResolutionResults.getResultingCalls()) {
      descriptors.add(resolvedCall.getResultingDescriptor());
    }
    dataFlowInfo=facade.getTypeInfo(right,context.replaceDataFlowInfo(dataFlowInfo)).getDataFlowInfo();
    context.trace.record(AMBIGUOUS_REFERENCE_TARGET,operationSign,descriptors);
  }
 else   if (assignmentOperationType != null && (assignmentOperationDescriptors.isSuccess() || !binaryOperationDescriptors.isSuccess())) {
    temporaryForAssignmentOperation.commit();
    if (!KotlinBuiltIns.getInstance().isUnit(assignmentOperationType)) {
      context.trace.report(ASSIGNMENT_OPERATOR_SHOULD_RETURN_UNIT.on(operationSign,assignmentOperationDescriptors.getResultingDescriptor(),operationSign));
    }
  }
 else {
    temporaryForBinaryOperation.commit();
    context.trace.record(VARIABLE_REASSIGNMENT,expression);
    if (left instanceof JetArrayAccessExpression) {
      ExpressionTypingContext contextForResolve=context.replaceScope(scope).replaceBindingTrace(TemporaryBindingTrace.create(context.trace,"trace to resolve array set method for assignment",expression));
      basic.resolveArrayAccessSetMethod((JetArrayAccessExpression)left,right,contextForResolve,context.trace);
    }
    dataFlowInfo=facade.getTypeInfo(right,context.replaceDataFlowInfo(dataFlowInfo)).getDataFlowInfo();
    BasicExpressionTypingVisitor.checkLValue(context.trace,leftOperand);
  }
  temporary.commit();
  return JetTypeInfo.create(checkAssignmentType(type,expression,contextWithExpectedType),dataFlowInfo);
}
