{
  TemporaryBindingTrace temporaryBindingTrace=TemporaryBindingTrace.create(contextWithExpectedType.trace,"trace to resolve array set method for binary expression",expression);
  ExpressionTypingContext context=contextWithExpectedType.replaceExpectedType(TypeUtils.NO_EXPECTED_TYPE).replaceBindingTrace(temporaryBindingTrace);
  JetSimpleNameExpression operationSign=expression.getOperationReference();
  IElementType operationType=operationSign.getReferencedNameElementType();
  JetTypeInfo leftInfo=facade.getTypeInfo(expression.getLeft(),context);
  JetType leftType=leftInfo.getType();
  DataFlowInfo dataFlowInfo=leftInfo.getDataFlowInfo();
  JetExpression right=expression.getRight();
  JetExpression left=JetPsiUtil.deparenthesizeWithNoTypeResolution(expression.getLeft());
  if (right == null || left == null) {
    temporaryBindingTrace.commit();
    return JetTypeInfo.create(null,dataFlowInfo);
  }
  if (leftType == null) {
    dataFlowInfo=facade.getTypeInfo(right,context.replaceDataFlowInfo(dataFlowInfo)).getDataFlowInfo();
    context.trace.report(UNRESOLVED_REFERENCE.on(operationSign,operationSign));
    temporaryBindingTrace.commit();
    return JetTypeInfo.create(null,dataFlowInfo);
  }
  ExpressionReceiver receiver=new ExpressionReceiver(left,leftType);
  Name name=OperatorConventions.ASSIGNMENT_OPERATIONS.get(operationType);
  TemporaryBindingTrace assignmentOperationTrace=TemporaryBindingTrace.create(context.trace,"trace to check assignment operation like '+=' for",expression);
  OverloadResolutionResults<FunctionDescriptor> assignmentOperationDescriptors=BasicExpressionTypingVisitor.getResolutionResultsForBinaryCall(scope,name,context.replaceBindingTrace(assignmentOperationTrace),expression,receiver);
  JetType assignmentOperationType=OverloadResolutionResultsUtil.getResultType(assignmentOperationDescriptors);
  Name counterpartName=OperatorConventions.BINARY_OPERATION_NAMES.get(OperatorConventions.ASSIGNMENT_OPERATION_COUNTERPARTS.get(operationType));
  TemporaryBindingTrace binaryOperationTrace=TemporaryBindingTrace.create(context.trace,"trace to check binary operation like '+' for",expression);
  OverloadResolutionResults<FunctionDescriptor> binaryOperationDescriptors=BasicExpressionTypingVisitor.getResolutionResultsForBinaryCall(scope,counterpartName,context.replaceBindingTrace(binaryOperationTrace),expression,receiver);
  JetType binaryOperationType=OverloadResolutionResultsUtil.getResultType(binaryOperationDescriptors);
  JetType type=assignmentOperationType != null ? assignmentOperationType : binaryOperationType;
  if (assignmentOperationType != null && binaryOperationType != null) {
    OverloadResolutionResults<FunctionDescriptor> ambiguityResolutionResults=OverloadResolutionResultsUtil.ambiguity(assignmentOperationDescriptors,binaryOperationDescriptors);
    context.trace.report(ASSIGN_OPERATOR_AMBIGUITY.on(operationSign,ambiguityResolutionResults.getResultingCalls()));
    Collection<DeclarationDescriptor> descriptors=Sets.newHashSet();
    for (    ResolvedCall<? extends FunctionDescriptor> call : ambiguityResolutionResults.getResultingCalls()) {
      descriptors.add(call.getResultingDescriptor());
    }
    dataFlowInfo=facade.getTypeInfo(right,context.replaceDataFlowInfo(dataFlowInfo)).getDataFlowInfo();
    context.trace.record(AMBIGUOUS_REFERENCE_TARGET,operationSign,descriptors);
  }
 else   if (assignmentOperationType != null) {
    assignmentOperationTrace.commit();
    if (!KotlinBuiltIns.getInstance().isUnit(assignmentOperationType)) {
      context.trace.report(ASSIGNMENT_OPERATOR_SHOULD_RETURN_UNIT.on(operationSign,assignmentOperationDescriptors.getResultingDescriptor(),operationSign));
    }
  }
 else {
    binaryOperationTrace.commit();
    context.trace.record(VARIABLE_REASSIGNMENT,expression);
    if (left instanceof JetArrayAccessExpression) {
      ExpressionTypingContext contextForResolve=context.replaceScope(scope).replaceBindingTrace(TemporaryBindingTrace.create(contextWithExpectedType.trace,"trace to resolve array set method for assignment",expression));
      basic.resolveArrayAccessSetMethod((JetArrayAccessExpression)left,right,contextForResolve,context.trace);
    }
    dataFlowInfo=facade.getTypeInfo(right,context.replaceDataFlowInfo(dataFlowInfo)).getDataFlowInfo();
    BasicExpressionTypingVisitor.checkLValue(context.trace,expression.getLeft());
  }
  temporaryBindingTrace.commit();
  return JetTypeInfo.create(checkAssignmentType(type,expression,contextWithExpectedType),dataFlowInfo);
}
