{
  final PsiElement element=getTargetElement(descriptor);
  JetElement codeBlockForLocalDeclaration=getEnclosingElementForLocalDeclaration(element);
  if (codeBlockForLocalDeclaration != null) {
    BindingContext bindingContext=ResolutionUtils.analyze((JetElement)element,BodyResolveMode.FULL);
    final Map<PsiReference,PsiElement> referencesToElements=new HashMap<PsiReference,PsiElement>();
    codeBlockForLocalDeclaration.accept(new CalleeReferenceVisitorBase(bindingContext,true){
      @Override protected void processDeclaration(      JetSimpleNameExpression reference,      PsiElement declaration){
        if (!declaration.equals(element))         return;
        PsiElement container=PsiTreeUtil.getParentOfType(reference,JetNamedFunction.class,JetPropertyAccessor.class,JetClassOrObject.class);
        if (container instanceof JetPropertyAccessor) {
          container=PsiTreeUtil.getParentOfType(container,JetProperty.class);
        }
        if (container != null) {
          referencesToElements.put(ReferencesPackage.getMainReference(reference),container);
        }
      }
    }
);
    return collectNodeDescriptors(descriptor,referencesToElements,null);
  }
  SearchScope searchScope=getSearchScope(scopeType,basePsiClass);
  Map<PsiElement,HierarchyNodeDescriptor> methodToDescriptorMap=Maps.newHashMap();
  Object[] javaCallers=null;
  if (element instanceof PsiMethod) {
    javaCallers=javaTreeStructure.getChildElements(getJavaNodeDescriptor(descriptor));
    processPsiMethodCallers(Collections.singleton((PsiMethod)element),descriptor,methodToDescriptorMap,searchScope,true);
  }
  if (element instanceof JetNamedFunction || element instanceof JetSecondaryConstructor) {
    Collection<PsiMethod> lightMethods=LightClassUtil.INSTANCE$.getLightClassMethods((JetFunction)element);
    processPsiMethodCallers(lightMethods,descriptor,methodToDescriptorMap,searchScope,false);
  }
  if (element instanceof JetProperty) {
    LightClassUtil.PropertyAccessorsPsiMethods propertyMethods=LightClassUtil.INSTANCE$.getLightClassPropertyMethods((JetProperty)element);
    processPsiMethodCallers(propertyMethods,descriptor,methodToDescriptorMap,searchScope,false);
  }
  if (element instanceof JetClassOrObject) {
    JetPrimaryConstructor constructor=((JetClassOrObject)element).getPrimaryConstructor();
    if (constructor != null) {
      PsiMethod lightMethod=LightClassUtil.INSTANCE$.getLightClassMethod(constructor);
      processPsiMethodCallers(Collections.singleton(lightMethod),descriptor,methodToDescriptorMap,searchScope,false);
    }
 else {
      processJetClassOrObjectCallers((JetClassOrObject)element,descriptor,methodToDescriptorMap,searchScope);
    }
  }
  Object[] callers=methodToDescriptorMap.values().toArray(new Object[methodToDescriptorMap.size()]);
  return (javaCallers != null) ? ArrayUtil.mergeArrays(javaCallers,callers) : callers;
}
