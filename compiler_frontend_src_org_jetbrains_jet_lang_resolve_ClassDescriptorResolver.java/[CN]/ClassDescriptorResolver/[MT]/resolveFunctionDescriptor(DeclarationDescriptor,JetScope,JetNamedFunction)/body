{
  final FunctionDescriptorImpl functionDescriptor=new FunctionDescriptorImpl(containingDescriptor,annotationResolver.resolveAnnotations(scope,function.getModifierList()),JetPsiUtil.safeName(function.getName()));
  WritableScope innerScope=new WritableScopeImpl(scope,functionDescriptor,trace.getErrorHandler()).setDebugName("Function descriptor header scope");
  innerScope.addLabeledDeclaration(functionDescriptor);
  List<TypeParameterDescriptor> typeParameterDescriptors=resolveTypeParameters(functionDescriptor,innerScope,function.getTypeParameters());
  resolveGenericBounds(function,innerScope,typeParameterDescriptors);
  JetType receiverType=null;
  JetTypeReference receiverTypeRef=function.getReceiverTypeRef();
  if (receiverTypeRef != null) {
    JetScope scopeForReceiver=function.hasTypeParameterListBeforeFunctionName() ? innerScope : scope;
    receiverType=typeResolver.resolveType(scopeForReceiver,receiverTypeRef);
  }
  List<ValueParameterDescriptor> valueParameterDescriptors=resolveValueParameters(functionDescriptor,innerScope,function.getValueParameters());
  JetTypeReference returnTypeRef=function.getReturnTypeRef();
  JetType returnType;
  if (returnTypeRef != null) {
    returnType=typeResolver.resolveType(innerScope,returnTypeRef);
  }
 else   if (function.hasBlockBody()) {
    returnType=JetStandardClasses.getUnitType();
  }
 else {
    final JetExpression bodyExpression=function.getBodyExpression();
    if (bodyExpression != null) {
      returnType=new DeferredType(new LazyValue<JetType>(){
        @Override protected JetType compute(){
          JetFlowInformationProvider flowInformationProvider=computeFlowData(function,bodyExpression);
          return semanticServices.getTypeInferrerServices(trace,flowInformationProvider).inferFunctionReturnType(scope,function,functionDescriptor);
        }
      }
);
    }
 else {
      trace.getErrorHandler().genericError(function.asElement().getNode(),"This function must either declare a return type or have a body element");
      returnType=ErrorUtils.createErrorType("No type, no body");
    }
  }
  Modality defaultModality;
  if (containingDescriptor instanceof ClassDescriptor) {
    boolean isDefinitelyAbstract=((ClassDescriptor)containingDescriptor).getKind() == ClassKind.TRAIT && function.getBodyExpression() == null;
    defaultModality=isDefinitelyAbstract ? Modality.ABSTRACT : Modality.FINAL;
  }
 else {
    defaultModality=Modality.FINAL;
  }
  Modality modality=resolveModalityFromModifiers(function.getModifierList(),defaultModality);
  functionDescriptor.initialize(receiverType,typeParameterDescriptors,valueParameterDescriptors,returnType,modality);
  trace.record(BindingContext.FUNCTION,function,functionDescriptor);
  return functionDescriptor;
}
