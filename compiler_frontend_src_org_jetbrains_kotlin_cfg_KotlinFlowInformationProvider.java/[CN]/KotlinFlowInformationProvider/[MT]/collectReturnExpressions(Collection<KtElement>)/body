{
  final Set<Instruction> instructions=Sets.newHashSet(pseudocode.getInstructions());
  SubroutineExitInstruction exitInstruction=pseudocode.getExitInstruction();
  for (  Instruction previousInstruction : exitInstruction.getPreviousInstructions()) {
    previousInstruction.accept(new InstructionVisitor(){
      @Override public void visitReturnValue(      @NotNull ReturnValueInstruction instruction){
        if (instructions.contains(instruction)) {
          returnedExpressions.add(instruction.getElement());
        }
      }
      @Override public void visitReturnNoValue(      @NotNull ReturnNoValueInstruction instruction){
        if (instructions.contains(instruction)) {
          returnedExpressions.add(instruction.getElement());
        }
      }
      @Override public void visitJump(      @NotNull AbstractJumpInstruction instruction){
      }
      @Override public void visitUnconditionalJump(      @NotNull UnconditionalJumpInstruction instruction){
        redirectToPrevInstructions(instruction);
      }
      private void redirectToPrevInstructions(      Instruction instruction){
        for (        Instruction previousInstruction : instruction.getPreviousInstructions()) {
          previousInstruction.accept(this);
        }
      }
      @Override public void visitNondeterministicJump(      @NotNull NondeterministicJumpInstruction instruction){
        redirectToPrevInstructions(instruction);
      }
      @Override public void visitMarkInstruction(      @NotNull MarkInstruction instruction){
        redirectToPrevInstructions(instruction);
      }
      @Override public void visitInstruction(      @NotNull Instruction instruction){
        if (instruction instanceof KtElementInstruction) {
          KtElementInstruction elementInstruction=(KtElementInstruction)instruction;
          returnedExpressions.add(elementInstruction.getElement());
        }
 else {
          throw new IllegalStateException(instruction + " precedes the exit point");
        }
      }
    }
);
  }
}
