{
  Disposable junk=new Disposable(){
    @Override public void dispose(){
    }
  }
;
  JetCoreEnvironment jetCoreEnvironment;
  if (jar != null) {
    jetCoreEnvironment=JetTestUtils.createEnvironmentWithMockJdkAndIdeaAnnotations(junk,ConfigurationKind.JDK_AND_ANNOTATIONS);
    jetCoreEnvironment.addToClasspath(jar);
  }
 else {
    CompilerConfiguration configuration=CompileCompilerDependenciesTest.compilerConfigurationForTests(ConfigurationKind.JDK_AND_ANNOTATIONS,TestJdkKind.FULL_JDK);
    jetCoreEnvironment=JetCoreEnvironment.createCoreEnvironmentForJVM(junk,configuration);
    if (!PathUtil.findRtJar().equals(jar)) {
      throw new RuntimeException("rt.jar mismatch: " + jar + ", "+ PathUtil.findRtJar());
    }
  }
  InjectorForJavaSemanticServices injector=new InjectorForJavaSemanticServices(BuiltinsScopeExtensionMode.ALL,jetCoreEnvironment.getProject());
  boolean hasErrors;
  try {
    hasErrors=false;
    for (int count=0; count < classesPerChunk; ) {
      ZipEntry entry=zip.getNextEntry();
      if (entry == null) {
        break;
      }
      if (count == 0) {
        System.err.println("chunk from " + entry.getName());
      }
      System.err.println(entry.getName());
      String entryName=entry.getName();
      if (!entryName.endsWith(".class")) {
        continue;
      }
      if (entryName.matches("(.*/|)package-info\\.class")) {
        continue;
      }
      if (entryName.contains("$")) {
        continue;
      }
      String className=entryName.substring(0,entryName.length() - ".class".length()).replace("/",".");
      try {
        ClassDescriptor clazz=injector.getJavaDescriptorResolver().resolveClass(new FqName(className),DescriptorSearchRule.ERROR_IF_FOUND_IN_KOTLIN);
        if (clazz == null) {
          throw new IllegalStateException("class not found by name " + className + " in "+ libDescription);
        }
        clazz.getDefaultType().getMemberScope().getAllDescriptors();
      }
 catch (      Exception e) {
        System.err.println("failed to resolve " + className);
        e.printStackTrace();
        hasErrors=true;
      }
      ++count;
    }
  }
  finally {
    Disposer.dispose(junk);
  }
  return hasErrors;
}
