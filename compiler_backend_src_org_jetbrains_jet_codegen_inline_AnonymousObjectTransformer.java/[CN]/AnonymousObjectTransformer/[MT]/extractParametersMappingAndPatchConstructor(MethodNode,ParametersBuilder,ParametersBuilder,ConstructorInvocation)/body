{
  CapturedParamOwner owner=new CapturedParamOwner(){
    @Override public Type getType(){
      return Type.getObjectType(invocation.getOwnerInternalName());
    }
  }
;
  List<LambdaInfo> capturedLambdas=new ArrayList<LambdaInfo>();
  List<CapturedParamInfo> constructorAdditionalFakeParams=new ArrayList<CapturedParamInfo>();
  Map<Integer,LambdaInfo> indexToLambda=invocation.getLambdasToInline();
  Set<Integer> capturedParams=new HashSet<Integer>();
  AbstractInsnNode cur=constructor.instructions.getFirst();
  while (cur != null) {
    if (cur instanceof FieldInsnNode) {
      FieldInsnNode fieldNode=(FieldInsnNode)cur;
      if (fieldNode.getOpcode() == Opcodes.PUTFIELD && InlineCodegenUtil.isCapturedFieldName(fieldNode.name)) {
        boolean isPrevVarNode=fieldNode.getPrevious() instanceof VarInsnNode;
        boolean isPrevPrevVarNode=isPrevVarNode && fieldNode.getPrevious().getPrevious() instanceof VarInsnNode;
        if (isPrevPrevVarNode) {
          VarInsnNode node=(VarInsnNode)fieldNode.getPrevious().getPrevious();
          if (node.var == 0) {
            VarInsnNode previous=(VarInsnNode)fieldNode.getPrevious();
            int varIndex=previous.var;
            LambdaInfo lambdaInfo=indexToLambda.get(varIndex);
            CapturedParamInfo info=capturedParamBuilder.addCapturedParam(owner,fieldNode.name,Type.getType(fieldNode.desc),lambdaInfo != null,null);
            if (lambdaInfo != null) {
              info.setLambda(lambdaInfo);
              capturedLambdas.add(lambdaInfo);
            }
            constructorAdditionalFakeParams.add(info);
            capturedParams.add(varIndex);
            constructor.instructions.remove(previous.getPrevious());
            constructor.instructions.remove(previous);
            AbstractInsnNode temp=cur;
            cur=cur.getNext();
            constructor.instructions.remove(temp);
            continue;
          }
        }
      }
    }
    cur=cur.getNext();
  }
  constructorParamBuilder.addThis(oldObjectType,false);
  Type[] types=Type.getArgumentTypes(invocation.getDesc());
  for (  Type type : types) {
    LambdaInfo info=indexToLambda.get(constructorParamBuilder.getNextValueParameterIndex());
    ParameterInfo parameterInfo=constructorParamBuilder.addNextParameter(type,info != null,null);
    parameterInfo.setLambda(info);
    if (capturedParams.contains(parameterInfo.getIndex())) {
      parameterInfo.setCaptured(true);
    }
 else {
    }
  }
  Map<String,LambdaInfo> capturedLambdasToInline=new HashMap<String,LambdaInfo>();
  List<CapturedParamDesc> allRecapturedParameters=new ArrayList<CapturedParamDesc>();
  for (  LambdaInfo info : capturedLambdas) {
    for (    CapturedParamDesc desc : info.getCapturedVars()) {
      CapturedParamInfo recapturedParamInfo=capturedParamBuilder.addCapturedParam(desc,getNewFieldName(desc.getFieldName()));
      StackValue composed=StackValue.composed(StackValue.local(0,oldObjectType),StackValue.field(desc.getType(),oldObjectType,recapturedParamInfo.getNewFieldName(),false));
      recapturedParamInfo.setRemapValue(composed);
      allRecapturedParameters.add(desc);
      constructorParamBuilder.addCapturedParam(recapturedParamInfo,recapturedParamInfo.getNewFieldName()).setRemapValue(composed);
    }
    capturedLambdasToInline.put(info.getLambdaClassType().getInternalName(),info);
  }
  invocation.setAllRecapturedParameters(allRecapturedParameters);
  invocation.setCapturedLambdasToInline(capturedLambdasToInline);
  return constructorAdditionalFakeParams;
}
