{
  final Set<String> modifiers=modifiersListToModifiersSet(psiClass.getModifierList());
  final List<Class> innerClasses=classesToClassList(psiClass.getAllInnerClasses());
  final List<Function> methods=methodsToFunctionList(psiClass.getMethods(),true);
  final List<Field> fields=fieldsToFieldList(psiClass.getAllFields());
  final List<Element> typeParameters=elementsToElementList(psiClass.getTypeParameters());
  final List<Type> implementsTypes=typesToNotNullableTypeList(psiClass.getImplementsListTypes());
  final List<Type> extendsTypes=typesToNotNullableTypeList(psiClass.getExtendsListTypes());
  final IdentifierImpl name=new IdentifierImpl(psiClass.getName());
  final List<Expression> baseClassParams=new LinkedList<Expression>();
  final SuperVisitor visitor=new SuperVisitor();
  psiClass.accept(visitor);
  final HashSet<PsiExpressionList> resolvedSuperCallParameters=visitor.getResolvedSuperCallParameters();
  if (resolvedSuperCallParameters.size() == 1)   baseClassParams.addAll(expressionsToExpressionList(resolvedSuperCallParameters.toArray(new PsiExpressionList[1])[0].getExpressions()));
  if (!psiClass.isEnum() && !psiClass.isInterface() && getPrimaryConstructorForThisCase(psiClass) == null) {
    final List<Field> finalOrWithEmptyInitializer=getFinalOrWithEmptyInitializer(fields);
    final Map<String,String> initializers=new HashMap<String,String>();
    for (    final Function f : methods) {
      for (      Field fo : finalOrWithEmptyInitializer) {
        String init=getDefaultInitializer(fo);
        initializers.put(fo.getIdentifier().toKotlin(),init);
      }
      if (f.getKind() == INode.Kind.CONSTRUCTOR && !((Constructor)f).isPrimary()) {
        final List<Statement> newStatements=new LinkedList<Statement>();
        for (        Statement s : f.getBlock().getStatements()) {
          boolean isRemoved=false;
          if (s.getKind() == INode.Kind.ASSINGNMENT_EXPRESSION) {
            final AssignmentExpression assignmentExpression=(AssignmentExpression)s;
            if (assignmentExpression.getLeft().getKind() == INode.Kind.CALL_CHAIN) {
              for (              Field fo : finalOrWithEmptyInitializer) {
                final String id=fo.getIdentifier().toKotlin();
                if (((CallChainExpression)assignmentExpression.getLeft()).getIdentifier().toKotlin().endsWith("." + id)) {
                  initializers.put(id,assignmentExpression.getRight().toKotlin());
                  isRemoved=true;
                }
              }
            }
          }
          if (!isRemoved) {
            newStatements.add(s);
          }
        }
        newStatements.add(0,new DummyStringStatement("val __ = " + createPrimaryConstructorInvocation(name.toKotlin(),finalOrWithEmptyInitializer,initializers)));
        f.setBlock(new Block(newStatements));
      }
    }
    methods.add(new Constructor(Identifier.EMPTY_IDENTIFIER,Collections.<String>emptySet(),new ClassType(name,false),Collections.<Element>emptyList(),new ParameterList(createParametersFromFields(finalOrWithEmptyInitializer)),new Block(createInitStatementsFromFields(finalOrWithEmptyInitializer)),true));
  }
  if (psiClass.isInterface())   return new Trait(name,modifiers,typeParameters,extendsTypes,Collections.<Expression>emptyList(),implementsTypes,innerClasses,methods,fields);
  if (psiClass.isEnum())   return new Enum(name,modifiers,typeParameters,Collections.<Type>emptyList(),Collections.<Expression>emptyList(),implementsTypes,innerClasses,methods,fieldsToFieldListForEnums(psiClass.getAllFields()));
  return new Class(name,modifiers,typeParameters,extendsTypes,baseClassParams,implementsTypes,innerClasses,methods,fields);
}
