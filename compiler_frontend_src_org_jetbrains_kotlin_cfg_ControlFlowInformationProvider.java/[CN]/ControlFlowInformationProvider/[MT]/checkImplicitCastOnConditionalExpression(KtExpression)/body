{
  Collection<KtExpression> branchExpressions=collectResultingExpressionsOfConditionalExpression(expression);
  KotlinType expectedExpressionType=trace.get(EXPECTED_EXPRESSION_TYPE,expression);
  if (expectedExpressionType != null && expectedExpressionType != DONT_CARE)   return;
  KotlinType expressionType=trace.getType(expression);
  if (expressionType == null) {
    return;
  }
  if (KotlinBuiltIns.isAnyOrNullableAny(expressionType)) {
    boolean isUsedAsResultOfLambda=BindingContextUtilsKt.isUsedAsResultOfLambda(expression,trace.getBindingContext());
    for (    KtExpression branchExpression : branchExpressions) {
      if (branchExpression == null)       continue;
      KotlinType branchType=trace.getType(branchExpression);
      if (branchType == null || KotlinBuiltIns.isAnyOrNullableAny(branchType) || (isUsedAsResultOfLambda && KotlinBuiltIns.isUnitOrNullableUnit(branchType))) {
        return;
      }
    }
    for (    KtExpression branchExpression : branchExpressions) {
      if (branchExpression == null)       continue;
      KotlinType branchType=trace.getType(branchExpression);
      if (branchType == null)       continue;
      if (KotlinBuiltIns.isNothing(branchType))       continue;
      trace.report(IMPLICIT_CAST_TO_ANY.on(getResultingExpression(branchExpression),branchType,expressionType));
    }
  }
}
