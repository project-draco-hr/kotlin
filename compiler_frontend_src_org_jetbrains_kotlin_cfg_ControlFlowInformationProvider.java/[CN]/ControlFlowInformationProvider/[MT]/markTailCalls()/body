{
  final DeclarationDescriptor subroutineDescriptor=trace.get(BindingContext.DECLARATION_TO_DESCRIPTOR,subroutine);
  if (!(subroutineDescriptor instanceof FunctionDescriptor))   return;
  if (!((FunctionDescriptor)subroutineDescriptor).isTailrec())   return;
class KindAndCall {
    TailRecursionKind kind;
    private final ResolvedCall<?> call;
    KindAndCall(    TailRecursionKind kind,    ResolvedCall<?> call){
      this.kind=kind;
      this.call=call;
    }
  }
  final Map<KtElement,KindAndCall> calls=new HashMap<KtElement,KindAndCall>();
  PseudocodeTraverserKt.traverse(pseudocode,TraversalOrder.FORWARD,new FunctionVoid1<Instruction>(){
    @Override public void execute(    @NotNull Instruction instruction){
      if (!(instruction instanceof CallInstruction))       return;
      CallInstruction callInstruction=(CallInstruction)instruction;
      ResolvedCall<?> resolvedCall=CallUtilKt.getResolvedCall(callInstruction.getElement(),trace.getBindingContext());
      if (resolvedCall == null)       return;
      CallableDescriptor functionDescriptor=resolvedCall.getResultingDescriptor();
      if (!functionDescriptor.getOriginal().equals(subroutineDescriptor))       return;
      if (resolvedCall.getCall().getValueArguments().size() != functionDescriptor.getValueParameters().size() && !functionDescriptor.getOverriddenDescriptors().isEmpty())       return;
      KtElement element=callInstruction.getElement();
      KtExpression parent=PsiTreeUtil.getParentOfType(element,KtTryExpression.class,KtFunction.class,KtAnonymousInitializer.class);
      if (parent instanceof KtTryExpression) {
        calls.put(element,new KindAndCall(IN_TRY,resolvedCall));
        return;
      }
      boolean isTail=PseudocodeTraverserKt.traverseFollowingInstructions(callInstruction,new HashSet<Instruction>(),TraversalOrder.FORWARD,new TailRecursionDetector(subroutine,callInstruction));
      boolean sameDispatchReceiver=ResolvedCallUtilKt.hasThisOrNoDispatchReceiver(resolvedCall,trace.getBindingContext());
      TailRecursionKind kind=isTail && sameDispatchReceiver ? TAIL_CALL : NON_TAIL;
      KindAndCall kindAndCall=calls.get(element);
      calls.put(element,new KindAndCall(combineKinds(kind,kindAndCall == null ? null : kindAndCall.kind),resolvedCall));
    }
  }
);
  boolean hasTailCalls=false;
  for (  Map.Entry<KtElement,KindAndCall> entry : calls.entrySet()) {
    KtElement element=entry.getKey();
    KindAndCall kindAndCall=entry.getValue();
switch (kindAndCall.kind) {
case TAIL_CALL:
      trace.record(TAIL_RECURSION_CALL,kindAndCall.call.getCall(),TailRecursionKind.TAIL_CALL);
    hasTailCalls=true;
  break;
case IN_TRY:
trace.report(Errors.TAIL_RECURSION_IN_TRY_IS_NOT_SUPPORTED.on(element));
break;
case NON_TAIL:
trace.report(Errors.NON_TAIL_RECURSIVE_CALL.on(element));
break;
}
}
if (!hasTailCalls) {
trace.report(Errors.NO_TAIL_CALLS_FOUND.on((KtNamedFunction)subroutine));
}
}
