{
  RedundantBoxingInterpreter interpreter=new RedundantBoxingInterpreter(node.instructions);
  Analyzer<BasicValue> analyzer=new Analyzer<BasicValue>(interpreter);
  Frame<BasicValue>[] frames=runAnalyzer(analyzer,internalClassName,node);
  Set<BoxedBasicValue> valuesToOptimize=filterSafeToRemoveValues(interpreter.getCandidatesBoxedValues());
  if (!valuesToOptimize.isEmpty()) {
    findValuesClashingWithVariables(node,frames);
    valuesToOptimize=filterSafeToRemoveValues(valuesToOptimize);
    adaptLocalVariableTableForBoxedValues(node,frames);
    applyVariablesRemapping(node,buildVariablesRemapping(valuesToOptimize,node));
    adaptInstructionsForBoxedValues(node,frames,valuesToOptimize);
  }
  super.transform(internalClassName,node);
}
