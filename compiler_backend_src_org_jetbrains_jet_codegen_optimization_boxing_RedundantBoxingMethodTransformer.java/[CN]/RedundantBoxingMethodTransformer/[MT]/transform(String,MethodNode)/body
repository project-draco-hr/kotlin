{
  RedundantBoxingInterpreter interpreter=new RedundantBoxingInterpreter(node.instructions);
  Analyzer<BasicValue> analyzer=new Analyzer<BasicValue>(interpreter);
  Frame<BasicValue>[] frames=runAnalyzer(analyzer,internalClassName,node);
  RedundantBoxedValuesCollection valuesToOptimize=interpreter.getCandidatesBoxedValues();
  if (!valuesToOptimize.isEmpty()) {
    removeValuesClashingWithVariables(valuesToOptimize,node,frames);
    adaptLocalVariableTableForBoxedValues(node,frames);
    applyVariablesRemapping(node,buildVariablesRemapping(valuesToOptimize,node));
    adaptInstructionsForBoxedValues(node,frames,valuesToOptimize);
  }
  super.transform(internalClassName,node);
}
