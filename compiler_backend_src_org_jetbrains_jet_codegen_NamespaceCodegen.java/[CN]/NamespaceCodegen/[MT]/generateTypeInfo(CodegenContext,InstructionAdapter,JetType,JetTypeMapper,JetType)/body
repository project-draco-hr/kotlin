{
  String knownTypeInfo=typeMapper.isKnownTypeInfo(jetType);
  if (knownTypeInfo != null) {
    v.getstatic("jet/TypeInfo",knownTypeInfo,"Ljet/TypeInfo;");
    return;
  }
  DeclarationDescriptor declarationDescriptor=jetType.getConstructor().getDeclarationDescriptor();
  if (!jetType.equals(root) && jetType.getArguments().size() == 0 && !JetStandardClasses.getAny().equals(declarationDescriptor)) {
    v.getstatic(typeMapper.mapType(jetType,OwnerKind.IMPLEMENTATION).getInternalName(),JvmAbi.TYPE_INFO_FIELD,"Ljet/TypeInfo;");
    return;
  }
  boolean hasUnsubstituted=TypeUtils.hasUnsubstitutedTypeParameters(jetType);
  if (!jetType.equals(root) && !hasUnsubstituted) {
    int typeInfoConstantIndex=context.getTypeInfoConstantIndex(jetType);
    v.invokestatic(context.getNamespaceClassName(),"$getCachedTypeInfo$" + typeInfoConstantIndex,"()Ljet/TypeInfo;");
    return;
  }
  final Type jvmType=typeMapper.mapType(jetType);
  v.aconst(jvmType);
  v.iconst(jetType.isNullable() ? 1 : 0);
  List<TypeProjection> arguments=jetType.getArguments();
  if (arguments.size() > 0 && !(jvmType.getSort() == Type.ARRAY && JetTypeMapper.correctElementType(jvmType).getSort() != Type.OBJECT)) {
    v.iconst(arguments.size());
    v.newarray(JetTypeMapper.TYPE_TYPEINFOPROJECTION);
    for (int i=0, argumentsSize=arguments.size(); i < argumentsSize; i++) {
      TypeProjection argument=arguments.get(i);
      v.dup();
      v.iconst(i);
      generateTypeInfo(context,v,argument.getType(),typeMapper,root);
      ExpressionCodegen.genTypeInfoToProjection(v,argument.getProjectionKind());
      v.astore(JetTypeMapper.TYPE_OBJECT);
    }
    v.invokestatic("jet/TypeInfo",JvmStdlibNames.JET_OBJECT_GET_TYPEINFO_METHOD,"(Ljava/lang/Class;Z[Ljet/typeinfo/TypeInfoProjection;)Ljet/TypeInfo;");
  }
 else {
    v.invokestatic("jet/TypeInfo",JvmStdlibNames.JET_OBJECT_GET_TYPEINFO_METHOD,"(Ljava/lang/Class;Z)Ljet/TypeInfo;");
  }
}
