{
  getResolverScopeData(scopeData);
  PsiType returnPsiType=method.getReturnType();
  if (returnPsiType == null) {
    return null;
  }
  if (method.getJetMethod().flags().get(JvmStdlibNames.JET_METHOD_FLAG_PROPERTY_BIT)) {
    return null;
  }
  if (scopeData.kotlin) {
    String ownerClassName=method.getPsiMethod().getContainingClass().getQualifiedName();
    if (ownerClassName.equals("java.lang.Object")) {
      return null;
    }
  }
  SimpleFunctionDescriptorImpl functionDescriptorImpl=new SimpleFunctionDescriptorImpl(scopeData.classOrNamespaceDescriptor,resolveAnnotations(method.getPsiMethod()),Name.identifier(method.getName()),CallableMemberDescriptor.Kind.DECLARATION);
  String context="method " + method.getName() + " in class "+ psiClass.getQualifiedName();
  List<TypeParameterDescriptor> methodTypeParameters=resolveMethodTypeParameters(method,functionDescriptorImpl);
  TypeVariableResolver methodTypeVariableResolver=TypeVariableResolvers.typeVariableResolverFromTypeParameters(methodTypeParameters,functionDescriptorImpl,context);
  ValueParameterDescriptors valueParameterDescriptors=resolveParameterDescriptors(functionDescriptorImpl,method.getParameters(),methodTypeVariableResolver);
  JetType returnType=makeReturnType(returnPsiType,method,methodTypeVariableResolver);
  String signature=method.getSignatureAnnotation().signature();
  if (!signature.isEmpty()) {
    try {
      JetNamedFunction altFunDeclaration=JetPsiFactory.createFunction(project,signature);
      AlternativeSignatureParsing.checkForSyntaxErrors(method,altFunDeclaration);
      ValueParameterDescriptors altValueParameters=AlternativeSignatureParsing.computeAlternativeValueParameters(valueParameterDescriptors,altFunDeclaration);
      JetTypeReference returnTypeRef=altFunDeclaration.getReturnTypeRef();
      JetType altReturnType=returnTypeRef != null ? AlternativeSignatureParsing.computeAlternativeTypeFromAnnotation(returnTypeRef.getTypeElement(),returnType) : returnType;
      List<TypeParameterDescriptor> altTypeParameters=AlternativeSignatureParsing.computeAlternativeTypeParameters(methodTypeParameters,altFunDeclaration);
      valueParameterDescriptors=altValueParameters;
      returnType=altReturnType;
      methodTypeParameters=altTypeParameters;
    }
 catch (    AlternativeSignatureMismatchException e) {
      scopeData.addAlternativeSignatureError(e.getMessage());
    }
  }
  functionDescriptorImpl.initialize(valueParameterDescriptors.receiverType,DescriptorUtils.getExpectedThisObjectIfNeeded(scopeData.classOrNamespaceDescriptor),methodTypeParameters,valueParameterDescriptors.descriptors,returnType,resolveModality(method,method.isFinal()),resolveVisibilityFromPsiModifiers(method.getPsiMethod()),false);
  trace.record(BindingContext.FUNCTION,method.getPsiMethod(),functionDescriptorImpl);
  BindingContextUtils.recordFunctionDeclarationToDescriptor(trace,method.getPsiMethod(),functionDescriptorImpl);
  FunctionDescriptor substitutedFunctionDescriptor=functionDescriptorImpl;
  if (method.getPsiMethod().getContainingClass() != psiClass && !method.isStatic()) {
    throw new IllegalStateException("non-static method in subclass");
  }
  return (FunctionDescriptorImpl)substitutedFunctionDescriptor;
}
