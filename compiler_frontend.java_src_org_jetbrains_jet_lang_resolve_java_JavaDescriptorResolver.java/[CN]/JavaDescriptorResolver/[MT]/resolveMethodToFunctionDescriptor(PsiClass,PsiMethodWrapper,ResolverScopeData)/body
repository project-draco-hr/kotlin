{
  getResolverScopeData(scopeData);
  PsiType returnPsiType=method.getReturnType();
  if (returnPsiType == null) {
    return null;
  }
  if (method.getJetMethod().kind() == JvmStdlibNames.JET_METHOD_KIND_PROPERTY) {
    return null;
  }
  if (scopeData.kotlin) {
    String ownerClassName=method.getPsiMethod().getContainingClass().getQualifiedName();
    if (ownerClassName.equals("java.lang.Object")) {
      return null;
    }
  }
  SimpleFunctionDescriptorImpl functionDescriptorImpl=new SimpleFunctionDescriptorImpl(scopeData.classOrNamespaceDescriptor,resolveAnnotations(method.getPsiMethod()),Name.identifier(method.getName()),CallableMemberDescriptor.Kind.DECLARATION);
  String context="method " + method.getName() + " in class "+ psiClass.getQualifiedName();
  List<TypeParameterDescriptor> methodTypeParameters=resolveMethodTypeParameters(method,functionDescriptorImpl);
  TypeVariableResolver methodTypeVariableResolver=TypeVariableResolvers.typeVariableResolverFromTypeParameters(methodTypeParameters,functionDescriptorImpl,context);
  ValueParameterDescriptors valueParameterDescriptors=resolveParameterDescriptors(functionDescriptorImpl,method.getParameters(),methodTypeVariableResolver);
  JetType returnType=makeReturnType(returnPsiType,method,methodTypeVariableResolver);
  String signature=method.getSignatureAnnotation().signature();
  if (!signature.isEmpty()) {
    try {
      JetNamedFunction altFunDeclaration=JetPsiFactory.createFunction(project,signature);
      List<PsiErrorElement> syntaxErrors=AnalyzingUtils.getSyntaxErrorRanges(altFunDeclaration);
      if (!syntaxErrors.isEmpty()) {
        String textSignature=String.format("%s(%s)",method.getName(),StringUtil.join(method.getPsiMethod().getSignature(PsiSubstitutor.EMPTY).getParameterTypes(),new Function<PsiType,String>(){
          @Override public String fun(          PsiType psiType){
            return psiType.getPresentableText();
          }
        }
,", "));
        int errorOffset=syntaxErrors.get(0).getTextOffset();
        String syntaxErrorDescription=syntaxErrors.get(0).getErrorDescription();
        String errorText=syntaxErrors.size() == 1 ? String.format("Alternative signature for %s has syntax error at %d: %s",textSignature,errorOffset,syntaxErrorDescription) : String.format("Alternative signature for %s has %d syntax errors, first is at %d: %s",textSignature,syntaxErrors.size(),errorOffset,syntaxErrorDescription);
        throw new AlternativeSignatureMismatchException(errorText);
      }
 else {
        valueParameterDescriptors=AlternativeSignatureParsing.computeAlternativeValueParameters(valueParameterDescriptors,altFunDeclaration);
        JetTypeReference returnTypeRef=altFunDeclaration.getReturnTypeRef();
        if (returnTypeRef != null) {
          returnType=AlternativeSignatureParsing.computeAlternativeTypeFromAnnotation(returnTypeRef.getTypeElement(),returnType);
        }
        methodTypeParameters=AlternativeSignatureParsing.computeAlternativeTypeParameters(methodTypeParameters,altFunDeclaration);
      }
    }
 catch (    AlternativeSignatureMismatchException e) {
      scopeData.addAlternativeSignatureError(e.getMessage());
    }
  }
  functionDescriptorImpl.initialize(valueParameterDescriptors.receiverType,DescriptorUtils.getExpectedThisObjectIfNeeded(scopeData.classOrNamespaceDescriptor),methodTypeParameters,valueParameterDescriptors.descriptors,returnType,Modality.convertFromFlags(method.getPsiMethod().hasModifierProperty(PsiModifier.ABSTRACT),!method.isFinal()),resolveVisibilityFromPsiModifiers(method.getPsiMethod()),false);
  trace.record(BindingContext.FUNCTION,method.getPsiMethod(),functionDescriptorImpl);
  BindingContextUtils.recordFunctionDeclarationToDescriptor(trace,method.getPsiMethod(),functionDescriptorImpl);
  FunctionDescriptor substitutedFunctionDescriptor=functionDescriptorImpl;
  if (method.getPsiMethod().getContainingClass() != psiClass && !method.isStatic()) {
    throw new IllegalStateException("non-static method in subclass");
  }
  return (FunctionDescriptorImpl)substitutedFunctionDescriptor;
}
