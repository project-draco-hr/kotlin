{
  getResolverScopeData(scopeData);
  PsiType returnPsiType=method.getReturnType();
  if (returnPsiType == null) {
    return null;
  }
  if (method.getJetMethod().kind() == JvmStdlibNames.JET_METHOD_KIND_PROPERTY) {
    return null;
  }
  if (scopeData.kotlin) {
    String ownerClassName=method.getPsiMethod().getContainingClass().getQualifiedName();
    if (ownerClassName.equals("java.lang.Object")) {
      return null;
    }
  }
  SimpleFunctionDescriptorImpl functionDescriptorImpl=new SimpleFunctionDescriptorImpl(scopeData.classOrNamespaceDescriptor,resolveAnnotations(method.getPsiMethod()),Name.identifier(method.getName()),CallableMemberDescriptor.Kind.DECLARATION);
  String context="method " + method.getName() + " in class "+ psiClass.getQualifiedName();
  List<TypeParameterDescriptor> methodTypeParameters=resolveMethodTypeParameters(method,functionDescriptorImpl);
  TypeVariableResolver methodTypeVariableResolver=TypeVariableResolvers.typeVariableResolverFromTypeParameters(methodTypeParameters,functionDescriptorImpl,context);
  ValueParameterDescriptors valueParameterDescriptors=resolveParameterDescriptors(functionDescriptorImpl,method.getParameters(),methodTypeVariableResolver);
  JetType returnType=makeReturnType(returnPsiType,method,methodTypeVariableResolver);
  String signature=method.getSignatureAnnotation().signature();
  if (!signature.isEmpty()) {
    JetNamedFunction altFunDeclaration=JetPsiFactory.createFunction(project,signature);
    valueParameterDescriptors=AlternativeSignatureParsing.computeAlternativeValueParameters(valueParameterDescriptors,altFunDeclaration);
    JetTypeReference returnTypeRef=altFunDeclaration.getReturnTypeRef();
    if (returnTypeRef != null) {
      returnType=AlternativeSignatureParsing.computeAlternativeTypeFromAnnotation(returnTypeRef.getTypeElement(),returnType);
    }
    methodTypeParameters=AlternativeSignatureParsing.computeAlternativeTypeParameters(methodTypeParameters,altFunDeclaration);
  }
  functionDescriptorImpl.initialize(valueParameterDescriptors.receiverType,DescriptorUtils.getExpectedThisObjectIfNeeded(scopeData.classOrNamespaceDescriptor),methodTypeParameters,valueParameterDescriptors.descriptors,returnType,Modality.convertFromFlags(method.getPsiMethod().hasModifierProperty(PsiModifier.ABSTRACT),!method.isFinal()),resolveVisibilityFromPsiModifiers(method.getPsiMethod()),false);
  trace.record(BindingContext.FUNCTION,method.getPsiMethod(),functionDescriptorImpl);
  BindingContextUtils.recordFunctionDeclarationToDescriptor(trace,method.getPsiMethod(),functionDescriptorImpl);
  FunctionDescriptor substitutedFunctionDescriptor=functionDescriptorImpl;
  if (method.getPsiMethod().getContainingClass() != psiClass && !method.isStatic()) {
    throw new IllegalStateException("non-static method in subclass");
  }
  return (FunctionDescriptorImpl)substitutedFunctionDescriptor;
}
